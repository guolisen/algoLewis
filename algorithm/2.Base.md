[TOC]
# 排序

https://www.algolist.net/Algorithms/Sorting/Selection_sort
https://www.algolist.net/Algorithms/Sorting/Quicksort
https://www.algolist.net/Algorithms/Sorting/Insertion_sort
https://www.algolist.net/Algorithms/Sorting/Bubble_sort
https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html

## 快速排序

### 143 · Sort Colors II
```
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
# 双指针
### 56 · Two Sum

```
    vector<int> twoSum(vector<int> &numbers, int target) {
        int m = numbers.size();
        vector<int> res;
        for (int i = 0; i < m - 1; i++)
        {
            for (int j = i + 1; j < m; j++)
            {
                if (numbers[i] + numbers[j] == target)
                {
                    res.push_back(i);
                    res.push_back(j);
                    return res;
                }
            }
        }
        return {-1, -1};
    }
```
### 59 · 3Sum Closest
```
    int threeSumClosest(vector<int> &numbers, int target) {
        if (numbers.empty())
            return 100000000;
        sort(numbers.begin(), numbers.end());
        int m = numbers.size();
        int minv = INT_MAX;
        for (int i = 0; i < m - 1; ++i)
        {
            int l = i + 1;
            int r = m - 1;
            while (l < r)
            {
                int sum = numbers[i] + numbers[l]  + numbers[r];
                if (abs(sum - target) < abs(minv - target))
                {
                    minv = sum;               
                }

                if (sum < target)
                {
                    l++;
                }
                else
                {
                    r--;
                }
            }

        }
        return minv;
    }
```
### 64 · Merge Sorted Array(6 · Merge Two Sorted Arrays)

```
    void mergeSortedArray(int A[], int m, int B[], int n) {
        int ai = 0;
        int bi = 0;
        vector<int> ires;
        while (ai < m && bi < n)
        {
            if (A[ai] <= B[bi])
            {
                ires.push_back(A[ai++]);
            }
            else
            {
                ires.push_back(B[bi++]);
            }
        }
        while (ai < m)
        {
            ires.push_back(A[ai++]);
        }
        while (bi < n)
        {
            ires.push_back(B[bi++]);
        }

        int i = 0;
        for (auto n : ires)
        {
            A[i++] = n;
        }
    }
```
Second method:
```
    vector<int> mergeSortedArray(vector<int> &A, vector<int> &B) {
        int m = A.size();
        int n = B.size();
        vector<int> res;
        int ai = 0;
        int bi = 0;
        for (int k = 0; k < m + n; ++k)
        {
            if (ai < m && (bi == n || A[ai] < B[bi]))
            {
                res.push_back(A[ai++]);
            }
            else
            {
                res.push_back(B[bi++]);
            }
        }
        return res;
    }
```
In one array
```
    void mergeSortedArray(int A[], int m, int B[], int n) {
        int ri = m + n - 1;
        int ai = m - 1;
        int bi = n - 1;

        while (ai >= 0 && bi >= 0)
        {
            if (A[ai] > B[bi])
            {
                A[ri--] = A[ai--];
            }
            else
            {
                A[ri--] = B[bi--];
            }
        }
        while (bi >= 0)
        {
            A[ri--] = B[bi--];
        }
    }
```
### 165 · Merge Two Sorted Lists

```
    ListNode * mergeTwoLists(ListNode * l1, ListNode * l2) {
        if (!l1) return l2;
        if (!l2) return l1;
        ListNode* head = nullptr;
        if (l1->val < l2->val)
        {
            head = l1;
            head->next = mergeTwoLists(l1->next, l2);
        }
        else
        {
            head = l2;
            head->next = mergeTwoLists(l1, l2->next);
        }
        return head;
    }
```
1246 · Longest Repeating Character Replacement
同向双指针

```
    int characterReplacement(string &s, int k) {
        int m = s.size();
        int res = 0;
        for (int c = 'A'; c <= 'Z'; ++c)
        {
            int count = 0;
            for (int i = 0, j = 0; i < m; i++)
            {
                if (s[i] == c)
                    count++;                           
                while (i - j + 1 - count > k)
                {
                    if (s[j] == c)
                        count--;
                    j++;                      
                }
                res = max(res, i - j + 1);
            }
        }

        return res;
    }
```
### 460 · Find K Closest Elements
```
class Solution {
public:
    bool isClosed(vector<int>& A, int target, int l, int r)
    {
        if (l < 0)
            return false;
        if (r >= A.size())
            return true;
        if ((target - A[l]) != (A[r] - target))
            return (target - A[l]) < (A[r] - target);
        return true;
    }
    vector<int> kClosestNumbers(vector<int> &A, int target, int k) {
        int m = A.size();
        int l = 0;
        int r = m - 1;
        while (l < r)
        {
            int mid = (l + r + 1) / 2;
            if (A[mid] <= target)
            {
                l = mid;
            }
            else
            {
                r = mid - 1;
            }
        }
        int lpos = l;
        int rpos = l + 1;
        vector<int> res;
        while (res.size() < k)
        {
            if (isClosed(A, target, lpos, rpos))
            {
                res.push_back(A[lpos--]);
            }
            else
            {
                res.push_back(A[rpos++]);
            }
        }

        return res;
    }
};
```

## 滑动窗口
### 384 · Longest Substring Without Repeating Characters
```
class Solution {
public:
    int lengthOfLongestSubstring(string &s) {
        int m = s.size();
        int j = 0;
        int res = 0;
        unordered_map<char, int> hash;
        for (int i = 0; i < m; i++)
        {
            while (j < m && !hash.count(s[j]))
            {
                hash[s[j]]++;
                j++;
            }
            res = max(res, (int)hash.size());
            if (hash[s[i]])
            {
                hash[s[i]]--;
                if (!hash[s[i]])
                    hash.erase(s[i]);
            }
        }
        return res;
    }
};
```

### 386 · Longest Substring with At Most K Distinct Characters

```
class Solution {
public:
    int lengthOfLongestSubstringKDistinct(string &s, int k) {
        int m = s.length();
        int sum = 0;
        int res = 0;
        unordered_map<char, int> hash;
        for (int r = 0, l = 0; r < m; r++)
        {
            hash[s[r]]++;
            if (hash[s[r]] == 1)
            {
                sum++;
            }
            while (sum > k)
            {
                if (hash[s[l]])
                {
                    hash[s[l]]--;
                }
                if (!hash[s[l]])
                {
                    sum--;
                }
                l++;
            }
            res = max(res, r - l + 1);
        }
        return res;
    }
};
```
### 32 · Minimum Window Substring
```
class Solution {
public:
    string minWindow(string &source , string &target) {
        int m = source.length();
        int n = target.length();
        unordered_map<char, int> shash;
        unordered_map<char, int> thash;
        for (auto t : target)
        {
            thash[t]++;
        }

        int sum = 0;
        int l = 0;
        string res;
        for (int r = 0; r < m; r++)
        {
            shash[source[r]]++;
            if (thash.count(source[r]) && shash[source[r]] <= thash[source[r]])
                sum++;
            while (shash[source[l]] > thash[source[l]]) 
            {
                shash[source[l++]]--;
            }
            if (sum == n)
            {
                if (res.empty() || res.length() > r - l + 1)
                {
                    res = source.substr(l, r - l + 1);
                }
            }
        }
        return res;
    }
};
```
### 1643 · Pick Fruits
```
class Solution {
public:
    int pickFruits(vector<int> &arr) {
        if (arr.empty())
            return 1;
        int m = arr.size();
        unordered_map<int, int> hash;
        int count = 0;
        int res = 0;
        for (int r = 0, l = 0; r < m; r++)
        {
            hash[arr[r]]++;
            if (hash[arr[r]] == 1)
            {
                count++;
            }
            while (count > 2)
            {
                hash[arr[l]]--;
                if (hash[arr[l]] == 0)
                {
                    count--;
                }
                l++;
            }
            res = max(res, r - l + 1);
        }
        return res;
    }
};
```
### 647 · Find All Anagrams in a String
```
class Solution {
public:
    vector<int> findAnagrams(string &s, string &p) {
        int m = s.size();
        int n = p.size();

        unordered_map<char, int> hash;
        for (auto c : p)
        {
            hash[c]++;
        }
        int match = 0;
        int start = 0;
        int end = 0;
        vector<int> res;
        while(end <= m)
        {
            if (hash[s[end]] >= 1)
                match++;
            hash[s[end]]--;
            end++;
            if (match == n)
                res.push_back(start);
            if (end - start == n)
            {
                if (hash[s[start]] >= 0)
                {
                    match--;
                }
                hash[s[start]]++;
                start++;
            }
        }
        return res;
    }
};
```
### 1375 · Substring With At Least K Distinct Characters
```
class Solution {
public:
    long long kDistinctCharacters(string &s, int k) {
        int m = s.size();
        unordered_map<char, int> hash;
        int j = 0;
        long long res = 0;
        for (int i = 0; i < m; i++)
        {
            while (j < m && hash.size() < k)
            {
                hash[s[j]]++;
                j++;
            }
            if (hash.size() >= k)
            {
                res += m - j + 1;
            }
            if (hash[s[i]])
            {
                hash[s[i]]--;
                if (hash[s[i]] == 0)
                {
                    hash.erase(s[i]);
                }
            }
        }
        return res;
    }
};
```
### 386 · Longest Substring with At Most K Distinct Characters
同向双指针
```
class Solution {
public:
    int lengthOfLongestSubstringKDistinct(string &s, int k) {
        if (k == 0)
            return 0;
        int m = s.size();
        int res = 0;
        int i = 0;
        unordered_map<char, int> hash;
        for (int j = 0; j < m; j++)
        {
            hash[s[j]]++;
            while (hash.size() > k)
            {
                if (hash[s[i]])
                {
                    hash[s[i]]--;
                    if (!hash[s[i]])
                    {
                        hash.erase(s[i]);
                    }
                    i++;
                }
            }
            res = max (res, j - i + 1);
        }
        return res;
    }
};
```


## 单调栈 O(n)

给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。
```
#include <iostream>
using namespace std;
const int N = 100010;
int stk[N], tt;

int main()
{
    int n;
    cin >> n;
    while (n -- )
    {
        int x;
        scanf("%d", &x);
        while (tt && stk[tt] >= x) tt -- ;//* 如果栈顶元素大于当前待入栈元素，则出栈
        if (!tt) printf("-1 ");//如果栈空，则没有比该元素小的值。
        else printf("%d ", stk[tt]);//栈顶元素就是左侧第一个比它小的元素。
        stk[ ++ tt] = x;
    }
    return 0;
}
```
### 1852 · Final Discounted Price
```
class Solution {
public:
    vector<int> FinalDiscountedPrice(vector<int> &prices) {
        int m = prices.size();
        stack<int> s;
        vector<int> res(m, 0);

        for (int i = 0; i < m; i++)
        {
            res[i] = prices[i];
        }

        for (int i = 0; i < m; i++)
        {
            while (!s.empty() && prices[s.top()] >= prices[i])
            {
                int index = s.top();
                s.pop();
                res[index] = prices[index] - prices[i];
            }
            s.push(i);
        }
        return res;
    }
};
```
### 122 · Largest Rectangle in Histogram
就是找某一个柱形左右连边小于他的柱形，以他们作为边界，中间的部分为最大矩形
```
class Solution {
public:
    int largestRectangleArea(vector<int> &heights) {
        if (heights.empty())
            return 0;
        int m = heights.size();
        stack<int> st;
        int res = 0;
        for (int i = 0; i <= m; i++)
        {
            int curheight = (i == m)? -1 : heights[i];
            while (!st.empty() && heights[st.top()] >= curheight)
            {
                int h = heights[st.top()]; st.pop();
                int w = st.empty()? i : (i - st.top() - 1);
                res = max(res, h * w);
            }
            st.push(i);
        }
        return res;
    }
};
```


## 单调队列

### 362 · Sliding Window Maximum （求滑动窗口中的最大值）
维护单调队列，可以对该队列进行各种查找，二分
```
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int> &nums, int k) {
        int m = nums.size();
        deque<int> dq;
        vector<int> res;
        for (int i = 0; i < m; i++)
        {
            // 弹出出窗的元素
            if (!dq.empty() && i - k + 1 > dq.front()) dq.pop_front();
            // 弹出比当前值小的元素，保证单调性
            while (!dq.empty() && nums[dq.back()] <= nums[i]) dq.pop_back();
            dq.push_back(i);
            if (i >= k - 1)
                res.push_back(nums[dq.front()]);
        }
        return res;
    }
};
```

# 二分查找
### 1219 · Heaters
"<=" 返回的是左边第一个最大的，“>=”是右边第一个最小的 
```
class Solution {
public:
    int getMinRadio(vector<int> &heaters, int house)
    {
        int m = heaters.size();
        int l = 0;
        int r = m - 1;
        while (l < r)
        {
            int mid = (l + r) / 2;
            if (heaters[mid] >= house)
            {
                r = mid;
            }
            else
            {
                l = mid + 1;
            }
        }
        int rpos = l;
        l = 0;
        r = m - 1;
        while (l < r)
        {
            int mid = (l + r + 1) / 2;
            if (heaters[mid] <= house)
            {
                l = mid;
            }
            else
            {
                r = mid - 1;
            }
        }
        int lpos = l;
        int lv = abs(heaters[lpos] - house);
        int rv = abs(heaters[rpos] - house);
        return lv < rv ? lv : rv;
    }
    int findRadius(vector<int> &houses, vector<int> &heaters) {
        sort(heaters.begin(), heaters.end());
        int m = houses.size();
        int res = 0;
        for (int i = 0; i < m; i++)
        {
            int dist = getMinRadio(heaters, houses[i]);
            res = max(res, dist);
        }
        return res;
    }
};
```

### 61 · Search for a Range
### 462 · Total Occurrence of Target

```
class Solution {
public:
    int totalOccurrence(vector<int> &A, int target) {
        if (A.empty())
            return 0;
        int m = A.size();
        int l = 0;
        int r = m - 1;
        while (l < r)
        {
            int mid = (l + r) / 2;
            if (A[mid] >= target)
            {
                r = mid;
            }
            else
            {
                l = mid + 1;
            }
        }

        if (A[l] != target)
            return 0;

        int left = l;
        l = 0;
        r = m - 1;
        while (l < r)
        {
            int mid = (l + r + 1) / 2;
            if (A[mid] <= target)
            {
                l = mid;
            }
            else
            {
                r = mid - 1;
            }
        }
        int right = r;

        return right - left + 1;
    }
};
```
STL 版
```
class Solution {
public:
    int totalOccurrence(vector<int> &A, int target) {
        if (A.empty())
            return 0;
        auto left  = std::lower_bound(A.begin(), A.end(), target);
        if (left == A.end())
            return 0;
        auto right = std::upper_bound(A.begin(), A.end(), target);
        return std::distance(left, right);
    }
};
```
### 74 · First Bad Version
```
    int binarySearch(int l, int r)
    {
        if (l > r) return INT_MAX;
        int mid = l + (r - l) / 2;
        if (SVNRepo::isBadVersion(mid)) 
            return std::min(mid, binarySearch(l, mid - 1));
        return binarySearch(mid + 1, r);
    }
```
### 585 · Maximum Number in Mountain Sequence
查找山峰山谷
```
class Solution {
public:
    bool check(vector<int>& nums, int mid)
    {
        int m = nums.size();
        if (mid + 1 < m)
        {
            if (nums[mid + 1] > nums[mid])
            {
                return false;
            }
        }
        return true;
    }
    int mountainSequence(vector<int> &nums) {
        int m = nums.size();
        int l = 0; 
        int r = m - 1;
        while (l < r)
        {
            int mid = (l + r) / 2;
            if (check(nums, mid))
            {
                r = mid;
            }
            else
            {
                l = mid + 1;
            }
        }
        return nums[l];
    }
};
```
### 159 · Find Minimum in Rotated Sorted Array
要和左端点比较
```
class Solution {
public:
    int findMin(vector<int> &nums) {
        int m = nums.size();
        int l = 0;
        int r = m - 1;

        while (l < r)
        {
            if (nums[l] <= nums[r])
                return nums[l];
            int mid = (l + r) / 2;
            if (nums[mid] < nums[l])
            {
                r = mid;
            }
            else
            {
                l = mid + 1;
            }
        }
        return nums[l];
    }
};
```

### 183 · Wood Cut

在结果值域上二分，check() 返回的是包含正确结果的check(带=的)，所以应该由l = mid或r= mid处理
```
class Solution {
public:
    bool check(vector<int> &L, long mid, int k)
    {
        long divide = 0;
        for (auto n : L)
        {
            divide += n / mid;
        }
        if (divide >= k)
        {
            return true;
        }

        return false;
    }
    int woodCut(vector<int> &L, int k) {
        if (L.empty())
            return 0;
        int len = L.size();
        long minVal = -9999999999;
        for (auto n : L)
        {
            if (n > minVal)
                minVal = n;
        }

        long l = 0;
        long r = minVal;
        
        while (l < r)
        {
            long mid = (l + r + 1) / 2;
            if (check(L, mid, k))
            {
               l = mid;
            }
            else
            {
                r = mid - 1;
            }
        }

        return l;
    }
};
```
### 438 · Copy Books II
```
class Solution {
public:
    bool check(int n, vector<int>& times, int mid)
    {
        int most = 0;
        for (auto t : times)
        {
            most += mid / t;
        }
        return n <= most;
    }
    int copyBooksII(int n, vector<int> &times) {
        int m = times.size();
        int mint = 0x3f3f3f3f;
        for (auto t : times)
        {
            mint = min(mint, t);
        }

        int l = 0;
        int r = mint * n;
        while (l < r)
        {
            int mid = (l + r) / 2;
            if (check(n, times, mid))
            {
                r = mid;
            }
            else
            {
                l = mid + 1;
            }
        }
        return l;
    }
};
```


## 二维二分
### 390 · Find Peak Element II
```
class Solution {
public:
    bool isPeak(const vector<vector<int>> &A, int i, int j) {
        return A[i][j] > A[i + 1][j] && A[i][j] > A[i - 1][j] && 
               A[i][j] > A[i][j + 1] && A[i][j] > A[i][j - 1];
    }
    int getLineMax(vector<vector<int>>& A, int line)
    {
        int idx = 0;
        int maxv = 0;
        int m = A[0].size();
        for (int i = 0; i < m; i++)
        {
            if (maxv < A[line][i])
            {
                maxv = A[line][i];
                idx = i;
            }
        }
        return idx;
    }
    vector<int> gpeak(vector<vector<int>>& A, int l, int r)
    {
        int m = A.size();
        int mid = (l + r) / 2;
        int lineMax = getLineMax(A, mid);
        if (isPeak(A, mid, lineMax))
        {
            return {mid, lineMax};
        }
        if (mid + 1 < m && A[mid][lineMax] >= A[mid + 1][lineMax])
        {
            return gpeak(A, l, mid - 1);
        }
        else
        {
            return gpeak(A, mid + 1, r);
        }
    }
    vector<int> findPeakII(vector<vector<int>> &A) {
        int m = A.size();
        int n = A[0].size();

        return gpeak(A, 1, m - 2);
    }
};
```

# 数学
## n次方
### 428 · Pow(x, n)   50. Pow(x, n)
```
// 如果x^(n/2)，即x的一半，是偶数，x^n = y * y
// 如果x^(n/2)，即x的一半，是奇数，x^n = y * y * x
class Solution {
public:
    double quickMul(double x, long long N) {
        if (N == 0) {
            return 1.0;
        }
        double y = quickMul(x, N / 2);
        return N % 2 == 0 ? y * y : y * y * x;
    }

    double myPow(double x, int n) {
        long long N = n;
        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
    }
};
```
## 质数
### 1324 · Count Primes
```
class Solution {
public:
    vector<int> primes;
    int cnt = 0;   
    bool st[2000000];     
    int res = 0;
    Solution(): primes(2000000, 0) {}

    void get_primes(int n)
    {
        for (int i = 2; i <= n; i ++ )
        {
            if (!st[i]) 
            {
                primes[cnt ++ ] = i;
            }
            for (int j = 0; primes[j] <= n / i; j ++ )
            {
                st[primes[j] * i] = true;
                if (i % primes[j] == 0) break;
            }
        }
    }

    int countPrimes(int n) {
        get_primes(n);

        for (auto c : primes)
            if (c != 0 && c != n)
                res++;
        return res;
    }
};
```

# 并查集
### 1179 · Friend Circles
```
class Solution {
public:
    int find(vector<int>& p, int x)
    {
        if (p[x] != x) p[x] = find(p, p[x]);
            return p[x];
    }
    int findCircleNum(vector<vector<int>> &M) {
        if (M.empty())
            return 0;
        int m = M.size();
        int n = M[0].size();
        vector<int> p(m);
        for (int i = 0; i < m; i++)
        {
            p[i] = i;
        }

        for (int i = 0; i < m; i++)
        {
            for (int j = i + 1; j < n; j++)
            {
                if (M[i][j] == 1)
                {
                    p[find(p, i)] = find(p, j);
                }
            }
        }

        set<int> resset;
        for (int i = 0; i < m; i++)
        {
            resset.insert(find(p, i));
        }

        return resset.size();
    }
};
```
### 677 · Number of Big Islands
计算size的模板
```
class Solution {
public:
    int p[90000] = {0};
    int size[90000] = {0};
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
            return p[x];
    }
    int getIndex(int x, int y, int n)
    {
        return x * n + y;
    }
    bool inBound(int x, int y, int m, int n)
    {
        if (x >= m || y >= n || x < 0 || y < 0)
            return false;
        return true;
    }
    int numsofIsland(vector<vector<bool>> &grid, int k) {
        if (grid.empty())
            return 0;
        int m = grid.size();
        int n = grid[0].size();

        int dx[4] = {1, 0, -1, 0};
        int dy[4] = {0, 1, 0, -1};

        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                p[getIndex(i, j, n)] = getIndex(i, j, n);
                if (grid[i][j])
                    size[getIndex(i, j, n)] = 1;
            }
        }

        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (!grid[i][j])
                    continue;
                for (int k = 0; k < 4; k++)
                {
                    int nx = i + dx[k];
                    int ny = j + dy[k];

                    if (!inBound(nx, ny, m, n))
                        continue;

                    if (grid[nx][ny] == true)
                    {
                        if (find(getIndex(i, j, n)) != find(getIndex(nx, ny, n)))
                        {
                            size[find(getIndex(nx, ny, n))] += size[find(getIndex(i, j, n))];
                            size[find(getIndex(i, j, n))] = 0;
                            p[find(getIndex(i, j, n))] = find(getIndex(nx, ny, n));
                        }
                    }
                }
            }
        }
        int res = 0;
        int maxInd = getIndex(m - 1, n - 1, n);
        for (int i = 0; i <= maxInd; i++)
        {
            if (size[i] >= k)
                res++;   
        }

        return res;
    }
};
```
### 805 · Maximum Association Set
字符并查集
```
class UnionFind {
public:
    unordered_map<string, string> m;
    UnionFind(){}

    /*
    string find(string s) {
        if (m[s] != s) {
            m[s] = find(m[s]);
        }
        return m[s];
    }
    */
    
    string find(string s) {
        while (m.find(s) != m.end()) {
            s = m[s];
        }
        return s;
    }
    
    vector<string> getAnswer() {
        vector<string> ans;
        unordered_map<string, unordered_set<string>> temp;
        for (auto a : m) {
            string s = find(a.first);
            temp[s].insert(a.first);
            temp[s].insert(s);
        }
        for (auto a : temp) {
            if (a.second.size() > ans.size()) {
                ans = vector<string>(a.second.begin(), a.second.end());
            }
        }
        return ans;
    }
    
    void connect(string s1, string s2) {
        string ss1 = find(s1);
        string ss2 = find(s2);
        
        if (ss1 == ss2) return;
        if (ss1 < ss2) {
            m[ss1] = ss2;
        } else {
            m[ss2] = ss1;
        }
    }
};

class Solution {
public:
    vector<string> maximumAssociationSet(vector<string> &ListA, vector<string> &ListB) {
        UnionFind uf;
        for (int i = 0; i < ListA.size(); i++) {
            uf.connect(ListA[i], ListB[i]);
        }
        
        return uf.getAnswer();
    }
};
```

## 初始化 集合计算
### 434 · Number of Islands II
```
class Solution {
public:
    int p[100000];
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
    int index(int x, int y, int m)
    {
        return x * m + y;
    }
    vector<int> numIslands2(int n, int m, vector<Point> &operators) {
        if (operators.empty())
            return {};

        vector<int> res;
        unordered_set<int> nodes;
        int s = operators.size();
        unordered_set<int> current;
        int dx[4] = {0, 1, 0, -1};
        int dy[4] = {1, 0, -1, 0};
        int total = 0;
        for (int i = 0; i < s; i++)
        {
            int pos = index(operators[i].x, operators[i].y, m);
            nodes.insert(pos);
            if (current.count(pos))
            {
                res.push_back(total);
                continue;
            }
            total++;
            p[pos] = pos;
            for (int j = 0; j < 4; j++)
            {
                int nx = operators[i].x + dx[j];
                int ny = operators[i].y + dy[j];
                if (!(nx >= 0 && nx < n && ny >= 0 && ny < m)) 
                    continue;
                if (current.count(index(nx, ny, m)))
                {
                    int apos = index(operators[i].x, operators[i].y, m);
                    int bpos = index(nx, ny, m);
                    if (find(apos) != find(bpos))
                    {
                        p[find(apos)] = find(bpos);
                        total--;
                    }
                }
            }

            current.insert(index(operators[i].x, operators[i].y, m));
            res.push_back(total);
        }
        
        return res;
    }
};
```

## Size计算

### 590 · Connecting Graph II

1.   if (find(a) == find(b)) 

2.           size[find(b)] += size[find(a)];  // 顺序相反
             p[find(a)] = find(b);
3. size[i] = 1;
4. return size[find(a)];
```
class ConnectingGraph2 {
public:
    int p[100000];
    int size[100000];
    ConnectingGraph2(int n) {
        for (int i = 0; i <= n; i++)
        {
            p[i] = i;
            size[i] = 1;
        }
    }
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }

    void connect(int a, int b) {
        if (find(a) == find(b)) 
            return;
        size[find(b)] += size[find(a)];
        p[find(a)] = find(b);
    }

    int query(int a) {
        return size[find(a)];
    }
};
```

# 图论
## BFS

### 611 · Knight Shortest Path
```
class Solution {
public:
    bool isNotOut(int x, int y, int m, int n)
    {
        if (x >= m || y >= n || x < 0 || y < 0)
            return false;
        return true;
    }
    int shortestPath(vector<vector<bool>> &grid, Point &source, Point &destination) {
        int m = grid.size();
        int n = grid[0].size();

        int dx[8] = {1, 1, -1, -1, 2, 2, -2, -2};
        int dy[8] = {2, -2, 2, -2, 1, -1, 1, -1};
        vector<vector<bool>> visit(m, vector<bool>(n, false));
        queue<Point> q;
        q.push(source);

        int step = 0;
        while (!q.empty())
        {
            int levelnum = q.size();
            step++;
            while (levelnum--)
            {
                auto cur = q.front(); q.pop();
                if (cur.x == destination.x && cur.y == destination.y)
                    return step-1;
                for (int i = 0; i < 8; i++)
                {
                    int nx = cur.x + dx[i];
                    int ny = cur.y + dy[i];

                    if (isNotOut(nx, ny, m, n) && !visit[nx][ny] && !grid[nx][ny])
                    {
                        q.push(Point(nx, ny));
                        visit[nx][ny] = true;
                    }
                }
            }
        }

        return -1;
    }
};
```
### 137 · Clone Graph
```
// DFS
class Solution {
public:
    UndirectedGraphNode* dfs(UndirectedGraphNode* node, unordered_map<int, UndirectedGraphNode*>& visit)
    {
        if (!node)
            return nullptr;
        
        auto it = visit.find(node->label);
        if (it == visit.end())
        {
            UndirectedGraphNode* current = new UndirectedGraphNode(node->label);
            visit.insert(make_pair(current->label, current));
            for (auto c : node->neighbors)
            {
                UndirectedGraphNode* child = dfs(c, visit);
                current->neighbors.push_back(child);
            }
        }

        return visit[node->label];
    }

    UndirectedGraphNode* cloneGraph(UndirectedGraphNode* node) {
        if (!node)
        {
            return nullptr;
        }

        unordered_map<int, UndirectedGraphNode*> visit;
        return dfs(node, visit);
    }
};

// BFS
class Solution {
public:
    UndirectedGraphNode* cloneGraph(UndirectedGraphNode* node) {
        if (!node)
        {
            return nullptr;
        }
        unordered_map<UndirectedGraphNode*, UndirectedGraphNode*> nodeMap;
        queue<UndirectedGraphNode*> q;
        nodeMap.insert(make_pair(node, new UndirectedGraphNode(node->label)));
        q.push(node);
        while (!q.empty())
        {
            auto cur = q.front(); q.pop();
            for (auto c : cur->neighbors)
            {
                auto it = nodeMap.find(c);
                if (it == nodeMap.end())
                {
                    UndirectedGraphNode* tmpnode = new UndirectedGraphNode(c->label);
                    nodeMap.insert(make_pair(c, tmpnode));
                    nodeMap[cur]->neighbors.push_back(tmpnode);
                    q.push(c);
                }
                else
                {
                    nodeMap[cur]->neighbors.push_back(nodeMap[c]);
                }
            }
        }

        return nodeMap[node];
    }
};
```
### DFS BFS 标准模板题 1563 · Shortest path to the destination
DFS
```
class Solution {
public:
    bool isInBound(int x, int y, int m, int n)
    {
        if (x >= m || x < 0 || y >= n || y < 0)
            return false;
        return true;
    }
    void dfs(vector<vector<int>> &targetMap, vector<vector<bool>> &vis, int x, int y, int current, int& res)
    {
        if (targetMap[x][y] == 2)
        {
            res = min (res, current);
            return;
        }
        int dx[4] = {1,  0, -1, 0};
        int dy[4] = {0, -1,  0, 1};
        int m = targetMap.size();
        int n = targetMap[0].size();
        for (int i = 0; i < 4; i++)
        {
            int nx = x + dx[i];
            int ny = y + dy[i];

            if (isInBound(nx, ny, m, n) && !vis[nx][ny] && targetMap[nx][ny] != 1)
            {
                vis[nx][ny] = true;
                dfs(targetMap, vis, nx, ny, current + 1, res);
                vis[nx][ny] = false;
            }
        }
    }
    int shortestPath(vector<vector<int>> &targetMap) {
        int res = INT_MAX;
        int m = targetMap.size();
        int n = targetMap[0].size();
        vector<vector<bool>> vis(m + 1, vector<bool>(n + 1, false));
        dfs(targetMap, vis, 0, 0, 0, res);
        return res == INT_MAX? -1: res;
    }
};
```
BFS
```
class Solution {
public:
    bool isInBound(int x, int y, int m, int n)
    {
        if (x >= m || x < 0 || y >= n || y < 0)
            return false;
        return true;
    }
    int shortestPath(vector<vector<int>> &targetMap) {
        int m = targetMap.size();
        int n = targetMap[0].size();
        int dx[4] = {1,  0, -1, 0};
        int dy[4] = {0, -1,  0, 1};
        vector<vector<bool>> visit(m, vector<bool>(n, false));
        queue<pair<int, int>> q;
        q.push(make_pair(0, 0));
        visit[0][0] = true;
        int step = 0;
        while (!q.empty())
        {
            int levelcount = q.size();
            while(levelcount--)
            {
                auto cur = q.front(); q.pop();
                if (targetMap[cur.first][cur.second] == 2)
                    return step;
                for (int i = 0; i < 4; i++)
                {
                    int nx = cur.first + dx[i];
                    int ny = cur.second + dy[i];
                    if (isInBound(nx, ny, m, n) && !visit[nx][ny] && targetMap[nx][ny] != 1)
                    {
                        q.push(make_pair(nx, ny));
                        visit[nx][ny] = true;
                    }
                }
            }
            step++;
        }
        return -1;
    }
};
```
###  BFS记录路径的方法
```
#include<cstdio>
#include<queue>
using namespace std;
struct sss
{
    int x,y;
}ans[6][6];
int map[6][6];
int flag[6][6];
int dec[4][2]={1,0,0,1,-1,0,0,-1};
void print(struct sss q)
{
    if(q.x==0&&q.y==0)
    {
        printf("(0, 0)\n");
        return;
    }
    else
    {
        print(ans[q.x][q.y]);
        printf("(%d, %d)\n",q.x,q.y);
    }
}
void bfs(int x,int y)
{
    struct sss q;
    queue<struct sss> s;
    flag[0][0]=1;
    q.x=x;
    q.y=y;
    s.push(q);
    ans[0][0].x=-1;
    ans[0][0].y=-1;
    while(!s.empty())
    {
        q=s.front();
        s.pop();
        if(q.x==4&&q.y==4)
        {
            print(q);
            return;
        }
        for(int i=0;i<4;i++)
        {
            int xx=dec[i][0]+q.x;
            int yy=dec[i][1]+q.y;
            if(xx>=0&&xx<5&&yy>=0&&yy<5&&flag[xx][yy]==0&&map[xx][yy]==0)
            {
                struct sss w;
                w.x=xx;
                w.y=yy;
                s.push(w);
                flag[xx][yy]=1;
                ans[xx][yy].x=q.x;
                ans[xx][yy].y=q.y;
            }
        }
    }
}
int main()
{
    for(int i=0;i<5;i++)
    {
        for(int j=0;j<5;j++)
        {
            scanf("%d",&map[i][j]);
        }
    }
    bfs(0,0);
}
 

 

 

#include<cstdio>
#include<cmath>
#include<vector>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<queue>
#include<map>
#include<string>
using namespace std;
typedef long long ll;
char mp[1001][1001];
int n,m,k;
int flag;
int d[1001][1001];
char jg[1000001];
char yx[1000001];
int dis[4][2]={1,0,0,-1,0,1,-1,0};
char str[5]={"DLRU"};
void pan(int x,int y){
    //printf("k=%d\n",k);
    int tmp=k;
    for(int i=0;i<k;i++){
        int dex=-1;
        for(int j=0;j<4;j++){
            pair<int,int> z;
            z.first=x+dis[j][0];
            z.second=y+dis[j][1];
            if(z.first>=0&&z.first<n&&z.second>=0&&z.second<m&&mp[z.first][z.second]!='*'&&d[z.first][z.second]<tmp){
                dex=j;
                break;
            }
        }
        tmp--;
        x=x+dis[dex][0];
        y=y+dis[dex][1];
        jg[i]=str[dex];
    }
    jg[k]='\0';
    printf("%s\n",jg);
}
void bfs(int x,int y)
{
    queue<pair<int,int> > q;
    q.push(make_pair(x,y));
    for(int i=0;i<1000;i++){
        for(int j=0;j<1000;j++)
          d[i][j]=10000000;
    }
    int num=0;
    d[x][y]=0;
    while(!q.empty()){
        pair<int,int> w=q.front();
        q.pop();
        num++;
        for(int i=0;i<4;i++){
            pair<int,int> z;
            z.first=w.first+dis[i][0];
            z.second=w.second+dis[i][1];
            if(z.first>=0&&z.first<n&&z.second>=0&&z.second<m&&mp[z.first][z.second]=='.'){
                if(d[z.first][z.second]>d[w.first][w.second]+1){
                    d[z.first][z.second]=d[w.first][w.second]+1;
                    q.push(z);
                }
            }
        }
    }
    /*for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            if(d[i][j]==10000000) printf("%4d",-1);
            else printf("%4d",d[i][j]);
        }
        printf("\n");
    }*/
//    printf("num=%d\n",num);
    if(num==1) printf("IMPOSSIBLE");
    else pan(x,y);
}
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    for(int i=0;i<n;i++){
        scanf("%s",mp[i]);
    }
    if(k%2){
        printf("IMPOSSIBLE");
        return 0;
    }
    int vis=0;
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++)
        {
            if(mp[i][j]=='X')
            {
                mp[i][j]='.';
                bfs(i,j);
                vis=1;
                break;    
            }        
        }
        if(vis) break;
    }
}
```

## 拓扑排序

### 127 · Topological Sorting
```
class Solution {
public:
    vector<DirectedGraphNode*> topSort(vector<DirectedGraphNode*> graph) {
        if (graph.empty())
            return {};
        unordered_map<DirectedGraphNode*, int> inDegree;
        for (auto n : graph)
        {
            auto it = inDegree.find(n);
            if (it == inDegree.end())
                inDegree[n] = 0;
            for (auto outn : n->neighbors)
            {
                inDegree[outn]++;
            }
        }

        queue<DirectedGraphNode*> q;
        for (auto n : inDegree)
        {
            //cout << n.first->label << " " << n.second << endl;
            if (n.second == 0)
            {
                
                q.push(n.first);
            }
        }
        vector<DirectedGraphNode*> res;
        while (!q.empty())
        {
            auto cur = q.front(); q.pop();
            res.push_back(cur);
            for (auto c : cur->neighbors)
            {
                if (!(--inDegree[c]))
                    q.push(c);
            }
        }

        return res;
    }
};
```

### 615 · Course Schedule
### 616 · Course Schedule II
```
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<pair<int, int>> &prerequisites) {
        unordered_map<int, vector<int>> g;
        unordered_map<int, int> inDegree;
        for (int i = 0; i < numCourses; i++)
        {
            inDegree[i] = 0;
        }

        for (auto n : prerequisites)
        {
            g[n.second].push_back(n.first);
            inDegree[n.first]++;
        }

        queue<int> q;
        for (auto n : inDegree)
        {
            if (!n.second)
            {
                q.push(n.first);
            }
        }

        vector<int> res;
        while (!q.empty())
        {
            auto cur = q.front(); q.pop();
            res.push_back(cur);

            for (auto n : g[cur])
            {
                if (!(--inDegree[n]))
                {
                    q.push(n);
                }
            }
        }

        return (res.size() != numCourses) ? vector<int>() : res;
    }
};
```
## 爆搜
### 33 · N-Queens
```
class Solution {
public:
    /*
     * @param n: The number of queens
     * @return: All distinct solutions
     */
    void dfs(int r, int n, vector<string>& path, vector<vector<string>>& res)
    {      
        if (r == n)
        {
            res.push_back(path);
            return;
        }
        for (int i = 0; i < n; i++)
        {
            if (!col[i] && !row[i] && !dg[r + i] && !udg[r - i + n])
            {
                path[r][i] = 'Q';
                col[i] = row[i] = dg[r + i] = udg[r - i + n] = true;
                dfs(r + 1, n, path, res);
                path[r][i] = '.';
                col[i] = row[i] = dg[r + i] = udg[r - i + n] = false;
            }
        }
    }
    vector<bool> col;
    vector<bool> row;
    vector<bool> dg;
    vector<bool> udg;
    vector<vector<string>> solveNQueens(int n) {
        if (!n)
            return {};
        vector<bool> lcol(n, false);
        vector<bool> lrow(n, false);
        vector<bool> ldg(2 * n, false);
        vector<bool> ludg(2 * n, false);
        col = lcol;
        row = lrow;
        dg = ldg;
        udg = ludg;

        vector<vector<string>> res;
        vector<string> path(n, string(n, '.'));

        dfs(0, n, path, res);
        return res;
    }
};
```
### 802 · Sudoku Solver
```
class Solution {
public:
    /**
     * @param board: the sudoku puzzle
     * @return: nothing
     */
    bool col[9][10]; 
    bool row[9][10];
    bool cell[3][3][10];
    bool dfs(vector<vector<int>>& board, int x, int y)
    {
        //cout << x << " " << y << endl;
        if (y == 9) 
        {
            x++;
            y = 0;
        }
        if (x == 9)
        {
            return true;
        }

        if (board[x][y] != 0)
            return dfs(board, x, y + 1);
        
        for (int i = 0; i < 9; i++)
        {
            if (!col[x][i] && !row[y][i] && !cell[x / 3][y / 3][i])
            {
                board[x][y] = i + 1;
                col[x][i] = true; row[y][i] = true; cell[x / 3][y / 3][i] = true;
                if (dfs(board, x, y + 1))
                    return true;
                board[x][y] = 0;
                col[x][i] = false; row[y][i] = false; cell[x / 3][y / 3][i] = false;
            }
        }
        return false;
    }
    void solveSudoku(vector<vector<int>> &board) {

        memset(col, 0, 9 * 10 * sizeof(bool));
        memset(row, 0, 9 * 10 * sizeof(bool));
        memset(cell, 0, 3 * 3 * 10 * sizeof(bool));
        for (int i = 0; i < 9; i++)
        {
            for (int j = 0; j < 9; j++)
            {
                if (board[i][j] != 0)
                {
                    col[i][board[i][j] - 1] = true;
                    row[j][board[i][j] - 1] = true;
                    cell[i / 3][j / 3][board[i][j] - 1] = true;
                }
            }
        }

        dfs(board, 0, 0);
        
    }
};
```
## SPFA

以bfs为基础，把选择条件换成只要距离更新了就入队

### 1565 · Modern Ludo I

```
class Solution {
public:
    int modernLudo(int length, vector<vector<int>> &connections) {
        int m = connections.size();
        vector<int> st(length + 1, 0);
        queue<int> q;
        q.push(1);
        st[1] = true;
        vector<int> dist(length + 1, INT_MAX);
        dist[1] = 0;
        while (!q.empty())
        {
            auto cur = q.front(); q.pop();
            st[cur] = false;
            for (auto e : connections)
            {
                if (e[0] == cur)
                {
                    if (dist[e[1]] > dist[cur])  // dist[e[1]] > dist[cur] + 0
                    {
                        dist[e[1]] = dist[cur];
                        if (!st[e[1]])
                        {
                            q.push(e[1]);
                            st[e[1]] = true;
                        }
                    }
                }
            }
            for (int i = 1; i <= 6; i++)
            {
                auto target = cur + i;
                if (target > length)
                    break;
                if (dist[target] > dist[cur] + 1)
                {
                    dist[target] = dist[cur] + 1;
                    if (!st[target])
                    {
                        q.push(target);
                        st[target] = true;
                    }
                }
            }
        }

        return dist[length];
    }
};
```
### 1469 · Longest Path On The Tree(树的直径)

树的直径，就是从任一点开始找到最远距离点，再从这个最远距离点找另外一个最远距离点，这两点之间就是直径

```
class Solution {
public:
    void spfa(int n, unordered_map<int, vector<pair<int, int>>>& g, int start, int& maxindex, int& maxdist)
    {
        vector<bool> visit(n, false);
        vector<int> dist(n, 0x3f3f3f3f);
        queue<int> q;
        q.push(start);
        visit[start] = true;
        dist[start] = 0;
        while(!q.empty())
        {
            auto cur = q.front(); q.pop();
            visit[cur] = false;
            int m = g[cur].size();
            for (int i = 0; i < m; i++)
            {
                if (dist[g[cur][i].first] > dist[cur] + g[cur][i].second)
                {
                    dist[g[cur][i].first] = dist[cur] + g[cur][i].second;
                    if (maxdist < dist[g[cur][i].first])
                    {
                        maxdist  = dist[g[cur][i].first];
                        maxindex = g[cur][i].first;
                    }
                    if (!visit[g[cur][i].first])
                    {
                        q.push(g[cur][i].first);
                        visit[g[cur][i].first] = true;
                    }
                }
            }
        }
    }
    int longestPath(int n, vector<int> &starts, vector<int> &ends, vector<int> &lens) {
        unordered_map<int, vector<pair<int, int>>> g;
        int m = starts.size();
        for (int i = 0; i < n - 1; i++)
        {
            g[starts[i]].push_back({ends[i], lens[i]});
            g[ends[i]].push_back({starts[i], lens[i]});
        }

        int maxi = 0;
        int maxd = 0;
        spfa(n, g, 0, maxi, maxd);
        spfa(n, g, maxi, maxi, maxd);
        return maxd;
    }
};
```
### 1862 · Time to Flower Tree
```
class Solution {
public:
    int timeToFlowerTree(vector<int> &father, vector<int> &time) {
        set<tuple<int, int, int>> edges;
        int m = father.size();
        for (int i = 1; i < m; i++)
        {
            edges.insert({father[i], i, time[i]});
        }
        vector<int> dist(m, 0x3f3f3f3f);
        dist[0] = 0;
        queue<int> q;
        q.push(0);
        vector<bool> visit(m, false);
        visit[0] = true;
        while (!q.empty())
        {
            auto cur = q.front(); q.pop();
            visit[cur] = false;
            for (auto e : edges)
            {
                if (get<0>(e) != cur)
                    continue;
                if (dist[get<1>(e)] > dist[cur] + get<2>(e))
                {
                    dist[get<1>(e)] = dist[cur] + get<2>(e);
                    if (!visit[get<1>(e)])
                    {
                        q.push(get<1>(e));
                        visit[get<1>(e)] = true;
                    }
                }
            }
        }
        int res = 0;
        for (auto d : dist)
        {
            res = max(res, d);
        }

        return res;
    }
};
```
### 258 · Map Jump
```
class Solution {
public:
    int idx(int x, int y, int n)
    {
        return x * n + y;
    }
    bool isInBound(int x, int y, int m, int n)
    {
        if (x >= m || y >= n || x < 0 || y < 0)
            return false;
        return true;
    }
    int mapJump(vector<vector<int>> &arr) {
        int m = arr.size();
        int n = arr[0].size();
        int dx[4] = {0, 1, 0, -1};
        int dy[4] = {1, 0, -1, 0};
        vector<int>  dist(m * n, 0x3f3f3f3f);
        queue<pair<int, int>> q;
        q.push({0, 0});
        dist[idx(0, 0, n)] = 0;
        while (!q.empty())
        {
            auto cur = q.front(); q.pop();
            for (int i = 0; i < 4; i++)
            {
                int nx = cur.first  + dx[i];
                int ny = cur.second + dy[i];
                if (!isInBound(nx, ny, m, n))
                    continue;

                int h = max(dist[idx(cur.first, cur.second, n)], abs(arr[nx][ny] - arr[cur.first][cur.second]));
                if (dist[idx(nx, ny, n)] > h)
                {
                    dist[idx(nx, ny, n)] = h;
                    q.push({nx, ny});
                }
            }
        }
        return dist[idx(m - 1, n - 1, n)];

    }
};
```
## Dijkstra
### 1057 · Network Delay Time
```
class Solution {
public:
    int networkDelayTime(vector<vector<int>> &times, int N, int K) {
        vector<vector<int>> g(N + 1, vector<int>(N + 1, 0x3f3f3f3f));
        for (auto e : times)
        {
            g[e[0]][e[1]] = min(g[e[0]][e[1]], e[2]);
        }
        vector<int> dist(N + 1, 0x3f3f3f3f);
        vector<bool> visit(N + 1, false);
        dist[K] = 0;
        for (int i = 0; i < N; i++)
        {
            int t = -1;
            for (int j = 1; j <= N; j++)
            {
                if (!visit[j] && (t == -1 || dist[t] > dist[j]))
                    t = j;
            }
            for (int j = 1; j <= N; j++)
            {
                if (dist[j] > dist[t] + g[t][j])
                {
                    dist[j] = dist[t] + g[t][j];
                }
            }
            visit[t] = true;
        }

        int res = 0;
        for (int i = 1; i <= N; i++)
        {
            if (dist[i] == 0x3f3f3f3f)
                return -1;
            res = max(res, dist[i]);
        }
        return res;
    }
};
```
# 二叉树
### 97 · Maximum Depth of Binary Tree
```
class Solution:
    """
    @param root: The root of binary tree.
    @return: An integer
    """
    def maxDepth(self, root):
        if root is None:
            return 0
        leftDepth = self.maxDepth(root.left)
        rightDepth = self.maxDepth(root.right)
        return max(leftDepth, rightDepth) + 1
```

# String
## 字符串hash
### 128 · Hash Function
```
class Solution {
public:
    int hashCode(string &key, int HASH_SIZE) {
        int P = 33;
        int sum = 0;
        int len = key.length();
        long long h[len] = {0};

        h[0] = key[0];
        for (int i = 1; i < len; i++)
        {   
            h[i] = (h[i - 1] * P + key[i]) % HASH_SIZE;
        }

        return h[len - 1];
    }
};
```
### 13 · Implement strStr()
```
#include <limits>
class Solution {
public:
    int strStr(string &source, string &target) {
        if (target.empty())
            return 0;
        int m = source.size();
        int n = target.size();
        int C = 31;
        long long power = 1;
        long long thash = 0;
        for (int i = 0; i < n; i++)
        {
            power *= C;
            thash = thash * C + target[i];
        }

        long long shash = 0;
        for (int i = 0; i < m; i++)
        {
            // abc + d   p2 + p1 + p0 -> p3 + p2 + p1 + p0
            shash = shash * C + source[i];
            if (i < n - 1)
                continue;

            // abcd - a  p3 + p2 + p1 + p0 -> p2 + p1 + p0
            if (i >= n)
            {
                shash = shash - source[i - n] * power;
                if (shash < 0)
                    shash += std::numeric_limits<long long>::max();
            }

            if (thash == shash)
                return i - n + 1;
        }
        return -1;
    }
};
```
# Trie树
### 442 · Implement Trie (Prefix Tree)
```
class Trie {
public:
    /*
     * @param word: a word
     * @return: nothing
     */
    int son[100000][26];
    int cnt[100000];
    int idx = 0;
    void insert(string &word) {
        int m = word.size();
        int p = 0;
        for (int i = 0; i < m; i++)
        {
            int u = word[i] - 'a';
            if (!son[p][u]) son[p][u] = ++idx;
            p = son[p][u];
        }
        cnt[p]++;
    }

    /*
     * @param word: A string
     * @return: if the word is in the trie.
     */
    bool search(string &word) {
        int m = word.size();
        int p = 0;
        for (int i = 0; i < m; i++)
        {
            int u = word[i] - 'a';
            if (!son[p][u]) 
                return false;
            p = son[p][u];
        }
        return cnt[p]? true: false;
    }

    /*
     * @param prefix: A string
     * @return: if there is any word in the trie that starts with the given prefix.
     */
    bool startsWith(string &prefix) {
        int m = prefix.size();
        int p = 0;
        for (int i = 0; i < m; i++)
        {
            int u = prefix[i] - 'a';
            if (!son[p][u]) 
                return false;
            p = son[p][u];
        }
        return true;
    }
};
```

# Heap
### 130 · Heapify
```
    void heapify(vector<int> &A) {
        priority_queue<int, vector<int>, greater<int>> q;
        for (auto n : A)
        {
            q.push(n);
        }
        A.clear();
        while (!q.empty())
        {
            A.push_back(q.top()); q.pop();
        }
    }
    
    void heapify(vector<int> &A) {

        int len = A.size();
        if (!len || len == 1)
           return;
         
        std::make_heap (A.begin(),A.end(), [](int a, int b){return a > b;});
    }    
```
```
void down(vector<int> &A, int i)
    {
        int t = i;
        int len = A.size();
         if (i * 2 <= len && A[i-1] > A[i * 2 - 1])
         {
             t = i * 2;
         }
         if (i * 2 + 1 <= len && A[i - 1] > A[i * 2 + 1 - 1])
         {
             t = i * 2 + 1;
         }

         if (t != i)
         {
             swap(A[t-1], A[i-1]);
             down(A, t);
         }

    }
```
### 613 · High Five
Heap 基础用法
```
class Solution {
public:
    /**
     * @param results a list of <student_id, score>
     * @return find the average of 5 highest scores for each person
     * map<int, double> (student_id, average_score)
     */
    map<int, double> highFive(vector<Record>& results) {
        map<int, priority_queue<int, vector<int>, greater<int>>> hash;
        map<int, double> hashTotal;

        for (auto n : results)
        {
            hash[n.id].push(n.score);
            hashTotal[n.id] += n.score;
            if (hash[n.id].size() > 5)
            {
                hashTotal[n.id] -= hash[n.id].top();
                hash[n.id].pop();
            }
        }
        for (auto& n : hashTotal)
        {
            n.second /= 5.0;
        }
        return hashTotal;
    }
};
```

# Hash
## 扩容
### 129 · Rehashing
将容量扩充为原来的两倍，然后将原来的数据重新计算hash放入新的buff中
```
class Solution {
public:
    int hashcode(int key, int capacity) {
        return (key % capacity + capacity) % capacity;
    }
    vector<ListNode*> rehashing(vector<ListNode*> hashTable) {
        int m = hashTable.size();
        vector<ListNode*> newHashTab(2 * m, nullptr);
        for (auto n : hashTable)
        {
            while (n)
            {
                ListNode* newNode = new ListNode(n->val);
                ListNode* l = newHashTab[hashcode(n->val, 2 * m)];
                if (!l)
                    newHashTab[hashcode(n->val, 2 * m)] = newNode;
                else
                {
                    while (l)
                    {
                        if (!l->next)
                        {
                            l->next = newNode;
                            break;
                        }
                        l = l->next;
                    }
                }
                n = n->next;
            }
        }
        return newHashTab;
    }
};
```
# 链表（见链表页）
### 103 · Linked List Cycle II 链表环 
```
class Solution {
public:
    ListNode * detectCycle(ListNode * head) {
        if(head == NULL || head->next == NULL){
            return NULL;
        }
        ListNode *slow = head;
        ListNode *fast = head;
        while(fast != NULL && fast->next != NULL){
            slow = slow->next;
            fast = fast->next->next;
            if(slow == fast){
                break;
            }
        }
        if(fast == NULL || fast->next == NULL){
            return NULL;
        }
        slow = head;
        while(slow != fast){
            slow = slow->next;
            fast = fast->next;
        }
        return slow;
    }
};
```
### L21. 合并两个有序链表
### L23. 合并K个升序链表
### L19. 删除链表的倒数第 N 个结点
### L876. 链表的中间结点
### 剑指 Offer 24. 反转链表
### 判断单链表是否包含环
### 剑指 Offer II 022. 链表中环的入口节点
### 剑指 Offer II 023. 两个链表的第一个重合节点



# 动态规划

### 515 · Paint House
```
class Solution {
public:
    int minCost(vector<vector<int>> &costs) {
        if (costs.empty())
            return 0;
        int m = costs.size();
        vector<vector<int>> f(m, vector<int>(3, 0));
        f[0][0] = costs[0][0];
        f[0][1] = costs[0][1];
        f[0][2] = costs[0][2];
        for (int i = 1; i < m; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                f[i][j] = min(f[i - 1][(j + 1) % 3], f[i - 1][(j + 2) % 3]) + costs[i][j];
            }
        }
        int res = INT_MAX;
        for (int i = 0; i < 3; i++)
        {
            res = min(res, f[m - 1][i]);
        }

        return res;
    }
};
```
### 111 · Climbing Stairs
```
class Solution {
public:
    int climbStairs(int n) {
        if (n == 0)
            return 0;
        vector<int> dp(n + 1, 0);
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++)
        {
            dp[i] = dp[i - 2] + dp[i - 1];
        }
        return dp[n];
    }
};
```
### 300 · Meeting Room IV
接龙
```
class Solution {
public:
    int maxValue(vector<vector<int>> &meeting, vector<int> &value) {
        int m = meeting.size();
        vector<int> f(50010, 0);

        int res = 0;
        for (int j = 1; j < 50010; j++)
        {
            f[j] = f[j - 1];
            for (int i = 1; i <= m; i++)
            {
                if (meeting[i - 1][1] != j)
                    continue;

                f[j] = max(f[j], f[meeting[i - 1][0]] + value[i - 1]);
                res = max(res, f[j]);
            }
        }

        return res;
    }
};
```
### L32. Longest Valid Parentheses 
dp为 以“)” 为结尾的左边最长括号的长度
```
class Solution {
public:
    int longestValidParentheses(string s) {
        if (s.length() <= 1)
            return 0;
        int len = s.length();
        int dp[300000] = {0};

        int max = 0;
        for (int i = 1; i < len; ++i)
        {
            if (s[i] == ')')
            {
                int pre = 0;
                pre = i - dp[i - 1] - 1;
                if (pre >= 0 && s[pre] == '(')
                {
                    dp[i] = dp[i - 1] + 2;
                    if (pre > 0)
                    {
                        dp[i] += dp[pre - 1];
                    }
                }

                if (dp[i] > max)
                {
                    max = dp[i];
                }
            }
        }
        return max;
    }
};
```

## 坐标型DP
### 115 · Unique Paths II
```
class Solution {
public:
    bool isInBound(int x, int y, int m, int n)
    {
        if (x >= m || y >= n || x < 0 || y < 0)
            return false;
        return true;
    }
    int uniquePathsWithObstacles(vector<vector<int>> &obstacleGrid) {
        if (obstacleGrid.empty())
            return 0;
        if (obstacleGrid[0][0])
            return 0;

        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        vector<vector<int>> f(m + 1, vector<int>(n + 1, 0));
        f[0][0] = 1;
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (obstacleGrid[i][j])
                    continue;
                if (isInBound(i - 1, j, m, n))
                    f[i][j] += f[i - 1][j];
                if (isInBound(i, j - 1, m, n))
                    f[i][j] += f[i][j - 1];
            }
        }
        return f[m - 1][n - 1];
    }
};
```
### 76 · Longest Increasing Subsequence(LIS)

是大于，不是大于等于。初始化为1
```
class Solution {
public:
    int longestIncreasingSubsequence(vector<int> &nums) {
        if (nums.empty())
            return 0;
        int m = nums.size();
        vector<int> f(m + 1, 1);
        int res = 0;
        for (int i = 1; i < m; i++)
        {
            for (int j = 0; j < i; j++)
            {
                if (nums[i] > nums[j])
                {
                    f[i] = max(f[i], f[j] + 1);
                }
                res = max(res, f[i]);
            }
        }
        return res;
    }
};
```
### 77 · Longest Common Subsequence(LCS)

f(i, j) 是1-i和i- j两个子序列的LCS

f(i - 1, j) 和 f(i, j - 1)都包含 f(i - 1, j - 1)这种情况，但是取max的时候实际还是取的他们三者的最大值，是否重复不重要。



```
class Solution {
public:
    int longestCommonSubsequence(string &A, string &B) {
        int m = A.size();
        int n = B.size();
        A = " " + A;
        B = " " + B;
        vector<vector<int>> f(m + 1, vector<int>(n + 1, 0));
        
        for (int i = 1; i <= m; i++)
        {
            for (int j = 1; j <= n; j++)
            {
                f[i][j] = max(f[i - 1][j], f[i][j - 1]);
                if (A[i] == B[j])
                {
                    f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1);
                }
            }
        }
        return f[m][n];
    }
};
```
## 区间DP
### 667 · Longest Palindromic Subsequence
len从1开始，i从0开始
```
int longestPalindromeSubseq(string s) {
        int n = s.size();
        vector<vector<int>> dp(n + 10, vector<int>(n + 10, 0));
        for (int len = 1; len <= n; len++)
        {
            for (int i = 0; i + len - 1 < n; ++i)
            {
                int j = i + len - 1;
                if (len == 1)
                    dp[i][j] = 1;
                else if (s[i] == s[j])
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                else
                    dp[i][j] = max(dp[i][j], max(dp[i + 1][j], dp[i][j - 1]));
            }
        }

        return dp[0][n - 1];
    }
```
常规做法, dp[j]为，以j为结尾的，最长回文子序列长度
```
class Solution {
public:
    bool isPal(const string& s)
    {
        int l = 0;
        int r = s.length() - 1;

        while (l <= r && s[l] == s[r]) { l++; r--;}
        if(l > r)
            return true;
        return false;
    }
    int longestPalindromeSubseq(string &s) {
        int len = s.length();
        int res = INT_MIN;
        vector<int> dp(len + 2, 1);
        for (int i = 1; i < len; i++)
        {
            for (int j = 0; j < i; j++)
            {
                if (isPal(s.substr(j - dp[j] + 1, dp[j]) + s[i]))
                {
                    dp[i] = max (dp[i], dp[j] + 1);
                    res = max (res, dp[i]);
                }
            }
        }
        return res;
    }
};
```
### 476 · Stone Game
算法：区间DP

这是一道区间DP问题，我们需要用区间表示状态来递推。设s是表示石头重量的数组，设f[i][j]是将s[i,...,j]的石头合并成一个所需的最少能量，那么这个最少能量按照最后一步合并的分界线可以分为以下几种情况：

1、最后一步是s[i]和s[i+1,...,j]合并，此时需要的最少能量是f[i+1][j]+sum(s[i]...s[j]),第一项是合并后者需要的能量，第二项是最后一次合并所需要的能量。s[i]自己只有一个石头，不需要合并

2、最后一步是s[i,i+1]和s[i+2,...,j]合并，此时需要的最少能量是f[i][i+1]+f[i+2][j]+sum(s[i]...s[j])，第一项是合并前两个石头需要的能量，第二项是合并后半区间石头需要的能量，最后一项是最后一次合并需要的能量；

从上面我们可以看出一个规律，f[i][j]应该是所有区间分法中前一半区间的石头合并需要的总能量加上后半区间的总能量再加上最后一次合并需要的能量

求得A的前缀和
区间长度从2开始枚举，
根据上诉思路可得递推式
dp[l][r] =min(dp[l][r], dp[l][j] + dp[j + 1][r] + sum_a[r + 1] - sum_a[l])
记得初始化dp[l][r]为一个较大值
结果存在dp[0][size-1]中

```
#include <numeric>
class Solution {
public:
    int stoneGame(vector<int> &A) {
        if (A.empty())
            return 0;
        int m = A.size();
        vector<vector<int>> f(m + 1, vector<int>(m + 1, 0));
        vector<int> sum(m + 1, 0);
        partial_sum(A.begin(), A.end(), sum.begin() + 1);

        for (int len = 2; len <= m; len++)
        {
            for (int i = 0; i + len - 1 < m; i++)
            {
                int j = i + len - 1;
                f[i][j] = 0x3f3f3f3f;
                for (int k = i; k < j; k++)
                    f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j] + (sum[j + 1] - sum[i])); 
            }
        }
        return f[0][m - 1];
    }
};
```


# 其他

## 扫描线
### 919 · Meeting Rooms II
对所有点排序，从左到右扫描每个点，是起点就加一，是终点就减一，判断这个过程中的最大值
```
class Solution {
public:
    int minMeetingRooms(vector<Interval> &intervals) {
        int m = intervals.size();
        multimap<int, int> order;
        for (auto i : intervals)
        {
            order.insert({i.start, 1});
            order.insert({i.end, -1});
        }
        int res = 0;
        int current = 0;
        for (auto t : order)
        {
            current += t.second;
            res = max(res, current);
        }
        return res;
    }
};
```
## 倍增
### 447 · Search in a Big Sorted Array
```
        while(reader->get(r) < target)
            r <<= 1;
```

```
class Solution {
public:
    int searchBigSortedArray(ArrayReader * reader, int target) {
        int l = 0;
        int r = 1;
        while(reader->get(r) < target)
            r <<= 1;
        while (l < r)
        {
            int mid = (l + r) / 2;
            if (reader->get(mid) >= target)
            {
                r = mid;
            }
            else
            {
                l = mid + 1;
            }
        }
        if (reader->get(l) != target)
            return -1;
        return l;
    }
};
```
### 5969. Destroying Asteroids

```
class Solution {
public:
    bool asteroidsDestroyed(int mass, vector<int>& asteroids) {
        sort(asteroids.begin(), asteroids.end());
        int m = asteroids.size();
        vector<int> minarr(18, -1);
        vector<long long> sums(18, 0);

        for (int i = 0; i < m; i++)
        {
            int h = 31 - __builtin_clz(asteroids[i]);
            if (minarr[h] == -1 || asteroids[i] < minarr[h])
            {
                minarr[h] = asteroids[i];
            }
            sums[h] += asteroids[i];
        }
        long long mm = mass;
        for (int i = 0; i < 17; i++)
        {
            if (mm < minarr[i])
                return false;
            mm += sums[i];
        }
        return true;
    }
};
```
## LRU  
### 134 · LRU Cache
```
#include <list>
class LRUCache {
public:
    LRUCache(int capacity) : _capacity(capacity) {

    }
    
    int get(int key) {
        auto it = _table.find(key);
        if (it != _table.end()) {
            _lru.splice(_lru.begin(), _lru, it->second);
            return it->second->second;
        }
        return -1;
    }
    
    void set(int key, int value) {
        auto it = _table.find(key);
        if (it != _table.end()) {
            _lru.splice(_lru.begin(), _lru, it->second);
            it->second->second = value;
            return;
        }
        
        _lru.emplace_front(key, value);
        _table[key] = _lru.begin();
        
        if (_table.size() > _capacity) {
            _table.erase(_lru.back().first);
            _lru.pop_back();
        }
    }
private:
    unordered_map<int, std::list<std::pair<int, int>>::iterator> _table;
    std::list<std::pair<int, int>> _lru;
    int _capacity;
};
```
