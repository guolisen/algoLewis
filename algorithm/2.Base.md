[TOC]
# 排序

https://www.algolist.net/Algorithms/Sorting/Selection_sort
https://www.algolist.net/Algorithms/Sorting/Quicksort
https://www.algolist.net/Algorithms/Sorting/Insertion_sort
https://www.algolist.net/Algorithms/Sorting/Bubble_sort
https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html

## 快速排序

### 143 · Sort Colors II
```
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
# 双指针
### 56 · Two Sum

```
    vector<int> twoSum(vector<int> &numbers, int target) {
        int m = numbers.size();
        vector<int> res;
        for (int i = 0; i < m - 1; i++)
        {
            for (int j = i + 1; j < m; j++)
            {
                if (numbers[i] + numbers[j] == target)
                {
                    res.push_back(i);
                    res.push_back(j);
                    return res;
                }
            }
        }
        return {-1, -1};
    }
```
### 59 · 3Sum Closest
```
    int threeSumClosest(vector<int> &numbers, int target) {
        if (numbers.empty())
            return 100000000;
        sort(numbers.begin(), numbers.end());
        int m = numbers.size();
        int minv = INT_MAX;
        for (int i = 0; i < m - 1; ++i)
        {
            int l = i + 1;
            int r = m - 1;
            while (l < r)
            {
                int sum = numbers[i] + numbers[l]  + numbers[r];
                if (abs(sum - target) < abs(minv - target))
                {
                    minv = sum;               
                }

                if (sum < target)
                {
                    l++;
                }
                else
                {
                    r--;
                }
            }

        }
        return minv;
    }
```
### 64 · Merge Sorted Array(6 · Merge Two Sorted Arrays)

```
    void mergeSortedArray(int A[], int m, int B[], int n) {
        int ai = 0;
        int bi = 0;
        vector<int> ires;
        while (ai < m && bi < n)
        {
            if (A[ai] <= B[bi])
            {
                ires.push_back(A[ai++]);
            }
            else
            {
                ires.push_back(B[bi++]);
            }
        }
        while (ai < m)
        {
            ires.push_back(A[ai++]);
        }
        while (bi < n)
        {
            ires.push_back(B[bi++]);
        }

        int i = 0;
        for (auto n : ires)
        {
            A[i++] = n;
        }
    }
```
Second method:
```
    vector<int> mergeSortedArray(vector<int> &A, vector<int> &B) {
        int m = A.size();
        int n = B.size();
        vector<int> res;
        int ai = 0;
        int bi = 0;
        for (int k = 0; k < m + n; ++k)
        {
            if (ai < m && (bi == n || A[ai] < B[bi]))
            {
                res.push_back(A[ai++]);
            }
            else
            {
                res.push_back(B[bi++]);
            }
        }
        return res;
    }
```
In one array
```
    void mergeSortedArray(int A[], int m, int B[], int n) {
        int ri = m + n - 1;
        int ai = m - 1;
        int bi = n - 1;

        while (ai >= 0 && bi >= 0)
        {
            if (A[ai] > B[bi])
            {
                A[ri--] = A[ai--];
            }
            else
            {
                A[ri--] = B[bi--];
            }
        }
        while (bi >= 0)
        {
            A[ri--] = B[bi--];
        }
    }
```
### 165 · Merge Two Sorted Lists

```
    ListNode * mergeTwoLists(ListNode * l1, ListNode * l2) {
        if (!l1) return l2;
        if (!l2) return l1;
        ListNode* head = nullptr;
        if (l1->val < l2->val)
        {
            head = l1;
            head->next = mergeTwoLists(l1->next, l2);
        }
        else
        {
            head = l2;
            head->next = mergeTwoLists(l1, l2->next);
        }
        return head;
    }
```
1246 · Longest Repeating Character Replacement
同向双指针
```
    int characterReplacement(string &s, int k) {
        int m = s.size();
        int res = 0;
        for (int c = 'A'; c <= 'Z'; ++c)
        {
            int count = 0;
            for (int i = 0, j = 0; i < m; i++)
            {
                if (s[i] == c)
                    count++;                           
                while (i - j + 1 - count > k)
                {
                    if (s[j] == c)
                        count--;
                    j++;                      
                }
                res = max(res, i - j + 1);
            }
        }

        return res;
    }
```
## 滑动窗口
### 386 · Longest Substring with At Most K Distinct Characters
```
class Solution {
public:
    int lengthOfLongestSubstringKDistinct(string &s, int k) {
        int m = s.length();
        int sum = 0;
        int res = 0;
        unordered_map<char, int> hash;
        for (int r = 0, l = 0; r < m; r++)
        {
            hash[s[r]]++;
            if (hash[s[r]] == 1)
            {
                sum++;
            }
            while (sum > k)
            {
                if (hash[s[l]])
                {
                    hash[s[l]]--;
                }
                if (!hash[s[l]])
                {
                    sum--;
                }
                l++;
            }
            res = max(res, r - l + 1);
        }
        return res;
    }
};
```
### 32 · Minimum Window Substring
```
class Solution {
public:
    string minWindow(string &source , string &target) {
        int m = source.length();
        int n = target.length();
        unordered_map<char, int> shash;
        unordered_map<char, int> thash;
        for (auto t : target)
        {
            thash[t]++;
        }

        int sum = 0;
        int l = 0;
        string res;
        for (int r = 0; r < m; r++)
        {
            shash[source[r]]++;
            if (thash.count(source[r]) && shash[source[r]] <= thash[source[r]])
                sum++;
            while (shash[source[l]] > thash[source[l]]) 
            {
                shash[source[l++]]--;
            }
            if (sum == n)
            {
                if (res.empty() || res.length() > r - l + 1)
                {
                    res = source.substr(l, r - l + 1);
                }
            }
        }
        return res;
    }
};
```
### 1643 · Pick Fruits
```
class Solution {
public:
    int pickFruits(vector<int> &arr) {
        if (arr.empty())
            return 1;
        int m = arr.size();
        unordered_map<int, int> hash;
        int count = 0;
        int res = 0;
        for (int r = 0, l = 0; r < m; r++)
        {
            hash[arr[r]]++;
            if (hash[arr[r]] == 1)
            {
                count++;
            }
            while (count > 2)
            {
                hash[arr[l]]--;
                if (hash[arr[l]] == 0)
                {
                    count--;
                }
                l++;
            }
            res = max(res, r - l + 1);
        }
        return res;
    }
};
```

# 数据结构
## LRU  
### 134 · LRU Cache

```
#include <list>
class LRUCache {
public:
    LRUCache(int capacity) : _capacity(capacity) {

    }
    
    int get(int key) {
        auto it = _table.find(key);
        if (it != _table.end()) {
            _lru.splice(_lru.begin(), _lru, it->second);
            return it->second->second;
        }
        return -1;
    }
    
    void set(int key, int value) {
        auto it = _table.find(key);
        if (it != _table.end()) {
            _lru.splice(_lru.begin(), _lru, it->second);
            it->second->second = value;
            return;
        }
        
        _lru.emplace_front(key, value);
        _table[key] = _lru.begin();
        
        if (_table.size() > _capacity) {
            _table.erase(_lru.back().first);
            _lru.pop_back();
        }
    }
private:
    unordered_map<int, std::list<std::pair<int, int>>::iterator> _table;
    std::list<std::pair<int, int>> _lru;
    int _capacity;
};
```

# 二分查找
### 61 · Search for a Range
### 462 · Total Occurrence of Target

```
class Solution {
public:
    int totalOccurrence(vector<int> &A, int target) {
        if (A.empty())
            return 0;
        int m = A.size();
        int l = 0;
        int r = m - 1;
        while (l < r)
        {
            int mid = (l + r) / 2;
            if (A[mid] >= target)
            {
                r = mid;
            }
            else
            {
                l = mid + 1;
            }
        }

        if (A[l] != target)
            return 0;

        int left = l;
        l = 0;
        r = m - 1;
        while (l < r)
        {
            int mid = (l + r + 1) / 2;
            if (A[mid] <= target)
            {
                l = mid;
            }
            else
            {
                r = mid - 1;
            }
        }
        int right = r;

        return right - left + 1;
    }
};
```
STL 版
```
class Solution {
public:
    int totalOccurrence(vector<int> &A, int target) {
        if (A.empty())
            return 0;
        auto left  = std::lower_bound(A.begin(), A.end(), target);
        if (left == A.end())
            return 0;
        auto right = std::upper_bound(A.begin(), A.end(), target);
        return std::distance(left, right);
    }
};
```
### 74 · First Bad Version
```
    int binarySearch(int l, int r)
    {
        if (l > r) return INT_MAX;
        int mid = l + (r - l) / 2;
        if (SVNRepo::isBadVersion(mid)) 
            return std::min(mid, binarySearch(l, mid - 1));
        return binarySearch(mid + 1, r);
    }
```

# 数学
## n次方
### 428 · Pow(x, n)   50. Pow(x, n)
```
// 如果x^(n/2)，即x的一半，是偶数，x^n = y * y
// 如果x^(n/2)，即x的一半，是奇数，x^n = y * y * x
class Solution {
public:
    double quickMul(double x, long long N) {
        if (N == 0) {
            return 1.0;
        }
        double y = quickMul(x, N / 2);
        return N % 2 == 0 ? y * y : y * y * x;
    }

    double myPow(double x, int n) {
        long long N = n;
        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
    }
};
```

# 并查集
### 1179 · Friend Circles
```
class Solution {
public:
    int find(vector<int>& p, int x)
    {
        if (p[x] != x) p[x] = find(p, p[x]);
            return p[x];
    }
    int findCircleNum(vector<vector<int>> &M) {
        if (M.empty())
            return 0;
        int m = M.size();
        int n = M[0].size();
        vector<int> p(m);
        for (int i = 0; i < m; i++)
        {
            p[i] = i;
        }

        for (int i = 0; i < m; i++)
        {
            for (int j = i + 1; j < n; j++)
            {
                if (M[i][j] == 1)
                {
                    p[find(p, i)] = find(p, j);
                }
            }
        }

        set<int> resset;
        for (int i = 0; i < m; i++)
        {
            resset.insert(find(p, i));
        }

        return resset.size();
    }
};
```
### 677 · Number of Big Islands
计算size的模板
```
class Solution {
public:
    int p[90000] = {0};
    int size[90000] = {0};
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
            return p[x];
    }
    int getIndex(int x, int y, int n)
    {
        return x * n + y;
    }
    bool inBound(int x, int y, int m, int n)
    {
        if (x >= m || y >= n || x < 0 || y < 0)
            return false;
        return true;
    }
    int numsofIsland(vector<vector<bool>> &grid, int k) {
        if (grid.empty())
            return 0;
        int m = grid.size();
        int n = grid[0].size();

        int dx[4] = {1, 0, -1, 0};
        int dy[4] = {0, 1, 0, -1};

        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                p[getIndex(i, j, n)] = getIndex(i, j, n);
                if (grid[i][j])
                    size[getIndex(i, j, n)] = 1;
            }
        }

        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (!grid[i][j])
                    continue;
                for (int k = 0; k < 4; k++)
                {
                    int nx = i + dx[k];
                    int ny = j + dy[k];

                    if (!inBound(nx, ny, m, n))
                        continue;

                    if (grid[nx][ny] == true)
                    {
                        if (find(getIndex(i, j, n)) != find(getIndex(nx, ny, n)))
                        {
                            size[find(getIndex(nx, ny, n))] += size[find(getIndex(i, j, n))];
                            size[find(getIndex(i, j, n))] = 0;
                            p[find(getIndex(i, j, n))] = find(getIndex(nx, ny, n));
                        }
                    }
                }
            }
        }
        int res = 0;
        int maxInd = getIndex(m - 1, n - 1, n);
        for (int i = 0; i <= maxInd; i++)
        {
            if (size[i] >= k)
                res++;   
        }

        return res;
    }
};
```
# 图论
## BFS

### 611 · Knight Shortest Path
```
class Solution {
public:
    bool isNotOut(int x, int y, int m, int n)
    {
        if (x >= m || y >= n || x < 0 || y < 0)
            return false;
        return true;
    }
    int shortestPath(vector<vector<bool>> &grid, Point &source, Point &destination) {
        int m = grid.size();
        int n = grid[0].size();

        int dx[8] = {1, 1, -1, -1, 2, 2, -2, -2};
        int dy[8] = {2, -2, 2, -2, 1, -1, 1, -1};
        vector<vector<bool>> visit(m, vector<bool>(n, false));
        queue<Point> q;
        q.push(source);

        int step = 0;
        while (!q.empty())
        {
            int levelnum = q.size();
            step++;
            while (levelnum--)
            {
                auto cur = q.front(); q.pop();
                if (cur.x == destination.x && cur.y == destination.y)
                    return step-1;
                for (int i = 0; i < 8; i++)
                {
                    int nx = cur.x + dx[i];
                    int ny = cur.y + dy[i];

                    if (isNotOut(nx, ny, m, n) && !visit[nx][ny] && !grid[nx][ny])
                    {
                        q.push(Point(nx, ny));
                        visit[nx][ny] = true;
                    }
                }
            }
        }

        return -1;
    }
};
```
### 137 · Clone Graph
```
// DFS
class Solution {
public:
    UndirectedGraphNode* dfs(UndirectedGraphNode* node, unordered_map<int, UndirectedGraphNode*>& visit)
    {
        if (!node)
            return nullptr;
        
        auto it = visit.find(node->label);
        if (it == visit.end())
        {
            UndirectedGraphNode* current = new UndirectedGraphNode(node->label);
            visit.insert(make_pair(current->label, current));
            for (auto c : node->neighbors)
            {
                UndirectedGraphNode* child = dfs(c, visit);
                current->neighbors.push_back(child);
            }
        }

        return visit[node->label];
    }

    UndirectedGraphNode* cloneGraph(UndirectedGraphNode* node) {
        if (!node)
        {
            return nullptr;
        }

        unordered_map<int, UndirectedGraphNode*> visit;
        return dfs(node, visit);
    }
};

// BFS
class Solution {
public:
    UndirectedGraphNode* cloneGraph(UndirectedGraphNode* node) {
        if (!node)
        {
            return nullptr;
        }
        unordered_map<UndirectedGraphNode*, UndirectedGraphNode*> nodeMap;
        queue<UndirectedGraphNode*> q;
        nodeMap.insert(make_pair(node, new UndirectedGraphNode(node->label)));
        q.push(node);
        while (!q.empty())
        {
            auto cur = q.front(); q.pop();
            for (auto c : cur->neighbors)
            {
                auto it = nodeMap.find(c);
                if (it == nodeMap.end())
                {
                    UndirectedGraphNode* tmpnode = new UndirectedGraphNode(c->label);
                    nodeMap.insert(make_pair(c, tmpnode));
                    nodeMap[cur]->neighbors.push_back(tmpnode);
                    q.push(c);
                }
                else
                {
                    nodeMap[cur]->neighbors.push_back(nodeMap[c]);
                }
            }
        }

        return nodeMap[node];
    }
};
```
### DFS BFS 标准模板题 1563 · Shortest path to the destination
DFS
```
class Solution {
public:
    bool isInBound(int x, int y, int m, int n)
    {
        if (x >= m || x < 0 || y >= n || y < 0)
            return false;
        return true;
    }
    void dfs(vector<vector<int>> &targetMap, vector<vector<bool>> &vis, int x, int y, int current, int& res)
    {
        if (targetMap[x][y] == 2)
        {
            res = min (res, current);
            return;
        }
        int dx[4] = {1,  0, -1, 0};
        int dy[4] = {0, -1,  0, 1};
        int m = targetMap.size();
        int n = targetMap[0].size();
        for (int i = 0; i < 4; i++)
        {
            int nx = x + dx[i];
            int ny = y + dy[i];

            if (isInBound(nx, ny, m, n) && !vis[nx][ny] && targetMap[nx][ny] != 1)
            {
                vis[nx][ny] = true;
                dfs(targetMap, vis, nx, ny, current + 1, res);
                vis[nx][ny] = false;
            }
        }
    }
    int shortestPath(vector<vector<int>> &targetMap) {
        int res = INT_MAX;
        int m = targetMap.size();
        int n = targetMap[0].size();
        vector<vector<bool>> vis(m + 1, vector<bool>(n + 1, false));
        dfs(targetMap, vis, 0, 0, 0, res);
        return res == INT_MAX? -1: res;
    }
};
```
BFS
```
class Solution {
public:
    bool isInBound(int x, int y, int m, int n)
    {
        if (x >= m || x < 0 || y >= n || y < 0)
            return false;
        return true;
    }
    int shortestPath(vector<vector<int>> &targetMap) {
        int m = targetMap.size();
        int n = targetMap[0].size();
        int dx[4] = {1,  0, -1, 0};
        int dy[4] = {0, -1,  0, 1};
        vector<vector<bool>> visit(m, vector<bool>(n, false));
        queue<pair<int, int>> q;
        q.push(make_pair(0, 0));
        visit[0][0] = true;
        int step = 0;
        while (!q.empty())
        {
            int levelcount = q.size();
            while(levelcount--)
            {
                auto cur = q.front(); q.pop();
                if (targetMap[cur.first][cur.second] == 2)
                    return step;
                for (int i = 0; i < 4; i++)
                {
                    int nx = cur.first + dx[i];
                    int ny = cur.second + dy[i];
                    if (isInBound(nx, ny, m, n) && !visit[nx][ny] && targetMap[nx][ny] != 1)
                    {
                        q.push(make_pair(nx, ny));
                        visit[nx][ny] = true;
                    }
                }
            }
            step++;
        }
        return -1;
    }
};
```
###  BFS记录路径的方法
```
#include<cstdio>
#include<queue>
using namespace std;
struct sss
{
    int x,y;
}ans[6][6];
int map[6][6];
int flag[6][6];
int dec[4][2]={1,0,0,1,-1,0,0,-1};
void print(struct sss q)
{
    if(q.x==0&&q.y==0)
    {
        printf("(0, 0)\n");
        return;
    }
    else
    {
        print(ans[q.x][q.y]);
        printf("(%d, %d)\n",q.x,q.y);
    }
}
void bfs(int x,int y)
{
    struct sss q;
    queue<struct sss> s;
    flag[0][0]=1;
    q.x=x;
    q.y=y;
    s.push(q);
    ans[0][0].x=-1;
    ans[0][0].y=-1;
    while(!s.empty())
    {
        q=s.front();
        s.pop();
        if(q.x==4&&q.y==4)
        {
            print(q);
            return;
        }
        for(int i=0;i<4;i++)
        {
            int xx=dec[i][0]+q.x;
            int yy=dec[i][1]+q.y;
            if(xx>=0&&xx<5&&yy>=0&&yy<5&&flag[xx][yy]==0&&map[xx][yy]==0)
            {
                struct sss w;
                w.x=xx;
                w.y=yy;
                s.push(w);
                flag[xx][yy]=1;
                ans[xx][yy].x=q.x;
                ans[xx][yy].y=q.y;
            }
        }
    }
}
int main()
{
    for(int i=0;i<5;i++)
    {
        for(int j=0;j<5;j++)
        {
            scanf("%d",&map[i][j]);
        }
    }
    bfs(0,0);
}
 

 

 

#include<cstdio>
#include<cmath>
#include<vector>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<queue>
#include<map>
#include<string>
using namespace std;
typedef long long ll;
char mp[1001][1001];
int n,m,k;
int flag;
int d[1001][1001];
char jg[1000001];
char yx[1000001];
int dis[4][2]={1,0,0,-1,0,1,-1,0};
char str[5]={"DLRU"};
void pan(int x,int y){
    //printf("k=%d\n",k);
    int tmp=k;
    for(int i=0;i<k;i++){
        int dex=-1;
        for(int j=0;j<4;j++){
            pair<int,int> z;
            z.first=x+dis[j][0];
            z.second=y+dis[j][1];
            if(z.first>=0&&z.first<n&&z.second>=0&&z.second<m&&mp[z.first][z.second]!='*'&&d[z.first][z.second]<tmp){
                dex=j;
                break;
            }
        }
        tmp--;
        x=x+dis[dex][0];
        y=y+dis[dex][1];
        jg[i]=str[dex];
    }
    jg[k]='\0';
    printf("%s\n",jg);
}
void bfs(int x,int y)
{
    queue<pair<int,int> > q;
    q.push(make_pair(x,y));
    for(int i=0;i<1000;i++){
        for(int j=0;j<1000;j++)
          d[i][j]=10000000;
    }
    int num=0;
    d[x][y]=0;
    while(!q.empty()){
        pair<int,int> w=q.front();
        q.pop();
        num++;
        for(int i=0;i<4;i++){
            pair<int,int> z;
            z.first=w.first+dis[i][0];
            z.second=w.second+dis[i][1];
            if(z.first>=0&&z.first<n&&z.second>=0&&z.second<m&&mp[z.first][z.second]=='.'){
                if(d[z.first][z.second]>d[w.first][w.second]+1){
                    d[z.first][z.second]=d[w.first][w.second]+1;
                    q.push(z);
                }
            }
        }
    }
    /*for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            if(d[i][j]==10000000) printf("%4d",-1);
            else printf("%4d",d[i][j]);
        }
        printf("\n");
    }*/
//    printf("num=%d\n",num);
    if(num==1) printf("IMPOSSIBLE");
    else pan(x,y);
}
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    for(int i=0;i<n;i++){
        scanf("%s",mp[i]);
    }
    if(k%2){
        printf("IMPOSSIBLE");
        return 0;
    }
    int vis=0;
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++)
        {
            if(mp[i][j]=='X')
            {
                mp[i][j]='.';
                bfs(i,j);
                vis=1;
                break;    
            }        
        }
        if(vis) break;
    }
}
```

## 拓扑排序

### 127 · Topological Sorting
```
class Solution {
public:
    vector<DirectedGraphNode*> topSort(vector<DirectedGraphNode*> graph) {
        if (graph.empty())
            return {};
        unordered_map<DirectedGraphNode*, int> inDegree;
        for (auto n : graph)
        {
            auto it = inDegree.find(n);
            if (it == inDegree.end())
                inDegree[n] = 0;
            for (auto outn : n->neighbors)
            {
                inDegree[outn]++;
            }
        }

        queue<DirectedGraphNode*> q;
        for (auto n : inDegree)
        {
            //cout << n.first->label << " " << n.second << endl;
            if (n.second == 0)
            {
                
                q.push(n.first);
            }
        }
        vector<DirectedGraphNode*> res;
        while (!q.empty())
        {
            auto cur = q.front(); q.pop();
            res.push_back(cur);
            for (auto c : cur->neighbors)
            {
                if (!(--inDegree[c]))
                    q.push(c);
            }
        }

        return res;
    }
};
```

### 615 · Course Schedule
### 616 · Course Schedule II
```
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<pair<int, int>> &prerequisites) {
        unordered_map<int, vector<int>> g;
        unordered_map<int, int> inDegree;
        for (int i = 0; i < numCourses; i++)
        {
            inDegree[i] = 0;
        }

        for (auto n : prerequisites)
        {
            g[n.second].push_back(n.first);
            inDegree[n.first]++;
        }

        queue<int> q;
        for (auto n : inDegree)
        {
            if (!n.second)
            {
                q.push(n.first);
            }
        }

        vector<int> res;
        while (!q.empty())
        {
            auto cur = q.front(); q.pop();
            res.push_back(cur);

            for (auto n : g[cur])
            {
                if (!(--inDegree[n]))
                {
                    q.push(n);
                }
            }
        }

        return (res.size() != numCourses) ? vector<int>() : res;
    }
};
```
## 爆搜
### 33 · N-Queens
```
class Solution {
public:
    /*
     * @param n: The number of queens
     * @return: All distinct solutions
     */
    void dfs(int r, int n, vector<string>& path, vector<vector<string>>& res)
    {      
        if (r == n)
        {
            res.push_back(path);
            return;
        }
        for (int i = 0; i < n; i++)
        {
            if (!col[i] && !row[i] && !dg[r + i] && !udg[r - i + n])
            {
                path[r][i] = 'Q';
                col[i] = row[i] = dg[r + i] = udg[r - i + n] = true;
                dfs(r + 1, n, path, res);
                path[r][i] = '.';
                col[i] = row[i] = dg[r + i] = udg[r - i + n] = false;
            }
        }
    }
    vector<bool> col;
    vector<bool> row;
    vector<bool> dg;
    vector<bool> udg;
    vector<vector<string>> solveNQueens(int n) {
        if (!n)
            return {};
        vector<bool> lcol(n, false);
        vector<bool> lrow(n, false);
        vector<bool> ldg(2 * n, false);
        vector<bool> ludg(2 * n, false);
        col = lcol;
        row = lrow;
        dg = ldg;
        udg = ludg;

        vector<vector<string>> res;
        vector<string> path(n, string(n, '.'));

        dfs(0, n, path, res);
        return res;
    }
};
```
### 802 · Sudoku Solver
```
class Solution {
public:
    /**
     * @param board: the sudoku puzzle
     * @return: nothing
     */
    bool col[9][10]; 
    bool row[9][10];
    bool cell[3][3][10];
    bool dfs(vector<vector<int>>& board, int x, int y)
    {
        //cout << x << " " << y << endl;
        if (y == 9) 
        {
            x++;
            y = 0;
        }
        if (x == 9)
        {
            return true;
        }

        if (board[x][y] != 0)
            return dfs(board, x, y + 1);
        
        for (int i = 0; i < 9; i++)
        {
            if (!col[x][i] && !row[y][i] && !cell[x / 3][y / 3][i])
            {
                board[x][y] = i + 1;
                col[x][i] = true; row[y][i] = true; cell[x / 3][y / 3][i] = true;
                if (dfs(board, x, y + 1))
                    return true;
                board[x][y] = 0;
                col[x][i] = false; row[y][i] = false; cell[x / 3][y / 3][i] = false;
            }
        }
        return false;
    }
    void solveSudoku(vector<vector<int>> &board) {

        memset(col, 0, 9 * 10 * sizeof(bool));
        memset(row, 0, 9 * 10 * sizeof(bool));
        memset(cell, 0, 3 * 3 * 10 * sizeof(bool));
        for (int i = 0; i < 9; i++)
        {
            for (int j = 0; j < 9; j++)
            {
                if (board[i][j] != 0)
                {
                    col[i][board[i][j] - 1] = true;
                    row[j][board[i][j] - 1] = true;
                    cell[i / 3][j / 3][board[i][j] - 1] = true;
                }
            }
        }

        dfs(board, 0, 0);
        
    }
};
```
## SPFA
### 1565 · Modern Ludo I
```
class Solution {
public:
    int modernLudo(int length, vector<vector<int>> &connections) {
        int m = connections.size();
        vector<int> st(length + 1, 0);
        queue<int> q;
        q.push(1);
        st[1] = true;
        vector<int> dist(length + 1, INT_MAX);
        dist[1] = 0;
        while (!q.empty())
        {
            auto cur = q.front(); q.pop();
            st[cur] = false;
            for (auto e : connections)
            {
                if (e[0] == cur)
                {
                    if (dist[e[1]] > dist[cur])  // dist[e[1]] > dist[cur] + 0
                    {
                        dist[e[1]] = dist[cur];
                        if (!st[e[1]])
                        {
                            q.push(e[1]);
                            st[e[1]] = true;
                        }
                    }
                }
            }
            for (int i = 1; i <= 6; i++)
            {
                auto target = cur + i;
                if (target > length)
                    break;
                if (dist[target] > dist[cur] + 1)
                {
                    dist[target] = dist[cur] + 1;
                    if (!st[target])
                    {
                        q.push(target);
                        st[target] = true;
                    }
                }
            }
        }

        return dist[length];
    }
};
```
### 1469 · Longest Path On The Tree(树的直径)

树的直径，就是从任一点开始找到最远距离点，再从这个最远距离点找另外一个最远距离点，这两点之间就是直径

```
class Solution {
public:
    void spfa(int n, unordered_map<int, vector<pair<int, int>>>& g, int start, int& maxindex, int& maxdist)
    {
        vector<bool> visit(n, false);
        vector<int> dist(n, 0x3f3f3f3f);
        queue<int> q;
        q.push(start);
        visit[start] = true;
        dist[start] = 0;
        while(!q.empty())
        {
            auto cur = q.front(); q.pop();
            visit[cur] = false;
            int m = g[cur].size();
            for (int i = 0; i < m; i++)
            {
                if (dist[g[cur][i].first] > dist[cur] + g[cur][i].second)
                {
                    dist[g[cur][i].first] = dist[cur] + g[cur][i].second;
                    if (maxdist < dist[g[cur][i].first])
                    {
                        maxdist  = dist[g[cur][i].first];
                        maxindex = g[cur][i].first;
                    }
                    if (!visit[g[cur][i].first])
                    {
                        q.push(g[cur][i].first);
                        visit[g[cur][i].first] = true;
                    }
                }
            }
        }
    }
    int longestPath(int n, vector<int> &starts, vector<int> &ends, vector<int> &lens) {
        unordered_map<int, vector<pair<int, int>>> g;
        int m = starts.size();
        for (int i = 0; i < n - 1; i++)
        {
            g[starts[i]].push_back({ends[i], lens[i]});
            g[ends[i]].push_back({starts[i], lens[i]});
        }

        int maxi = 0;
        int maxd = 0;
        spfa(n, g, 0, maxi, maxd);
        spfa(n, g, maxi, maxi, maxd);
        return maxd;
    }
};
```

# 二叉树
### 97 · Maximum Depth of Binary Tree
```
class Solution:
    """
    @param root: The root of binary tree.
    @return: An integer
    """
    def maxDepth(self, root):
        if root is None:
            return 0
        leftDepth = self.maxDepth(root.left)
        rightDepth = self.maxDepth(root.right)
        return max(leftDepth, rightDepth) + 1
```

# String
## 字符串hash
### 128 · Hash Function
```
class Solution {
public:
    int hashCode(string &key, int HASH_SIZE) {
        int P = 33;
        int sum = 0;
        int len = key.length();
        long long h[len] = {0};

        h[0] = key[0];
        for (int i = 1; i < len; i++)
        {   
            h[i] = (h[i - 1] * P + key[i]) % HASH_SIZE;
        }

        return h[len - 1];
    }
};
```

# Heap
### 130 · Heapify
```
    void heapify(vector<int> &A) {
        priority_queue<int, vector<int>, greater<int>> q;
        for (auto n : A)
        {
            q.push(n);
        }
        A.clear();
        while (!q.empty())
        {
            A.push_back(q.top()); q.pop();
        }
    }
    
    void heapify(vector<int> &A) {

        int len = A.size();
        if (!len || len == 1)
           return;
         
        std::make_heap (A.begin(),A.end(), [](int a, int b){return a > b;});
    }    
```
```
void down(vector<int> &A, int i)
    {
        int t = i;
        int len = A.size();
         if (i * 2 <= len && A[i-1] > A[i * 2 - 1])
         {
             t = i * 2;
         }
         if (i * 2 + 1 <= len && A[i - 1] > A[i * 2 + 1 - 1])
         {
             t = i * 2 + 1;
         }

         if (t != i)
         {
             swap(A[t-1], A[i-1]);
             down(A, t);
         }

    }
```
### 613 · High Five
Heap 基础用法
```
class Solution {
public:
    /**
     * @param results a list of <student_id, score>
     * @return find the average of 5 highest scores for each person
     * map<int, double> (student_id, average_score)
     */
    map<int, double> highFive(vector<Record>& results) {
        map<int, priority_queue<int, vector<int>, greater<int>>> hash;
        map<int, double> hashTotal;

        for (auto n : results)
        {
            hash[n.id].push(n.score);
            hashTotal[n.id] += n.score;
            if (hash[n.id].size() > 5)
            {
                hashTotal[n.id] -= hash[n.id].top();
                hash[n.id].pop();
            }
        }
        for (auto& n : hashTotal)
        {
            n.second /= 5.0;
        }
        return hashTotal;
    }
};
```

# Hash
## 扩容
### 129 · Rehashing
```
class Solution {
public:
    int hashcode(int key, int capacity) {
        return (key % capacity + capacity) % capacity;
    }
    vector<ListNode*> rehashing(vector<ListNode*> hashTable) {
        int m = hashTable.size();
        vector<ListNode*> newHashTab(2 * m, nullptr);
        for (auto n : hashTable)
        {
            while (n)
            {
                ListNode* newNode = new ListNode(n->val);
                ListNode* l = newHashTab[hashcode(n->val, 2 * m)];
                if (!l)
                    newHashTab[hashcode(n->val, 2 * m)] = newNode;
                else
                {
                    while (l)
                    {
                        if (!l->next)
                        {
                            l->next = newNode;
                            break;
                        }
                        l = l->next;
                    }
                }
                n = n->next;
            }
        }
        return newHashTab;
    }
};
```
# 链表（见链表页）
### 103 · Linked List Cycle II 链表环 
```
class Solution {
public:
    ListNode * detectCycle(ListNode * head) {
        if(head == NULL || head->next == NULL){
            return NULL;
        }
        ListNode *slow = head;
        ListNode *fast = head;
        while(fast != NULL && fast->next != NULL){
            slow = slow->next;
            fast = fast->next->next;
            if(slow == fast){
                break;
            }
        }
        if(fast == NULL || fast->next == NULL){
            return NULL;
        }
        slow = head;
        while(slow != fast){
            slow = slow->next;
            fast = fast->next;
        }
        return slow;
    }
};
```
### L21. 合并两个有序链表
### L23. 合并K个升序链表
### L19. 删除链表的倒数第 N 个结点
### L876. 链表的中间结点
### 剑指 Offer 24. 反转链表
### 判断单链表是否包含环
### 剑指 Offer II 022. 链表中环的入口节点
### 剑指 Offer II 023. 两个链表的第一个重合节点



# 动态规划
### 515 · Paint House
```
class Solution {
public:
    int minCost(vector<vector<int>> &costs) {
        if (costs.empty())
            return 0;
        int m = costs.size();
        vector<vector<int>> f(m, vector<int>(3, 0));
        f[0][0] = costs[0][0];
        f[0][1] = costs[0][1];
        f[0][2] = costs[0][2];
        for (int i = 1; i < m; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                f[i][j] = min(f[i - 1][(j + 1) % 3], f[i - 1][(j + 2) % 3]) + costs[i][j];
            }
        }
        int res = INT_MAX;
        for (int i = 0; i < 3; i++)
        {
            res = min(res, f[m - 1][i]);
        }

        return res;
    }
};
```

