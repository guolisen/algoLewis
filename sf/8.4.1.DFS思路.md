### 一、树与二叉树相关（DFS 基础场景）

1. **LeetCode 104. Maximum Depth of Binary Tree（二叉树的最大深度）**
    - 思路：递归法，根节点深度为 `1 + max(左子树深度, 右子树深度)`；或 BFS 层序遍历，层数即为最大深度。
2. **LeetCode 111. Minimum Depth of Binary Tree（二叉树的最小深度）**
    - 思路：递归法，注意叶子节点定义，若左 / 右子树为空，深度为 `1 + 非空子树深度`；或 BFS，遇到第一个叶子节点时的层数即为最小深度。
3. **LeetCode 112. Path Sum（路径总和）**
    - 思路：递归法，从根到叶子节点的路径和是否等于目标值；或 BFS，记录节点到根的路径和。
4. **LeetCode 113. Path Sum II（路径总和 II）**
    - 思路：递归法，回溯记录路径，当叶子节点路径和等于目标值时保存路径；或 BFS，同时记录路径和节点。
5. **LeetCode 124. Binary Tree Maximum Path Sum（二叉树中的最大路径和）**
    - 思路：递归法，计算每个节点的 “最大贡献值”（节点值 + max (左贡献，右贡献，0)），同时更新全局最大路径和（节点值 + 左贡献 + 右贡献）。
6. **LeetCode 257. Binary Tree Paths（二叉树的所有路径）**
    - 思路：递归法，回溯记录路径，到达叶子节点时将路径转为字符串保存；或 BFS，同时记录节点和路径。
7. **LeetCode 404. Sum of Left Leaves（左叶子之和）**
    - 思路：递归法，判断节点的左子节点是否为叶子，若是则累加其值，否则递归左右子树；或迭代法（BFS/DFS）。
8. **LeetCode 687. Longest Univalue Path（最长同值路径）**
    - 思路：递归法，计算每个节点的 “左同值链长度 + 右同值链长度”，取最大值；同值链长度为当前节点与子节点值相同时的长度 + 1。
9. **LeetCode 513. Find Bottom Left Tree Value（找树左下角的值）**
    - 思路：层序遍历（BFS），记录每层第一个节点，最后一层的第一个节点即为结果；或 DFS，优先遍历左子树，记录最深层的第一个节点。
10. **LeetCode 98. Validate Binary Search Tree（验证二叉搜索树）**
    - 思路：递归法（中序遍历，记录前驱节点值，确保当前节点值大于前驱）；或递归时传递上下界，确保节点值在合法区间。

### 二、图相关（遍历与连通性）

1. **LeetCode 200. Number of Islands（岛屿数量）**
    - 思路：网格 DFS，遍历每个陆地（'1'），并将其及相邻陆地标记为已访问（'0'），每轮 DFS 对应一个岛屿。
2. **LeetCode 130. Surrounded Regions（被围绕的区域）**
    - 思路：边界 DFS + 标记，先对边界的 'O' 及其连通区域标记为临时值，再将未标记的 'O' 改为 'X'，标记的临时值改回 'O'。
3. **LeetCode 417. Pacific Atlantic Water Flow（太平洋大西洋水流问题）**
    - 思路：双向 DFS，分别从太平洋边界和大西洋边界出发，记录能到达的节点，最后取两者的交集。
4. **LeetCode 695. Max Area of Island（岛屿的最大面积）**
    - 思路：网格 DFS，遍历每个陆地时计算连通区域的面积，更新最大值。
5. **LeetCode 994. Rotting Oranges（腐烂的橘子）**
    - 思路：BFS（更优，因需分层腐烂）或 DFS（需记录时间），初始将所有腐烂橘子入队，每次腐烂相邻新鲜橘子，统计时间。
6. **LeetCode 207. Course Schedule（课程表）**
    - 思路：拓扑排序 + DFS 环检测，构建邻接表和入度表，或用 DFS 检测是否存在环（有环则无法完成）。
7. **LeetCode 210. Course Schedule II（课程表 II）**
    - 思路：DFS 拓扑排序，记录节点的访问状态（未访问、访问中、已访问），后序遍历逆序即为拓扑序列；或 BFS 拓扑排序（Kahn 算法）。

### 三、组合问题（无顺序，不重复选）

1. **LeetCode 39. Combination Sum（组合总和，元素可重复选）**
    - 思路：DFS 回溯，从当前位置开始选，记录路径和，等于目标时保存，超过则剪枝。
2. **LeetCode 40. Combination Sum II（组合总和 II，元素不可重复选）**
    - 思路：DFS 回溯，先排序，同一层相同元素跳过（去重），记录路径和，等于目标时保存。
3. **LeetCode 216. Combination Sum III（组合总和 III，选 k 个数和为目标）**
    - 思路：DFS 回溯，从 1-9 中选 k 个不同数，和为目标，记录路径。
4. **LeetCode 17. Letter Combinations of a Phone Number（电话号码的字母组合）**
    - 思路：多叉树 DFS 回溯，每个数字对应多个字母，依次选择字母组合。
5. **LeetCode 77. Combinations（组合，从 n 选 k 的所有组合）**
    - 思路：DFS 回溯，记录当前选择的数，长度为 k 时保存。

### 四、排列问题（有顺序，全排列 / 部分排列）

1. **LeetCode 46. Permutations（全排列，无重复元素）**
    - 思路：DFS 回溯，用 visited 数组记录已选元素，递归构建排列。
2. **LeetCode 47. Permutations II（全排列 II，有重复元素，去重）**
    - 思路：DFS 回溯，先排序，同一层相同元素跳过（去重），用 visited 数组记录已选元素。
3. **LeetCode 31. Next Permutation（下一个排列）**
    - 思路：贪心（更优），或 DFS 生成所有排列找下一个；贪心步骤：从后找第一个降序对，交换后反转后续部分。
4. **LeetCode 567. Permutation in String（字符串的排列）**
    - 思路：滑动窗口 + 哈希表（判断字符频次是否匹配），或 DFS 辅助判断（但滑动窗口更高效）。

### 五、子集问题（所有可能的子集）

1. **LeetCode 78. Subsets（子集，无重复元素）**
    - 思路：DFS 回溯，每个元素选或不选，记录所有路径。
2. **LeetCode 90. Subsets II（子集 II，有重复元素，去重）**
    - 思路：DFS 回溯，先排序，同一层相同元素跳过（去重），每个元素选或不选。
3. **LeetCode 491. Increasing Subsequences（递增子序列，子集 + 递增约束，去重）**
    - 思路：DFS 回溯，同一层相同元素跳过（去重），确保子序列递增。

### 六、路径搜索与回溯（DFS + 剪枝）

1. **LeetCode 79. Word Search（单词搜索）**
    - 思路：网格 DFS + 回溯，标记已访问的格子，四个方向递归，匹配单词则返回。
2. **LeetCode 212. Word Search II（单词搜索 II）**
    - 思路：Trie + DFS 优化，先构建单词的 Trie 树，再网格 DFS 时借助 Trie 剪枝。
3. **LeetCode 51. N-Queens（N 皇后）**
    - 思路：经典回溯 + DFS 剪枝，逐行放置皇后，判断列、对角线是否冲突。
4. **LeetCode 52. N-Queens II（N 皇后 II）**
    - 思路：同 N 皇后，仅统计解的数量。
5. **LeetCode 37. Sudoku Solver（解数独）**
    - 思路：DFS + 回溯，逐格尝试填入数字，判断行、列、宫是否合法。
6. **LeetCode 131. Palindrome Partitioning（分割回文串）**
    - 思路：DFS 分割 + 回文判断，递归尝试所有分割点，子串是回文则继续。
7. **LeetCode 132. Palindrome Partitioning II（分割回文串 II）**
    - 思路：DFS + 动态规划优化，先预处理回文子串，再用 DP 记录最小分割数。

### 七、其他高频 DFS 题

1. **LeetCode 494. Target Sum（目标和）**
    - 思路：DFS + 回溯，每个数选 + 或 -，统计和为目标的方案数；或动态规划（背包问题思路）。
2. **LeetCode 95. Unique Binary Search Trees II（不同的二叉搜索树 II）**
    - 思路：DFS 构造，选根节点，递归构造左右子树，组合所有可能的左右子树。
3. **LeetCode 297. Serialize and Deserialize Binary Tree（二叉树的序列化与反序列化）**
    - 思路：DFS 递归序列化（前序遍历，记录空节点），反序列化时根据前序序列递归重建。
4. **LeetCode 329. Longest Increasing Path in a Matrix（最长递增路径 in 矩阵）**
    - 思路：网格 DFS + 记忆化，记录每个格子的最长递增路径长度，避免重复计算。