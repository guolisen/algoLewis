### 一、树与二叉树相关（DFS 基础场景）

1. **LeetCode 104. Maximum Depth of Binary Tree（二叉树的最大深度）**
    - **题目描述**：给定二叉树的根节点，返回树的最大深度（根节点到最远叶子节点的最长路径上的节点数）。
    - **示例**：输入 `3->9->20->null->null->15->7`，输出 `3`。
    - 思路：递归法，根节点深度为 `1 + max(左子树深度, 右子树深度)`；或 BFS 层序遍历，层数即为最大深度。
2. **LeetCode 111. Minimum Depth of Binary Tree（二叉树的最小深度）**
    - **题目描述**：给定二叉树的根节点，返回树的最小深度（根节点到最近叶子节点的路径上的节点数）。
    - **示例**：输入 `3->9->20->null->null->15->7`，输出 `2`（根到叶子 9 的路径）。
    - 思路：递归法，注意叶子节点定义，若左 / 右子树为空，深度为 `1 + 非空子树深度`；或 BFS，遇到第一个叶子节点时的层数即为最小深度。
3. **LeetCode 112. Path Sum（路径总和）**
    - **题目描述**：给定二叉树的根节点和目标和 `targetSum`，判断是否存在从根到叶子的路径，节点值之和等于 `targetSum`。
    - **示例**：输入 `5->4->8->11->null->13->4->7->2->null->null->null->1`，`targetSum=22`，输出 `true`（5+4+11+2=22）。
    - 思路：递归法，从根到叶子节点的路径和是否等于目标值；或 BFS，记录节点到根的路径和。
4. **LeetCode 113. Path Sum II（路径总和 II）**
    - **题目描述**：给定二叉树的根节点和目标和 `targetSum`，返回所有从根到叶子的路径，其节点值之和等于 `targetSum`（路径以节点值列表形式返回）。
    - **示例**：输入同上，`targetSum=22`，输出 `[[5,4,11,2]]`。
    - 思路：递归法，回溯记录路径，当叶子节点路径和等于目标值时保存路径；或 BFS，同时记录路径和节点。
5. **LeetCode 124. Binary Tree Maximum Path Sum（二叉树中的最大路径和）**
    - **题目描述**：给定二叉树的根节点，返回树中任意路径的最大和（路径可从任意节点出发到任意节点，至少含一个节点）。
    - **示例**：输入 `1->2->3`，输出 `6`（2+1+3）；输入 `-10->9->20->15->7`，输出 `42`（15+20+7）。
    - 思路：递归法，计算每个节点的 “最大贡献值”（节点值 + max (左贡献，右贡献，0)），同时更新全局最大路径和（节点值 + 左贡献 + 右贡献）。
6. **LeetCode 257. Binary Tree Paths（二叉树的所有路径）**
    - **题目描述**：给定二叉树的根节点，返回所有从根到叶子的路径，路径以字符串形式表示（如 `"1->2->5"`）。
    - **示例**：输入 `1->2->3->null->5`，输出 `["1->2->5", "1->3"]`。
    - 思路：递归法，回溯记录路径，到达叶子节点时将路径转为字符串保存；或 BFS，同时记录节点和路径。
7. **LeetCode 404. Sum of Left Leaves（左叶子之和）**
    - **题目描述**：给定二叉树的根节点，返回所有左叶子节点的值之和（左叶子指父节点的左子节点且自身无左右子树）。
    - **示例**：输入 `3->9->20->null->null->15->7`，左叶子为 9 和 15，输出 `24`。
    - 思路：递归法，判断节点的左子节点是否为叶子，若是则累加其值，否则递归左右子树；或迭代法（BFS/DFS）。
8. **LeetCode 687. Longest Univalue Path（最长同值路径）**
    - **题目描述**：给定二叉树的根节点，返回最长同值路径的长度（路径上所有节点值相同，长度为边数，路径可从任意节点出发）。
    - **示例**：输入 `5->4->5->1->1->null->5`，输出 `2`（右子树 5-5 的边数）。
    - 思路：递归法，计算每个节点的 “左同值链长度 + 右同值链长度”，取最大值；同值链长度为当前节点与子节点值相同时的长度 + 1。
9. **LeetCode 513. Find Bottom Left Tree Value（找树左下角的值）**
    - **题目描述**：给定二叉树的根节点，返回最底层（最深层）最左边节点的值。
    - **示例**：输入 `2->1->3`，输出 `1`；输入 `1->2->3->4->null->5->6->null->null->7`，输出 `7`。
    - 思路：层序遍历（BFS），记录每层第一个节点，最后一层的第一个节点即为结果；或 DFS，优先遍历左子树，记录最深层的第一个节点。
10. **LeetCode 98. Validate Binary Search Tree（验证二叉搜索树）**
    - **题目描述**：给定二叉树的根节点，判断其是否为二叉搜索树（BST：左子树所有节点值 <根，右子树所有节点值> 根，且左右子树均为 BST）。
    - **示例**：输入 `2->1->3`，输出 `true`；输入 `5->1->4->null->null->3->6`，输出 `false`（4 的左子树 3 < 5 不满足）。
    - 思路：递归法（中序遍历，记录前驱节点值，确保当前节点值大于前驱）；或递归时传递上下界，确保节点值在合法区间。

### 二、图相关（遍历与连通性）

1. **LeetCode 200. Number of Islands（岛屿数量）**
    - **题目描述**：给定 `m x n` 的网格，`'1'` 代表陆地，`'0'` 代表水，相邻陆地（水平 / 垂直）组成岛屿，返回岛屿的数量。
    - **示例**：输入 `[["1","1","0","0","0"],["1","1","0","0","0"],["0","0","1","0","0"],["0","0","0","1","1"]]`，输出 `3`。
    - 思路：网格 DFS，遍历每个陆地（'1'），并将其及相邻陆地标记为已访问（'0'），每轮 DFS 对应一个岛屿。
2. **LeetCode 130. Surrounded Regions（被围绕的区域）**
    - **题目描述**：给定 `m x n` 的网格，`'X'` 和 `'O'` 组成，被 `'X'` 完全包围的 `'O'` 需改为 `'X'`，边界上的 `'O'` 及其连通区域不变。
    - **示例**：输入边界有 `'O'` 时，其连通区域保留，其他 `'O'` 改为 `'X'`。
    - 思路：边界 DFS + 标记，先对边界的 'O' 及其连通区域标记为临时值，再将未标记的 'O' 改为 'X'，标记的临时值改回 'O'。
3. **LeetCode 417. Pacific Atlantic Water Flow（太平洋大西洋水流问题）**
    - **题目描述**：给定 `m x n` 的高度矩阵，太平洋在左 / 上边界，大西洋在右 / 下边界，水流只能从高到低或等高流动，返回既能流到太平洋又能流到大西洋的单元格坐标。
    - **示例**：输入 `[[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]`，输出能流到两洋的坐标列表。
    - 思路：双向 DFS，分别从太平洋边界和大西洋边界出发，记录能到达的节点，最后取两者的交集。
4. **LeetCode 695. Max Area of Island（岛屿的最大面积）**
    - **题目描述**：给定 `m x n` 的网格，`'1'` 代表陆地，`'0'` 代表水，返回最大岛屿的面积（岛屿面积为陆地单元格数量）。
    - **示例**：输入含一个 6 单元格的岛屿，输出 `6`。
    - 思路：网格 DFS，遍历每个陆地时计算连通区域的面积，更新最大值。
5. **LeetCode 994. Rotting Oranges（腐烂的橘子）**
    - **题目描述**：给定 `m x n` 的网格，`0` 是空，`1` 是新鲜橘子，`2` 是腐烂橘子，腐烂橘子每天会感染上下左右的新鲜橘子，返回直到所有橘子腐烂的天数（若有新鲜橘子无法腐烂，返回 `-1`）。
    - **示例**：输入 `[[2,1,1],[1,1,0],[0,1,1]]`，输出 `4`。
    - 思路：BFS（更优，因需分层腐烂）或 DFS（需记录时间），初始将所有腐烂橘子入队，每次腐烂相邻新鲜橘子，统计时间。
6. **LeetCode 207. Course Schedule（课程表）**
    - **题目描述**：给定 `numCourses` 门课程和先修课程列表 `prerequisites`（如 `[a,b]` 表示修 a 前需先修 b），判断是否可能完成所有课程。
    - **示例**：`numCourses=2`，`prerequisites=[[1,0]]`，输出 `true`；若 `prerequisites=[[1,0],[0,1]]`，输出 `false`（有环）。
    - 思路：拓扑排序 + DFS 环检测，构建邻接表和入度表，或用 DFS 检测是否存在环（有环则无法完成）。
7. **LeetCode 210. Course Schedule II（课程表 II）**
    - **题目描述**：同上，若可能完成所有课程，返回课程学习顺序；否则返回空数组。
    - **示例**：`numCourses=4`，`prerequisites=[[1,0],[2,0],[3,1],[3,2]]`，输出 `[0,1,2,3]` 或其他合法顺序。
    - 思路：DFS 拓扑排序，记录节点的访问状态（未访问、访问中、已访问），后序遍历逆序即为拓扑序列；或 BFS 拓扑排序（Kahn 算法）。

### 三、组合问题（无顺序，不重复选）

1. **LeetCode 39. Combination Sum（组合总和，元素可重复选）**
    - **题目描述**：给定无重复元素的整数数组 `candidates` 和目标数 `target`，找出所有元素和为 `target` 的组合（元素可重复选取，组合无顺序）。
    - **示例**：`candidates = [2,3,6,7]`，`target = 7`，输出 `[[2,2,3],[7]]`。
    - 思路：DFS 回溯，从当前位置开始选，记录路径和，等于目标时保存，超过则剪枝。
2. **LeetCode 40. Combination Sum II（组合总和 II，元素不可重复选）**
    - **题目描述**：给定可能含重复元素的整数数组 `candidates` 和目标数 `target`，找出所有元素和为 `target` 的组合（元素不可重复选取，组合无顺序，结果去重）。
    - **示例**：`candidates = [10,1,2,7,6,1,5]`，`target = 8`，输出 `[[1,1,6],[1,2,5],[1,7],[2,6]]`。
    - 思路：DFS 回溯，先排序，同一层相同元素跳过（去重），记录路径和，等于目标时保存。
3. **LeetCode 216. Combination Sum III（组合总和 III，选 k 个数和为目标）**
    - **题目描述**：找出所有由 `k` 个不同的 1-9 数字组成的组合，其和为 `n`（每个数字只能用一次）。
    - **示例**：`k=3`，`n=7`，输出 `[[1,2,4]]`；`k=3`，`n=9`，输出 `[[1,2,6],[1,3,5],[2,3,4]]`。
    - 思路：DFS 回溯，从 1-9 中选 k 个不同数，和为目标，记录路径。
4. **LeetCode 17. Letter Combinations of a Phone Number（电话号码的字母组合）**
    - **题目描述**：给定仅含数字 `2-9` 的字符串，返回所有可能的字母组合（数字与字母映射同手机键盘：2→abc，3→def 等）。
    - **示例**：输入 `"23"`，输出 `["ad","ae","af","bd","be","bf","cd","ce","cf"]`。
    - 思路：多叉树 DFS 回溯，每个数字对应多个字母，依次选择字母组合。
5. **LeetCode 77. Combinations（组合，从 n 选 k 的所有组合）**
    - **题目描述**：给定两个整数 `n` 和 `k`，返回 1-n 中所有可能的 `k` 个数的组合（组合无顺序）。
    - **示例**：`n=4`，`k=2`，输出 `[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]`。
    - 思路：DFS 回溯，记录当前选择的数，长度为 k 时保存。

### 四、排列问题（有顺序，全排列 / 部分排列）

1. **LeetCode 46. Permutations（全排列，无重复元素）**
    - **题目描述**：给定不含重复元素的整数数组 `nums`，返回所有可能的全排列（排列有顺序）。
    - **示例**：`nums = [1,2,3]`，输出 `[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]`。
    - 思路：DFS 回溯，用 visited 数组记录已选元素，递归构建排列。
2. **LeetCode 47. Permutations II（全排列 II，有重复元素，去重）**
    - **题目描述**：给定可能含重复元素的整数数组 `nums`，返回所有可能的全排列（结果需去重）。
    - **示例**：`nums = [1,1,2]`，输出 `[[1,1,2],[1,2,1],[2,1,1]]`。
    - 思路：DFS 回溯，先排序，同一层相同元素跳过（去重），用 visited 数组记录已选元素。
3. **LeetCode 31. Next Permutation（下一个排列）**
    - **题目描述**：实现获取下一个排列的函数，即字典序中下一个更大的排列（若已为最大，则返回最小排列）。
    - **示例**：输入 `[1,2,3]`，输出 `[1,3,2]`；输入 `[3,2,1]`，输出 `[1,2,3]`。
    - 思路：贪心（更优），或 DFS 生成所有排列找下一个；贪心步骤：从后找第一个降序对，交换后反转后续部分。
4. **LeetCode 567. Permutation in String（字符串的排列）**
    - **题目描述**：给定两个字符串 `s1` 和 `s2`，判断 `s2` 中是否包含 `s1` 的排列（即 `s1` 所有字符的某个排列是 `s2` 的子串）。
    - **示例**：`s1 = "ab"`，`s2 = "eidbaooo"`，输出 `true`（`s2` 含 `"ba"` 是 `s1` 的排列）。
    - 思路：滑动窗口 + 哈希表（判断字符频次是否匹配），或 DFS 辅助判断（但滑动窗口更高效）。

### 五、子集问题（所有可能的子集）

1. **LeetCode 78. Subsets（子集，无重复元素）**
    - **题目描述**：给定不含重复元素的整数数组 `nums`，返回所有可能的子集（包括空集和全集，子集无顺序）。
    - **示例**：`nums = [1,2,3]`，输出 `[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]`。
    - 思路：DFS 回溯，每个元素选或不选，记录所有路径。
2. **LeetCode 90. Subsets II（子集 II，有重复元素，去重）**
    - **题目描述**：给定可能含重复元素的整数数组 `nums`，返回所有可能的子集（结果需去重）。
    - **示例**：`nums = [1,2,2]`，输出 `[[],[1],[1,2],[1,2,2],[2],[2,2]]`。
    - 思路：DFS 回溯，先排序，同一层相同元素跳过（去重），每个元素选或不选。
3. **LeetCode 491. Increasing Subsequences（递增子序列，子集 + 递增约束，去重）**
    - **题目描述**：给定整数数组 `nums`，返回所有长度 ≥2 的递增子序列（子序列元素相对顺序不变，结果去重）。
    - **示例**：`nums = [4,6,7,7]`，输出 `[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]`。
    - 思路：DFS 回溯，同一层相同元素跳过（去重），确保子序列递增。

### 六、路径搜索与回溯（DFS + 剪枝）

1. **LeetCode 79. Word Search（单词搜索）**
    - **题目描述**：给定 `m x n` 的字符网格 `board` 和字符串 `word`，判断 `word` 是否存在于网格中（字母需相邻且不重复使用）。
    - **示例**：`board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]]`，`word = "ABCCED"`，输出 `true`。
    - 思路：网格 DFS + 回溯，标记已访问的格子，四个方向递归，匹配单词则返回。
2. **LeetCode 212. Word Search II（单词搜索 II）**
    - **题目描述**：给定字符网格 `board` 和单词列表 `words`，返回所有在网格中能找到的单词（单词搜索规则同上）。
    - **示例**：`words = ["oath","pea","eat","rain"]`，网格含 "oath" 和 "eat"，输出 `["oath","eat"]`。
    - 思路：Trie + DFS 优化，先构建单词的 Trie 树，再网格 DFS 时借助 Trie 剪枝。
3. **LeetCode 51. N-Queens（N 皇后）**
    - **题目描述**：n 皇后问题是将 n 个皇后放置在 n×n 的棋盘上，使皇后间不能互相攻击（同列、同行、同对角线无其他皇后），返回所有合法的放置方案（以棋盘字符形式表示）。
    - **示例**：n=4，输出 `[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]`。
    - 思路：经典回溯 + DFS 剪枝，逐行放置皇后，判断列、对角线是否冲突。
4. **LeetCode 52. N-Queens II（N 皇后 II）**
    - **题目描述**：同上，仅返回合法放置方案的数量。
    - **示例**：n=4，输出 `2`。
    - 思路：同 N 皇后，仅统计解的数量。
5. **LeetCode 37. Sudoku Solver（解数独）**
    - **题目描述**：给定 9×9 的数独板 `board`（`'.'` 表示空），填充空格使其满足数独规则（每行、每列、每个 3×3 宫格含 1-9 不重复）。
    - **示例**：输入含部分数字的数独，输出填充完成的合法数独。
    - 思路：DFS + 回溯，逐格尝试填入数字，判断行、列、宫是否合法。
6. **LeetCode 131. Palindrome Partitioning（分割回文串）**
    - **题目描述**：给定字符串 `s`，将其分割成一些子串，使每个子串都是回文串，返回所有可能的分割方案。
    - **示例**：`s = "aab"`，输出 `[["a","a","b"],["aa","b"]]`。
    - 思路：DFS 分割 + 回文判断，递归尝试所有分割点，子串是回文则继续。
7. **LeetCode 132. Palindrome Partitioning II（分割回文串 II）**
    - **题目描述**：给定字符串 `s`，返回将其分割成回文子串的最少分割次数（如 `s="aab"` 最少分割 1 次：`"aa|b"`）。
    - **示例**：`s = "aab"`，输出 `1`。
    - 思路：DFS + 动态规划优化，先预处理回文子串，再用 DP 记录最小分割数。

### 七、其他高频 DFS 题

1. **LeetCode 494. Target Sum（目标和）**
    - **题目描述**：给定非负整数数组 `nums` 和目标数 `target`，给每个数前加 `+` 或 `-`，使所有数的和等于 `target`，返回方案数。
    - **示例**：`nums = [1,1,1,1,1]`，`target = 3`，输出 `5`（有 5 种组合方式）。
    - 思路：DFS + 回溯，每个数选 + 或 -，统计和为目标的方案数；或动态规划（背包问题思路）。
2. **LeetCode 95. Unique Binary Search Trees II（不同的二叉搜索树 II）**
    - **题目描述**：给定整数 `n`，生成所有由 1-n 为节点的不同二叉搜索树（BST）。
    - **示例**：n=3，输出 5 种不同结构的 BST。
    - 思路：DFS 构造，选根节点，递归构造左右子树，组合所有可能的左右子树。
3. **LeetCode 297. Serialize and Deserialize Binary Tree（二叉树的序列化与反序列化）**
    - **题目描述**：设计算法将二叉树序列化为字符串，再将字符串反序列化为原始二叉树（序列化格式自定义）。
    - **示例**：序列化 `1->2->3->null->null->4->5` 为 `"1,2,3,null,null,4,5"`，反序列化后恢复原树。
    - 思路：DFS 递归序列化（前序遍历，记录空节点），反序列化时根据前序序列递归重建。
4. **LeetCode 329. Longest Increasing Path in a Matrix（最长递增路径 in 矩阵）**
    - **题目描述**：给定 `m x n` 的整数矩阵，找出最长递增路径的长度（路径可从任意单元格开始，向上下左右移动，每个步长值严格递增）。
    - **示例**：输入 `[[9,9,4],[6,6,8],[2,1,1]]`，输出 `4`（路径 1→2→6→9）。
    - 思路：网格 DFS + 记忆化，记录每个格子的最长递增路径长度，避免重复计算。