[TOC]



# 57 · 三数之和（双指针，固定一个，动另外两个）

固定一个，动另外两个

```
class Solution {
public:
    vector<vector<int>> threeSum(vector<int> &n) {
        int m = n.size();
        sort(n.begin(), n.end());
        set<vector<int>> res;
        for (int i = 0; i < m; i++)
        {
            int l = i + 1;
            int r = m - 1;
            while (l < r)
            {
                int sum = n[l] + n[r] + n[i];
                if (sum == 0)
                {
                    res.insert({n[i], n[l], n[r]});
                    l++;
                }
                else if (sum > 0)
                {
                    r--;
                }
                else
                {
                    l++;
                }
            }
        }
        vector<vector<int>> rr(res.begin(), res.end());
        return rr;
    }
};
```
# 667 ·  Longest Palindromic Subsequence 最长的回文序列（区间DP）

区间dp  子序列，不连续但是顺序固定，子数组/子字符串，连续
```
class Solution {
public:
    /**
     * @param s: the maximum length of s is 1000
     * @return: the longest palindromic subsequence's length
     */
    int longestPalindromeSubseq(string &s) {
        if (s.empty())
            return 0;
        int m = s.size();
        vector<vector<int>> f(m, vector<int>(m, 0));
        for(int len = 1; len <= m; len++)
        {
            for (int i = 0; i + len - 1 < m; i++)
            {
                int j = i + len - 1;
                if (len == 1)
                    f[i][j] = 1;
                else if (s[i] == s[j])
                    f[i][j] = f[i + 1][j - 1] + 2;
                else
                    f[i][j] = max(f[i + 1][j], f[i][j - 1]);
            }
        }
        return f[0][m - 1];
    }
};
```

# 200 · Longest Palindromic Substring 最长回文子串（区间 DP，从里往外算）



区间 DP，从里往外算

```
class Solution {
public:
    /**
     * @param s: input string
     * @return: a string as the longest palindromic substring
     */
    string longestPalindrome(string &s) {
        int m = s.size();
        vector<vector<bool>> f(m, vector<bool>(m));
        for (int i = 0; i < m; i++)
        {
            f[i][i] = true;
        }

        int maxlen = 0;
        string res = "";
        for (int len = 1; len <= m; len++)
        {
            for (int i = 0; i + len - 1 < m; i++)
            {
                int j = i + len - 1;
                if (s[i] == s[j])
                {
                    // i + 1 > j - 1 确定 单个字符 或者 两个字符的情况
                    if (i + 1 > j - 1 || f[i + 1][j - 1])
                    {
                        f[i][j] = true;
                        maxlen = len;
                        res = s.substr(i, len);
                    }
                }
            }
        }
        return res;
    }
};
```
# 76 · Longest Increasing Subsequence(LIS)

f[i\] 表示所有以第i个字符为结尾的上升子序列

```
class Solution {
public:
    int longestIncreasingSubsequence(vector<int> &nums) {
        if (nums.empty())
            return 0;
        int m = nums.size();
        vector<int> f(m, 1);
        int res = 1;
        for (int i = 1; i < m; i++)
        {
            for (int j = 0; j < i; j++)
            {
                if (nums[i] > nums[j])
                {
                    f[i] = max(f[i], f[j] + 1);
                    res = max(res, f[i]);
                }
            }
        }
        return res;
    }
};
```

```
class Solution:
    def longest_increasing_subsequence(self, nums: List[int]) -> int:
        m = len(nums)
        if m == 0:
            return 0
        dp = [1 for _ in range(m)]

        res = 1
        for i in range(1, m):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)
                    res = max(res, dp[i])
        return res

```



# 77 · Longest Common Subsequence（LCS） 最长公共子序列

f [ i \]\[ j ] 为第一个序列前i个字符中，和第二个序列前j个字符中的公共序列。所有在第一个序列的前i个字母中出现的，且在第二个序列中的前j个字母中出现的子序列

转移方程是看最后一个字符是否选取，a[i],b[j], 都选‘f[i - 1\][j - 1] + 1’, 都不选 f[i - 1\][j - 1]

```
int longestCommonSubsequence(string &A, string &B) {
    int m1 = A.size();
    int m2 = B.size();
    vector<vector<int>> f(m1 + 1, vector<int>(m2 + 1, 0));

    for (int i = 1; i <= m1; i++)
    {
        for (int j = 1; j <= m2; j++)
        {
            f[i][j] = max(f[i - 1][j], f[i][j - 1]);
            if (A[i - 1] == B[j - 1])
            {
                f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1);
            }
        }
    }
    return f[m1][m2];
}
```

# 124 · Longest Consecutive Sequence（可结合字符串处理数字序列）

   利用hash

   ```
   class Solution:
       def longestConsecutive(self, nums: List[int]) -> int:
           if len(nums) == 0:
               return 0
           m = len(nums)
           ns = set(nums)
   
           maxlen = 1
           for c in ns:
               if c - 1 not in ns:
                   curlen = 1
                   curchr = c
                   while curchr + 1 in ns:
                       curlen += 1
                       maxlen = max(maxlen, curlen)
                       curchr += 1
   
           return maxlen
   ```

# 594 · 字符串查找 II（字符串hash）

```
class Solution {
public:
    typedef unsigned long long ULL;

    ULL getHash(vector<ULL>& h, vector<ULL>& p, int L, int R)
    {
        return h[R] - h[L - 1] * p[R - (L - 1)];  //左移R - (L - 1)位后h[R] = 123456 h[L-1] = 123000
    }
    int strStr2(string &source, string &target) {
        int m = source.size();
        int n = target.size();

        vector<ULL> shash(m + 1, 0);
        vector<ULL> thash(n + 1, 0);
        vector<ULL> p(m + 1, 0);
        int P = 31;

        p[0] = 1;
        for (int i = 1; i <= m; i++)
        {
            p[i] = p[i - 1] * P;
            shash[i] = shash[i - 1] * P + source[i - 1];
        }

        for (int i = 1; i <= n; i++)
        {
            thash[i] = thash[i - 1] * P + target[i - 1];
        }

        for (int i = 1; i + n - 1 <= m; i++)
        {
            ULL hh = getHash(shash, p, i, i + n - 1);
            if (hh == thash[n])
                return i - 1;
        }
        return -1;
    }
};
```

# 539 · Move Zeroes（同向双指针）

同向双指针
```
class Solution {
public:
    void  moveZeroes(vector<int> &nums) {
        int m = nums.size();
        int l = 0;
        int r = 0;
        while (r < m)
        {
            if (nums[r] != 0)
            {
                swap(nums[l], nums[r]);
                l++;
            }
            r++;
        }
    }
};
```
# 443 · Two Sum - Greater than target（相向双指针）
相向双指针
```
class Solution {
public:
    int twoSum2(vector<int> &nums, int target) {
        int m = nums.size();
        sort (nums.begin(), nums.end());
        int l = 0;
        int r = m - 1;
        int res = 0;

        while (l < r)
        {
            int sum = nums[l] + nums[r];
            if (sum > target)
            {
                res += r - l;
                r--;
            }
            else
            {
                l++;
            }
        }
        return res;
    }
};
```


# 382 · Triangle Count（两个小边和如果大于这个大边，其他也都大于）

双指针，从大到小找，另外两个小边和如果大于这个大边，其他,r不变，l到r的也都大于
```
class Solution {
public:
    /**
     * @param s: A list of integers
     * @return: An integer
     */
    int triangleCount(vector<int> &s) {
        sort(s.begin(), s.end());
        int m = s.size();
        int res = 0;

        // 从大到小找，另外两个小边和如果大于这个大边，其他,r不变，l到r的也都大于
        for (int i = m - 1; i >= 0; i--)
        {
            int l = 0;
            int r = i - 1;

            while (l < r && r >= 0)
            {
                int sum = s[l] + s[r];
                if (sum > s[i])
                {
                    res += (r - l);
                    r--;
                }
                else
                {
                    l++;
                }
            }
        }
        return res;
    }
};
```

# 460 · Find K Closest Elements（isLeftClosest）

## 901 · Closest Binary Search Tree Value II

k个最接近目标值的数

```
class Solution {
public:
     bool isLeftClosest(vector<int> &a, int target, int l, int r)
     {
        if (l < 0)
            return false;
        if (r >= a.size())
            return true;
        if (target - a[l] <= a[r] - target)
            return true;
        return false;  
     }
    vector<int> kClosestNumbers(vector<int> &a, int target, int k) {
        vector<int> res;
        int l = 0;
        int r = a.size() - 1;
        while (l < r)
        {
            int mid = (l + r) / 2;
            if (a[mid] >= target)
            {
                r = mid;
            }
            else
            {
                l = mid + 1;
            }
        }
        int left  = l - 1;
        int right = l;
        while (k--)
        {
            if (isLeftClosest(a, target, left, right))
            {
                res.push_back(a[left--]);
            }
            else
            {
                res.push_back(a[right++]);
            }
        }
        return res;
    }
};
```
# 62 · Search in Rotated Sorted Array（比较左端点，想象成一个菱形）
想象成一个菱形，如果是上半部分，就判断是上坡，还是下坡，最后决定是r = mid或l = mid + 1

和左端点比较，确定是上半部还是下半部，判断坡度，确定是上升还是下降

```
class Solution {
public:
    bool check(vector<int> &A, int mid, int l, int r, int target)
    {
        int m = A.size();
        if (A[l] <= A[mid])
        {
            if (A[l] <= target && target <= A[mid])
            {
                return true;
            }
            else
                return false;
        }
        else
        {
            if (A[mid] <= target && target <= A[r])
            {
                return false;
            }
            else
                return true;
        }
    }
    int search(vector<int> &A, int target) {
        if (A.empty())
            return -1;
        int m = A.size();
        int l = 0;
        int r = m - 1;
        while (l < r)
        {
            int mid = (l + r) / 2;
            if(check(A, mid, l, r, target))
            {
                r = mid;
                if (A[mid] == target)
                    return mid;
            }
            else
            {
                l = mid + 1;
                if (A[mid] == target)
                    return mid;
            }
        }
        if (A[l] != target)
            return -1;
        return l;
    }
};
```

# 585 · Maximum Number in Mountain Sequence（比较两个数即可）

```
class Solution {
public:
    bool check(vector<int> &nums, int mid)
    {
        int m = nums.size();
        if ((mid - 1 >= 0 && nums[mid - 1] > nums[mid]) || 
            (mid + 1 < m && nums[mid] > nums[mid + 1]))
        {
            return true;
        }
        return false;
    }
    int mountainSequence(vector<int> &nums) {
        int m = nums.size();
        int l = 0;
        int r = m - 1;
        while (l < r)
        {
            int mid = (l + r) / 2;
            if (check(nums, mid))
            {
                r = mid;
            }
            else
            {
                l = mid + 1;
            }
        }
        return nums[l];
    }
};
```

# 137 · Clone Graph

1. 建立原始节点和新clone节点的map结构
2. 每次只处理当前节点和子节点，只将当前节点的子节点，加入到当前节点的clone节点中（当前节点 -> 子节点, 不处理 子节点->当前节点）

```
/**
 * Definition for undirected graph.
 * struct UndirectedGraphNode {
 *     int label;
 *     vector<UndirectedGraphNode *> neighbors;
 *     UndirectedGraphNode(int x) : label(x) {};
 * };
 */

class Solution {
public:
    UndirectedGraphNode* cloneGraph(UndirectedGraphNode *node) {
        if(!node)
            return nullptr;
        unordered_map<UndirectedGraphNode *, UndirectedGraphNode *> mclone;

        UndirectedGraphNode* croot = new UndirectedGraphNode(node->label);
        mclone[node] = croot;
        queue<UndirectedGraphNode *> q;
        q.push(node);

        while (!q.empty())
        {
            auto cur = q.front(); q.pop();
            for (auto n : cur->neighbors)
            {
                auto it = mclone.find(n);
                if (it != mclone.end())
                {
                    mclone[cur]->neighbors.push_back(it->second);
                }
                else
                {
                    auto newNode = new UndirectedGraphNode(n->label);
                    mclone[cur]->neighbors.push_back(newNode);
                    mclone[n] = newNode;
                    q.push(n);
                }
            }
        }
        return croot;

    }
};
```

# 120 · Word Ladder

方法1：将cur和dict里面的单词比较，只差一个字母的入队，宽搜

方法2： cur单词的每个位置用26字母替换，然后看是否在dict，且没有visit，如果是，入队

```
class Solution {
public:
    int ladderLength(string &start, string &end, unordered_set<string> &dict) {
        dict.insert(end);
        queue<string> q;
        unordered_set<string> visit;

        q.push(start);
        int step = 0;
        while(!q.empty())
        {
            int levelnum = q.size();
            while (levelnum--)
            {
                auto cur = q.front(); q.pop();
                if(cur == end)
                    return step + 1;
                int len = cur.size();
                for (int i = 0; i < len; i++)
                {
                    string ts = cur;
                    for (int j = 0; j < 26; j++)
                    {
                        if(ts[i] == 'a' + j)
                            continue;
                        ts[i] = 'a' + j;
                        if (!dict.count(ts) || visit.count(ts))
                            continue;
                        q.push(ts);
                        visit.insert(ts);
                    }
                }
            }
            step++;
        }
    }
};
```

# 178 · Graph Valid Tree （树 验证）

判断树的三个条件

1. 联通性

2. 边数 = 节点数 - 1

3. 是否有环

```
class Solution {
public:
    map<int, int> p;
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
    bool validTree(int n, vector<vector<int>> &edges) {
        if (edges.empty())
            return n == 1? true:false;
        for (int i = 0; i< n; i++)
        {
            p[i] = i;
        }

        for (auto n : edges)
        {
            if (find(n[0]) == find(n[1]))
            {
                return false;
            }

            p[find(n[0])] = find(n[1]);
        }

        std::set<int> res;
        for (int i = 0; i< n; i++)
        {
            res.insert(find(i));
        }
        if (res.size() != 1)
            return false;

        return true;
    }
};
```

```
1. 边数 = 节点数 - 1
2. 宽搜所有节点看连通性
class Solution:
    def valid_tree(self, nnum: int, edges: List[List[int]]) -> bool:
        if len(edges) != nnum - 1:
            return False
        d = collections.defaultdict(list)
        for e in edges:
            d[e[0]].append(e[1])
            d[e[1]].append(e[0])
        q = collections.deque([0])
        visit = [0]
        while len(q) != 0:
            cur = q.popleft()

            for n in d[cur]:
                if n not in visit:
                    visit.append(n)
                    q.append(n)
        return len(visit) == nnum
```





# 88 · Lowest Common Ancestor of a Binary Tree(分治LCA最低公共祖先)

```
class Solution {
public:
    TreeNode * midtravse(TreeNode * root, TreeNode * A, TreeNode * B)
    {
        if (!root)
            return nullptr;
        if (root == A || root == B)
            return root;
        
        auto l = midtravse(root->left, A, B);
        auto r = midtravse(root->right, A, B);

        if (l && r)
            return root;
        if (l)
            return l;
        if (r)
            return r;
        return nullptr;
    }
    TreeNode * lowestCommonAncestor(TreeNode * root, TreeNode * A, TreeNode * B) {
        return midtravse(root, A, B);
    }
};
```
## **LeetCode 235. Lowest Common Ancestor of a Binary Search Tree**(二叉搜索树的最近公共祖先)

```
class Solution:
    """
    @param root: root of the tree
    @param p: the node p
    @param q: the node q
    @return: find the LCA of p and q
    """
    def dfs(self, root, p, q):
        if root == None:
            return None
        if root == p or root == q:
            return root
        if root.val >= p.val and root.val >= q.val:
            return self.dfs(root.left, p, q)
        elif root.val <= p.val and root.val <= q.val:
            return self.dfs(root.right, p, q)
        return root
    def lowestCommonAncestor(self, root, p, q):
        return self.dfs(root, p, q)
```



# 87 · Remove Node in Binary Search Tree（找到node以后，用后继替代）

后继 int successor(TreeNode* root)
前驱 int predescessor(TreeNode* root)
找到node以后，用后继替代
```
class Solution {
public:
    int successor(TreeNode* root)
    {
        root = root->right;
        while (root->left)
        {
            root = root->left;
        }
        return root->val;
    }
    int predescessor(TreeNode* root)
    {
        root = root->left;
        while (root->right)
        {
            root = root->right;
        }
        return root->val;
    }

    TreeNode* removeNode(TreeNode *root, int value) {
        if (!root)
            return nullptr;
        
        if (value > root->val)
        {
            root->right = removeNode(root->right, value);
        }
        else if (value < root-> val)
        {
            root->left = removeNode(root->left, value); 
        }
        else
        {
            if (!root->left && !root->right)
            {
                return nullptr;
            }
            else if (root->right)
            {
                root->val = successor(root);
                root->right = removeNode(root->right, root->val);
            }
            else
            {
                root->val = predescessor(root);
                root->left = removeNode(root->left, root->val);
            }
        }
        return root;
    }
};
```



# 4 · Ugly Number II (丑数 * 2，3，5还是丑数，每次挑最小的)
```
class Solution {
public:
    int nthUglyNumber(int n) {
        if(n == 0)
            return 0;
        if(n == 1)
            return 1;
        vector<int> st(100000, 0);
        st[0] = 1;
        int s1 = 0;
        int s2 = 0;
        int s3 = 0;
        for (int i = 1; i < n; i++)
        {
            st[i] = min(st[s1] * 2, min(st[s2] * 3, st[s3] * 5));
            if (st[i] == st[s1] * 2)
                s1++;
            if (st[i] == st[s2] * 3)
                s2++;
            if (st[i] == st[s3] * 5)
                s3++;
        }
        return st[n - 1];
    }
};
```



# 134 · LRU Cache（std::list::splice()）

_lru.splice()

将后面的元素移到前面，

```
#include <list>
class LRUCache {
public:
    /*
    * @param capacity: An integer
    */LRUCache(int capacity): _capacity(capacity) {
        
    }

    /*
     * @param key: An integer
     * @return: An integer
     */
    int get(int key) {
        if (_table.count(key))
        {
            _lru.splice(_lru.begin(), _lru, _table[key]);
            return _table[key]->second;
        }
        return -1;
    }

    /*
     * @param key: An integer
     * @param value: An integer
     * @return: nothing
     */
    void set(int key, int value) {
        if (_table.count(key))
        {
            _lru.splice(_lru.begin(), _lru, _table[key]);
            _table[key]->second = value;
            return;
        }

        _lru.push_front({key, value});
        _table[key] = _lru.begin();
        if (_lru.size() > _capacity)
        {
            _table.erase(_lru.back().first);
            _lru.pop_back();
        }
    }

    int _capacity;
    list<pair<int, int>> _lru;
    unordered_map<int, list<pair<int, int>>::iterator> _table;
};
```

# 150 · Best Time to Buy and Sell Stock II





# 363 · Trapping Rain Water 接雨水
