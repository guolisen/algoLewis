

[TOC]



### 四、MSRA 面试 DP 考察特点

1. **重模型迁移**：不会直接考原题，而是在经典模型上做变形（如 LIS 结合二维、背包结合业务场景）；
2. **重优化思路**：不仅要求写出基础 DP，还会追问「如何优化空间 / 时间」（如滚动数组、二分、单调栈）；
3. **重状态设计**：常让候选人自己定义状态，而非直接给出（如「设计 DP 状态表示某字符串的子问题」）；
4. **重边界与特例**：考察对 DP 初始化、边界条件的考虑（如空数组、全 0 矩阵、环形问题）。

### 备考建议

1. 先掌握「基础经典 DP」的状态定义和转移逻辑，做到脱口而出；
2. 针对「进阶 DP」重点练习优化思路（如 LIS 的二分优化、背包的空间压缩）；
3. 做完题后复盘「状态为什么这么定义」「换一种状态定义是否可行」；
4. 结合 MSRA 的研究方向（NLP、CV、机器学习），关注文本 / 矩阵 / 序列相关的 DP 题（如编辑距离、最大矩形、LCS）。





### 一、基础经典 DP（必问，考察 DP 入门理解）

### 515 · Paint House

设定状态: `f[i][j]` 表示第i所房屋涂色为j时, 前i所房屋的最小花费

`f[i - 1][]`的时候不能和 j 涂一样的颜色, 所以在前一个的另外两个颜色里面选一个最小的加上当前`cost[i][j]`

```
class Solution {
public:
    int minCost(vector<vector<int>> &costs) {
        if (costs.empty())
            return 0;
        int m = costs.size();
        vector<vector<int>> f(m, vector<int>(3, 0));
        f[0][0] = costs[0][0];
        f[0][1] = costs[0][1];
        f[0][2] = costs[0][2];
        for (int i = 1; i < m; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                f[i][j] = min(f[i - 1][(j + 1) % 3], f[i - 1][(j + 2) % 3]) + costs[i][j];
            }
        }
        int res = INT_MAX;
        for (int i = 0; i < 3; i++)
        {
            res = min(res, f[m - 1][i]);
        }

        return res;
    }
};
```



#### 1. 爬楼梯（斐波那契型 DP）

- LeetCode：70. 爬楼梯 Climbing Stairs
- 考察要点：状态定义、边界条件、空间优化
- 核心思路：
    - 状态：`dp[i]` 表示爬到第`i`阶的方法数；
    - 转移：`dp[i] = dp[i-1] + dp[i-2]`（每次走 1/2 阶）；
    - 优化：无需数组，用两个变量滚动存储`dp[i-1]`和`dp[i-2]`，空间 O (1)。
    
    ```
        def climbStairs(self, n: int) -> int:
            if n <= 1:
                return 1
            if n == 2:
                return 2
            dp = [0] * (n + 1)
            dp[0] = 1
            dp[1] = 1
            dp[2] = 2
    
            for i in range(3, n + 1):
                dp[i] = dp[i - 1] + dp[i - 2]
            return dp[n]
    ```
    
    

#### 2. 最大子数组和（线性 DP）

- LeetCode：53. 最大子数组和

- 考察要点：状态压缩、贪心与 DP 结合

- 核心思路：

    - 状态：`dp[i]` 表示**以`i`结尾的最大子数组和**；
    - 转移：`dp[i] = max(nums[i], dp[i-1] + nums[i])`（选或不选前一个子数组）；
    - 优化：用单个变量替代数组，空间 O (1)（Kadane 算法）。

    ```
        def max_sub_array(self, nums: List[int]) -> int:
            dp = collections.defaultdict(int)
            dp[0] = 0
    
            res = -math.inf
            for i in range(1, len(nums) + 1):
                dp[i] = max(nums[i - 1], dp[i - 1] + nums[i - 1])
                res = max(res, dp[i])
            return res
    ```

    ```
        def maxSubArray(self, nums):
            #prefix_sum记录前i个数的和，max_Sum记录全局最大值，min_Sum记录前i个数中0-k的最小值
            min_sum, max_sum = 0, -sys.maxsize
            prefix_sum = 0
            
            for num in nums:
                prefix_sum += num
                max_sum = max(max_sum, prefix_sum - min_sum)
                min_sum = min(min_sum, prefix_sum)
                
            return max_sum
    
    ```
    
    

#### 3. 打家劫舍（间隔型 DP）

- LeetCode：198. 打家劫舍（基础）、213. 打家劫舍 II（环形）

```
You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.

 

Example 1:

Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
Example 2:

Input: nums = [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
Total amount you can rob = 2 + 9 + 1 = 12.
```

- 考察要点：状态分类、环形问题拆解

- 核心思路：

    - 基础版：`dp[i] = max(dp[i-1], dp[i-2] + nums[i])`（**偷或不偷第`i`家**）；
    - 环形版：拆分为「不偷第一家」和「不偷最后一家」两个线性问题，取最大值。

    ```
        def house_robber(self, a: List[int]) -> int:
            if len(a) == 0:
                return 0
            dp = collections.defaultdict(int)
            dp[0] = 0
            dp[1] = a[0]
    
            for i in range(2, len(a) + 1):
                dp[i] = max(dp[i - 1], dp[i - 2] + a[i - 1])
                
                #fn = max(f1, f0 + a)
                #f0 = f1
                #f1 = fn
                
    
            return dp[len(a)]
    ```
    ```
    class Solution:
        def rob(self, a: List[int]) -> int:
            if len(a) == 0:
                return 0
    
            f0, f1 = 0, a[0]
            for i in range(2, len(a) + 1):
                f0, f1 = f1, max(f1, f0 + a[i - 1])
                
            return f1
    ```

    

    就是考虑最后一个和第一个，不能同时选，只能考虑`[0, n - 1]` `[1, n]`

    ```
    class Solution:
        def rob(self, nums: List[int]) -> int:
            def robRange(start: int, end: int) -> int:
                first = nums[start]
                second = max(nums[start], nums[start + 1])
                for i in range(start + 2, end + 1):
                    first, second = second, max(first + nums[i], second)
                return second
            
            length = len(nums)
            if length == 1:
                return nums[0]
            elif length == 2:
                return max(nums[0], nums[1])
            else:
                return max(robRange(0, length - 2), robRange(1, length - 1))
    ```

    

    **第一步：先拆解第一段代码的执行逻辑（分步赋值）**

    第一段代码用 `fn` 作为临时变量，明确拆分了 “计算新值” 和 “更新旧值” 的步骤，我们先梳理每一轮循环的核心：

    ```python
    f0 = f1 = 0  # 初始状态：f0=0（偷第i-2间的最大收益），f1=0（偷第i-1间的最大收益）
    for x in nums:
        # 步骤1：计算当前轮的最大收益fn（偷第i间：f0+x；不偷第i间：f1）
        fn = max(f1, f0 + x)
        # 步骤2：更新f0为上一轮的f1（f0向后移一位，变成新的i-2）
        f0 = f1
        # 步骤3：更新f1为当前轮的fn（f1向后移一位，变成新的i-1）
        f1 = fn
    ```

    关键：`f0` 和 `f1` 的更新**依赖上一轮的旧值**，且步骤 2、3 是 “顺序执行”，必须先更 `f0` 再更 `f1`。

    **第二步：分析第二段代码的 “同时赋值” 逻辑**

    第二段代码利用 Python 的**元组解包（并行赋值）** 特性，把 “计算 + 更新” 合并成一行，核心规则是：

    > 赋值号右侧的表达式会**先全部计算完成**（使用赋值前的旧值），再一次性赋值给左侧变量。

    拆解这行核心代码：

    ```python
    f0, f1 = f1, max(f1, f0 + x)
    相当于
    f0, f1 = f1, fn
    ```

### 二、二维 / 矩阵 DP（高频，考察状态维度设计）

#### 1. 不同路径（网格 DP）

- LeetCode：62. 不同路径（基础）、63. 不同路径 II（有障碍）
- 考察要点：二维状态定义、障碍边界处理
- 核心思路：
    - 状态：`dp[i][j]` 表示从 (0,0) 到 (i,j) 的路径数；
    - 转移：无障碍时`dp[i][j] = dp[i-1][j] + dp[i][j-1]`；有障碍时`dp[i][j] = 0`；
    - 优化：用一维数组滚动更新（`dp[j] = dp[j] + dp[j-1]`），空间 O (n)。
    
    ```
        def unique_paths(self, m: int, n: int) -> int:
            dp = [[1] * (n + 1) for _ in range(m + 1)]
    
            for i in range(1, m + 1):
                for j in range(1, n + 1):
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
            return dp[m - 1][n - 1]
    ```
    
    ```
    def unique_paths_with_obstacles(self, obstacle_grid: List[List[int]]) -> int:
            m = len(obstacle_grid)
            n = len(obstacle_grid[0])
    
            dp = [[1] * (n + 1) for _ in range(m + 1)]
            for i in range(0, m):
                for j in range(0, n):
                    if i == 0 and j > 0:
                        dp[0][j] = dp[0][j - 1]
                    if j == 0 and i > 0:
                        dp[i][0] = dp[i - 1][0]
                    if obstacle_grid[i][j] == 1:
                        dp[i][j] = 0
    
            for i in range(1, m):
                for j in range(1, n):
                    if obstacle_grid[i][j] == 1:
                        continue
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
            return dp[m - 1][n - 1]
    
    ```
    
    

#### 2. 最小路径和（网格 DP）

- LeetCode：64. 最小路径和
- 考察要点：代价型 DP、状态转移的贪心倾向
- 核心思路：
    - 状态：`dp[i][j]` 表示从 (0,0) 到 (i,j) 的最小路径和；
    - 转移：`dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]`；
    - 优化：直接在原数组上修改，无需额外空间。
    
    ```
        def min_path_sum(self, grid: List[List[int]]) -> int:
            m = len(grid)
            n = len(grid[0])
            dp = [[0] * n for _ in range(m)]
            dp[0][0] = grid[0][0]
            for i in range(1, m):
                dp[i][0] += dp[i - 1][0] + grid[i][0]
            for j in range(1, n):
                dp[0][j] += dp[0][j - 1] + grid[0][j]
    
            for i in range(1, m):
                for j in range(1, n):
                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]
    
            return dp[m - 1][n - 1]
    ```
    
    

#### 3. 最长公共子序列（LCS）77 · Longest Common Subsequence

- LeetCode：1143. 最长公共子序列
- 考察要点：经典二维 DP、子序列与子串的区别
- 核心思路：
    - 状态：`dp[i][j]` 表示 text1 前`i`个字符和 text2 前`j`个字符的 LCS 长度；
    - 转移：
        - 若`text1[i-1] == text2[j-1]`，则`dp[i][j] = dp[i-1][j-1] + 1`；
        - 否则`dp[i][j] = max(dp[i-1][j], dp[i][j-1])`；
    - 扩展：常追问「如何输出具体的 LCS」（回溯 DP 表）。
    - f(i, j) 是1-i和i- j两个子序列的LCS
    
        f(i - 1, j) 和 f(i, j - 1)都包含 f(i - 1, j - 1)这种情况，但是取max的时候实际还是取的他们三者的最大值，是否重复不重要。
    - f [ i \]\[ j ] 为第一个序列前i个字符中，和第二个序列前j个字符中的公共序列。所有在第一个序列的前i个字母中出现的，且在第二个序列中的前j个字母中出现的子序列
    
        转移方程是看最后一个字符是否选取，a[i],b[j], 都选‘f[i - 1\][j - 1] + 1’, 都不选 f[i - 1\][j - 1]

```
要理解「尾部字符不同时 dp[i][j] = max(dp[i-1][j], dp[i][j-1])」的核心逻辑，关键是抓住 LCS（最长公共子序列）的 “不连续” 特性 和 动态规划 “子问题最优” 的本质—— 我们需要从 “缩小问题规模” 的角度，推导「text1 [0:i] 和 text2 [0:j] 的 LCS」与更小的子问题之间的关系。

第一步：先明确 dp[i][j] 的定义（基础前提）
首先重申状态定义（这是所有推导的核心）：dp[i][j] 表示 text1 的前 i 个字符（text1 [0:i]） 和 text2 的前 j 个字符（text2 [0:j]） 的最长公共子序列的长度。（注：text1 [i-1] 是 text1 前 i 个字符的最后一个字符，text2 [j-1] 是 text2 前 j 个字符的最后一个字符 —— 这是下标偏移的常规设计，避免处理 i=0/j=0 的边界时越界。）

第二步：尾部字符不同时，LCS 的两种 “可能来源”
当 text1 [i-1] ≠ text2 [j-1] 时，说明「这两个尾部字符无法同时加入 LCS」，此时 dp[i][j] 只能来自两个更小的子问题的最优解：
子问题 1：放弃 text1 的最后一个字符 → 依赖 dp[i-1][j]
既然 text1 [i-1] 和 text2 [j-1] 不相等，那么「text1 [0:i] 和 text2 [0:j] 的 LCS」不可能包含 text1 [i-1]（因为即使包含，也找不到 text2 中对应的字符匹配）。此时问题退化为：求「text1 的前 i-1 个字符」和「text2 的前 j 个字符」的 LCS，即 dp[i-1][j]。
子问题 2：放弃 text2 的最后一个字符 → 依赖 dp[i][j-1]
同理，「text1 [0:i] 和 text2 [0:j] 的 LCS」也不可能包含 text2 [j-1]，问题退化为：求「text1 的前 i 个字符」和「text2 的前 j-1 个字符」的 LCS，即 dp[i][j-1]。
为什么取两者的最大值？
LCS 的核心是 “最长”，因此我们需要从这两个子问题的最优解中，选长度更大的那个 —— 这就是 dp[i][j] = max(dp[i-1][j], dp[i][j-1]) 的本质。

第三步：用示例直观验证（避免抽象）
举个具体例子：
text1 = "abcde"（前 5 个字符，i=5），text2 = "acef"（前 4 个字符，j=4）；
尾部字符：text1 [4] = 'e'，text2 [3] = 'f' → 不相等；
子问题 1：dp [4][4]（text1 前 4 个字符 "abcd" + text2 前 4 个字符 "acef" 的 LCS 长度）= 2（"ace"？不，"abcd" 和 "acef" 的 LCS 是 "ac"，长度 2）；
子问题 2：dp [5][3]（text1 前 5 个字符 "abcde" + text2 前 3 个字符 "ace" 的 LCS 长度）= 3（"ace"，长度 3）；
因此 dp [5][4] = max (2, 3) = 3（符合实际："abcde" 和 "acef" 的 LCS 是 "ace"，长度 3）。
再换一个例子：
text1 = "abc"（i=3），text2 = "adc"（j=3）；
尾部字符：text1 [2] = 'c'，text2 [2] = 'c' → 相等，dp [3][3] = dp [2][2]+1；
dp [2][2] 是 "ab" 和 "ad" 的 LCS 长度 = 1 → dp [3][3] = 2（实际 LCS 是 "ac" 或 "dc"，长度 2）；
若尾部字符改为 text1 [2]='b'，text2 [2]='d' → 不相等：
dp [2][3]（"ab"+"adc" 的 LCS 长度 = 1），dp [3][2]（"abc"+"ad" 的 LCS 长度 = 1）→ dp [3][3] = 1（实际 LCS 是 "a"，长度 1）。

第四步：常见误区澄清
误区 1：为什么不是 dp[i][j] = dp[i-1][j-1]？
dp[i-1][j-1] 是「text1 前 i-1 个字符 + text2 前 j-1 个字符」的 LCS 长度，它一定 ≤ max (dp [i-1][j], dp [i][j-1])—— 因为：
dp [i-1][j] 包含了 dp [i-1][j-1] 的所有可能（多考虑了 text2 的第 j 个字符）；
dp [i][j-1] 也包含了 dp [i-1][j-1] 的所有可能（多考虑了 text1 的第 i 个字符）。
比如 text1="abcde"、text2="acef"，dp [4][3]（i-1=4,j-1=3）= 2，而 max (dp [4][4], dp [5][3])=3，显然取 dp [i-1][j-1] 会得到错误结果。
误区 2：为什么不用考虑「同时放弃两个尾部字符」？
「同时放弃 text1 [i-1] 和 text2 [j-1]」对应的是 dp[i-1][j-1]，但它的最优解已经被包含在 dp[i-1][j] 或 dp[i][j-1] 中了 —— 因为：
dp [i-1][j] ≥ dp [i-1][j-1]（多了 text2 的第 j 个字符，LCS 长度不会变短）；
dp [i][j-1] ≥ dp [i-1][j-1]（多了 text1 的第 i 个字符，LCS 长度不会变短）；
因此 max (dp [i-1][j], dp [i][j-1]) 已经覆盖了 dp[i-1][j-1] 的情况，无需额外考虑。
核心总结
当 text1 [i-1] ≠ text2 [j-1] 时：
两个尾部字符无法同时加入 LCS，因此只能 “放弃其中一个尾部字符”；
放弃 text1 尾部 → 子问题 dp [i-1][j]；放弃 text2 尾部 → 子问题 dp [i][j-1]；
LCS 追求 “最长”，因此取两个子问题的最大值作为 dp[i][j]；
这一逻辑完全符合动态规划 “分解为子问题 + 取最优解” 的核心思想，且覆盖了所有可能的情况。
简单记：尾部不同，二选一（放弃 text1 最后一个 或 放弃 text2 最后一个），选最长的那个。
```

```
    def longest_common_subsequence(self, a: str, b: str) -> int:
        if len(a) == 0 or len(b) == 0:
            return 0
        m = len(a)
        n = len(b)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
                if a[i - 1] == b[j - 1]:
                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + 1)
        return dp[m][n]
```

回溯 如何输出具体的 LCS

```
def longestCommonSubsequence(text1: str, text2: str) -> str:
    m, n = len(text1), len(text2)
    # 1. 构建 DP 表（初始化 (m+1)x(n+1) 的二维数组）
    dp = [[0]*(n+1) for _ in range(m+1)]
    
    # 填充 DP 表（常规 LCS 长度计算逻辑）
    for i in range(1, m+1):
        for j in range(1, n+1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    # 2. 回溯 DP 表，还原 LCS
    i, j = m, n
    lcs = []
    while i > 0 and j > 0:
        if text1[i-1] == text2[j-1]:
            # 字符匹配，加入 LCS，同时回溯左上角
            lcs.append(text1[i-1])
            i -= 1
            j -= 1
        else:
            # 字符不匹配，往 DP 值更大的方向走
            if dp[i-1][j] > dp[i][j-1]:
                i -= 1
            else:
                j -= 1
    
    # 回溯得到的是逆序，反转后得到最终 LCS
    return ''.join(reversed(lcs))

```





### 三、进阶 DP（区分度高，考察优化能力）

#### 1. 最长递增子序列（LIS）76 · Longest Increasing Subsequence

- LeetCode：300. 最长递增子序列
- 考察要点：O (n²) 基础解法、O (n log n) 优化、贪心 + 二分
- 核心思路：
    - 基础版：`dp[i] = max(dp[j]+1) (j < i 且 nums[j] < nums[i])`；
    - 优化版：维护一个「最小末尾数组」，遍历 nums 时用二分找替换位置，数组长度即为 LIS 长度；
    - 扩展：常结合二维问题（如 354. 俄罗斯套娃信封问题）。
    
    最长上升子序列模型
    
    ```
    for(int i=1;i<=n;i++)
    {
        f[i]=1;
        for(int j=1;j<i;j++)
            if(a[i]>a[j]) f[i]=max(f[j]+1,f[i]);
    }
    ```
    
    最长下降子序列模型
    
    ```
    for(int i=1;i<=n;i++)
    {
        f[i]=1;
        for(int j=1;j<i;j++)
            if(a[i]<a[j]) f[i]=max(f[j]+1,f[i]);
    }
    ```
    
    ```
    class Solution:
        def longest_increasing_subsequence(self, nums: List[int]) -> int:
            m = len(nums)
            if m == 0:
                return 0
            dp = [1 for _ in range(m)]
    
            res = 1
            for i in range(1, m):
                for j in range(i):
                    if nums[i] > nums[j]:
                        dp[i] = max(dp[i], dp[j] + 1)
                        res = max(res, dp[i])
            return res
    ```
    
    俄罗斯套娃
    
    ```
        def maxEnvelopes(self, envelopes: List[List[int]]) -> int:
    		if not envelopes:
                return 0
            
            n = len(envelopes)
            envelopes.sort(key=lambda x: (x[0], -x[1]))
    
            f = [1] * n
            for i in range(n):
                for j in range(i):
                    if envelopes[j][1] < envelopes[i][1]:
                        f[i] = max(f[i], f[j] + 1)
            
            return max(f)
    ```
    
    

#### 2. 编辑距离

- LeetCode：72. 编辑距离
- 考察要点：多操作型 DP、状态覆盖所有可能
- 核心思路：
    - 状态：`dp[i][j]` 表示 word1 前`i`个字符转为 word2 前`j`个字符的最小操作数；
    - 转移：
        - 若`word1[i-1] == word2[j-1]`，则`dp[i][j] = dp[i-1][j-1]`；
        - 否则`dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1`（删、插、改）；
    - 考察意义：MSRA 关注自然语言处理方向，编辑距离是经典文本处理 DP。
    
    给定两个字符src, dest，求用最少步数将src转换位dest，步骤只能用3中insert, delete, replace。
    
    
    
    - 动态规划：`dp[i][j]` 表示 word1 [0..i-1] 到 word2 [0..j-1] 的最小步数。若字符相等，`dp[i][j] = dp[i-1][j-1]`；否则取 `min(插入、删除、替换) + 1`。
    
        含有i-1，j-1这种dp一般遍历都从1开始，dp长度len + 1
    
        ```
        `f[i][j]`为word1前i个字符到word2的前j个字符的转化的最小步。 由于要计算i - 1 j - 1，为了方便dp都从1开始算，原始的word前面加一个" "
        含有i-1，j-1这种dp一般遍历都从1开始，dp长度len + 1
        
           > - 在word1中插入一个字符，相当于`dp[i][j - 1] + 1`，消消乐
           > - 在word1中删除一个字符，相当于`dp[i - 1][j] + 1`，消消乐
           > - 在word1和word2修改最后一个字符，相当于`dp[i - 1][j - 1] + 1`，消消乐
           > - word1最后一个字符和word2最后 一个字符相等的话 `dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])`
        这四重情况在一起求一个min   
        dp[i][j] = min(dp[i][j - 1] + 1, dp[i - 1][j] + 1, dp[i - 1][j - 1] + 1, dp[i - 1][j - 1])
        
            def min_distance(self, word1: str, word2: str) -> int:
                m = len(word1)
                n = len(word2)
                if m == 0:
                    return n
                if n == 0:
                    return m
                nword1 = " " + word1
                nword2 = " " + word2
        
                dp = [[0] * (n + 1) for _ in range(m + 1)]
                for i in range(m + 1):
                    dp[i][0] = i
                for j in range(n + 1):
                    dp[0][j] = j
        
                for i in range(1, m + 1):
                    for j in range(1, n + 1):
                        dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1
                        if nword1[i] == nword2[j]:
                            dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
                        else:
                            dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + 1)
                return dp[m][n]
           
        ```
    
        

#### 3. 零钱兑换

- LeetCode：322. 零钱兑换（最少硬币数）、518. 零钱兑换 II（组合数）
- 考察要点：完全背包模型、状态定义的顺序（排列 / 组合）
- 核心思路：
    - 322 题（最少硬币）：
        - 状态：`dp[i]` 表示凑成金额`i`的最少硬币数；
        - 转移：`dp[i] = min(dp[i - coin] + 1) (coin ≤ i)`；
    - 518 题（组合数）：
        - 状态：`dp[i]` 表示凑成金额`i`的组合数；
        - 转移：`dp[i] += dp[i - coin]`（先遍历硬币，再遍历金额，避免排列重复）；
    - 扩展：常追问「是否存在无限硬币的情况」「如何输出具体组合」。
    
    ```
        def coin_change(self, coins: List[int], amount: int) -> int:
            m = len(coins)
            dp = [math.inf for _ in range(amount + 1)]
            dp[0] = 0
            for i in range(1, amount + 1):
                for c in coins:
                    if c > i:
                        continue
                    dp[i] = min(dp[i - c] + 1, dp[i])
            if dp[amount] == math.inf:
                return -1;
            return dp[amount]
    ```
    
    

#### 4. 分割等和子集（0-1 背包）

- LeetCode：416. 分割等和子集
- 考察要点：0-1 背包的转化、空间优化
- 核心思路：
    - 问题转化：判断是否存在子集和为总和的一半；
    - 状态：`dp[j]` 表示能否凑出金额`j`；
    - 转移：`dp[j] = dp[j] || dp[j - nums[i]]`（逆序遍历金额，避免重复选）；
    - 扩展：常延伸到「目标和」（494. 目标和），考察 0-1 背包的正负转化。
    
    

#### 5. 最大矩形

- LeetCode：85. 最大矩形   [84. Largest Rectangle in Histogram](https://leetcode.cn/problems/largest-rectangle-in-histogram/)
- 考察要点：二维 DP + 单调栈、状态降维
- 核心思路：
    - 预处理：对每一行，计算`height[j]`表示以当前行为底，列`j`的连续 1 的高度；
    - 转化：对每一行的`height`数组，用「84. 柱状图中最大的矩形」的单调栈方法求最大矩形；
    - 考察意义：结合 DP 和单调栈的综合应用，MSRA 关注图形 / 矩阵处理方向时高频考察。

暴力解

```
class Solution {
public:
    int maximalRectangle(vector<vector<char>>& matrix) {
        int m = matrix.size();
        if (m == 0) {
            return 0;
        }
        int n = matrix[0].size();
        vector<vector<int>> left(m, vector<int>(n, 0));

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == '1') {
                    left[i][j] = (j == 0 ? 0: left[i][j - 1]) + 1;
                }
            }
        }

        int ret = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == '0') {
                    continue;
                }
                int width = left[i][j];
                int area = width;
                for (int k = i - 1; k >= 0; k--) {
                    width = min(width, left[k][j]);
                    area = max(area, (i - k + 1) * width);
                }
                ret = max(ret, area);
            }
        }
        return ret;
    }
};

```







1. **解码方法**（LeetCode 91. Num Decodings）
    - **英文名称**：Decode Ways
    - **核心思路**：属于字符串类 DP，重点考察边界条件处理。定义`dp[i]`为字符串前`i`个字符的解码方法数。转移逻辑分两种情况，一是单个字符解码（若当前字符非 0，`dp[i] += dp[i-1]`）；二是两个字符解码（若前两个字符组成 10 - 26 的数字，`dp[i] += dp[i-2]`）。边界上`dp[0] = 1`（空字符串作为递推基础），`dp[1]`取决于首个字符是否为 0。
2. **乘积最大子数组**（LeetCode 152. Maximum Product Subarray）
    - **英文名称**：Maximum Product Subarray
    - **核心思路**：是最大子数组和的进阶题，因负数相乘会改变符号，需额外维护最小值。定义`max_dp[i]`为以第`i`个元素结尾的最大乘积，`min_dp[i]`为以第`i`个元素结尾的最小乘积。转移方程为`max_dp[i] = max(nums[i], max(max_dp[i-1]*nums[i], min_dp[i-1]*nums[i]))`，`min_dp[i]`则取对应最小值，最终答案为`max_dp`数组的最大值。
3. **环形子数组的最大和**（LeetCode 918. Maximum Sum Circular Subarray）
    - **英文名称**：Maximum Sum Circular Subarray
    - **核心思路**：突破线性数组限制，考察环形场景的 DP 转化。解题关键分两种情况，一是最大子数组在数组内部（同 53 题最大子数组和）；二是最大子数组跨首尾（转化为求数组最小子数组和，用数组总和减去该值）。最终答案取两种情况的最大值，需注意全负数时的边界修正。
4. **三角形最小路径和**（LeetCode 120. Triangle）
    - **英文名称**：Triangle
    - **核心思路**：典型的二维空间 DP，可优化为一维。定义`dp[i][j]`为到达第`i`行第`j`列的最小路径和。转移方程为`dp[i][j] = min(dp[i-1][j-1], dp[i-1][j]) + triangle[i][j]`，其中首尾元素仅能从上层对应位置转移。优化后可使用一维数组滚动更新，空间复杂度从 O (n²) 降至 O (n)。
5. **地下城游戏**（LeetCode 174. Dungeon Game）
    - **英文名称**：Dungeon Game
    - **核心思路**：逆向 DP 的经典案例。若正向推导难以确定边界，定义`dp[i][j]`为从`(i,j)`到达右下角的最低初始生命值。转移方程为`dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1)`，确保生命值始终为正。边界上右下角单元格的`dp`值需根据其数值是否为负做修正。
6. **打家劫舍 III**（LeetCode 337. House Robber III）
    - **英文名称**：House Robber III
    - **核心思路**：将 DP 与树形结构结合，考察递归与状态划分。每个节点有两种状态，偷或不偷。定义`dp[node][0]`为不偷当前节点的最大收益，`dp[node][1]`为偷当前节点的最大收益。转移时，`dp[node][0] = max(dp[left][0], dp[left][1]) + max(dp[right][0], dp[right][1])`，`dp[node][1] = node.val + dp[left][0] + dp[right][0]`，通过后序遍历递归计算。
7. **最长有效括号**（LeetCode 32. Longest Valid Parentheses）
    - **英文名称**：Longest Valid Parentheses
    - **核心思路**：字符串括号类 DP 难题。定义`dp[i]`为以第`i`个字符结尾的最长有效括号长度。若`s[i]`为右括号，分两种情况，若`s[i-1]`为左括号，`dp[i] = dp[i-2] + 2`；若`s[i-1]`为右括号且`s[i - dp[i-1] - 1]`为左括号，则`dp[i] = dp[i-1] + dp[i - dp[i-1] - 2] + 2`。边界上`dp[0] = 0`，通过遍历字符串更新状态。
8. **第 N 个泰波那契数**（LeetCode 1137. N-th Tribonacci Number）
    - **英文名称**：N-th Tribonacci Number
    - **核心思路**：基础递推型 DP，考察空间优化。泰波那契数列定义为`T(0)=0，T(1)=1，T(2)=1，T(n)=T(n-1)+T(n-2)+T(n-3)`。无需额外数组，用三个变量迭代存储前三项值，每次更新变量，将空间复杂度从 O (n) 降至 O (1)，适合大数据量的场景。
9. **矩阵中的最长递增路径**（LeetCode 329. Longest Increasing Path in a Matrix）
    - **英文名称**：Longest Increasing Path in a Matrix
    - **核心思路**：二维矩阵与记忆化 DP 结合。定义`dp[i][j]`为以`(i,j)`为起点的最长递增路径长度。对每个单元格，递归探索上下左右四个方向，若相邻单元格值更大，则`dp[i][j] = max(dp[i][j], dfs(相邻单元格) + 1)`。用记忆化存储避免重复计算，时间复杂度优化为 O (mn)（m、n 为矩阵行列数）。
10. **删除一次得到子数组最大和**（LeetCode 1186. Maximum Subarray Sum with One Deletion）
    - **英文名称**：Maximum Subarray Sum with One Deletion
    - **核心思路**：最大子数组和的扩展题，增加删除一次的限制。定义`keep[i]`为不删除元素时以`i`结尾的最大子数组和，`delete[i]`为删除一次后以`i`结尾的最大子数组和。转移方程为`keep[i] = max(keep[i-1] + nums[i], nums[i])`，`delete[i] = max(keep[i-1], delete[i-1] + nums[i])`，最终答案取两个数组的最大值。