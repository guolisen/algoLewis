[TOC]



### 树与二叉树相关（DFS 基础场景）

#### 1. 二叉树的最大深度 → **LeetCode 104. Maximum Depth of Binary Tree**
#### 2. 二叉树的最小深度 → **LeetCode 111. Minimum Depth of Binary Tree**
#### 3. 路径总和 → **LeetCode 112. Path Sum**
#### 4. 路径总和 II → **LeetCode 113. Path Sum II**
#### 5. 二叉树中的最大路径和 → **LeetCode 124. Binary Tree Maximum Path Sum**
#### 6. 二叉树的所有路径 → **LeetCode 257. Binary Tree Paths**
#### 7. 左叶子之和 → **LeetCode 404. Sum of Left Leaves**
#### 8. 最长同值路径 → **LeetCode 687. Longest Univalue Path**
#### 9. 找树左下角的值 → **LeetCode 513. Find Bottom Left Tree Value**
#### 10. 验证二叉搜索树 → **LeetCode 98. Validate Binary Search Tree**（中序 DFS）

### 图相关（遍历与连通性）

#### 1. 岛屿数量 → **LeetCode 200. Number of Islands**（网格 DFS，经典入门）

DFS:

```
class Solution:
    """
    @param grid: a boolean 2D matrix
    @return: an integer
    """
    def isInBound(self, x, y, m, n):
        if x >= m or y >= n or x < 0 or y < 0:
            return False
        return True
    
    def dfs(self, grid, x, y, visit):
        m = len(grid)
        n = len(grid[0])
        if not self.isInBound(x, y, m, n):
            return
        dx = [0, 0, 1, -1]
        dy = [1, -1, 0, 0]
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            if not self.isInBound(nx, ny, m, n) or grid[nx][ny] != 1 or visit[nx][ny] == True:
                continue
            visit[nx][ny] = True
            self.dfs(grid, nx, ny, visit)

    def num_islands(self, grid: List[List[bool]]) -> int:
        if grid ==None:
            return 0
        if len(grid) == 0:
            return 0
        m = len(grid)
        n = len(grid[0])
        res = 0
        visit = [[False] * n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1 and visit[i][j] == False:
                    res += 1
                    self.dfs(grid, i, j, visit)
        return res
```

并查集

```
class Solution {
public:
    /**
     * @param grid: a boolean 2D matrix
     * @return: an integer
     */
    int find(unordered_map<int, int>& p, int x)
    {
        if (p[x] != x) p[x] = find(p, p[x]);
        return p[x];
    }
    int idx(int x, int y, int m)
    {
        return x * m + y;
    }
    bool isInBound(int x, int y, int m, int n)
    {
        if (x >= m || y >= n || x < 0 || y < 0)
            return false;
        return true;
    }
    int numIslands(vector<vector<bool>> &grid) {
        if (grid.size() == 0)
            return 0;
        
        int m = grid.size();
        int n = grid[0].size();

        unordered_map<int, int> p;
        for(int i = 0; i < m; i++)
            for(int j = 0; j < n; j++)
                p[idx(i, j, m)] = idx(i, j, m);

        int dx[4] = {0,0,-1,1};
        int dy[4] = {-1,1,0,0};
        for(int i = 0; i < m; i++)
        {
            for(int j = 0; j < n; j++)
            {
                if (grid[i][j] != 1)
                    continue;
                for (int d = 0; d < 4; d++)
                {
                    int nx = i + dx[d];
                    int ny = j + dy[d];
                    if (!isInBound(nx, ny, m, n) || grid[nx][ny] != 1 ||
                        p[find(p, idx(i, j, m))] == find(p, idx(nx, ny, m)))
                        continue;

                    p[find(p, idx(i, j, m))] = find(p, idx(nx, ny, m));
                }
            }
        }
        
        unordered_set<int> s;
        for(int i = 0; i < m; i++)
        {
            for(int j = 0; j < n; j++)
            {
                if (grid[i][j] == 1)
                {
                    s.insert(find(p, idx(i, j, m)));
                }
            }
        }
        return s.size();
    }
};
```



#### 2. 被围绕的区域 → **LeetCode 130. Surrounded Regions**（边界 DFS + 标记）

使用 BFS 的方法
先把从边界开始的 O 都标记为 W，这样非 W 的地方就全都需要标记为 X

```
class Solution:
    # @param {list[list[str]]} board a 2D board containing 'X' and 'O'
    # @return nothing 
    def surroundedRegions(self, board):
        # Write your code here
        if not any(board):
            return

        n, m = len(board), len(board[0])
        q = [ij for k in range(max(n,m)) for ij in ((0, k), (n-1, k), (k, 0), (k, m-1))]
        while q:
            i, j = q.pop()
            if 0 <= i < n and 0 <= j < m and board[i][j] == 'O':
                board[i][j] = 'W'
                q += (i, j-1), (i, j+1), (i-1, j), (i+1, j)

        board[:] = [['XO'[c == 'W'] for c in row] for row in board]
```



#### 3. 太平洋大西洋水流问题 → **LeetCode 417. Pacific Atlantic Water Flow**（双向 DFS）

```
class Solution:
    """
    @param matrix: the given matrix
    @return: The list of grid coordinates
             we will sort your return value in output
    """
    def isReach(self, x, y, m, n, bp, ba):
        if x == 0 or y == 0:
            bp = True
        if x == m - 1 or y == n - 1:
            ba = True
        return bp, ba
    def isInBound(self, x, y, m, n):
        if x >= m or y >= n or x < 0 or y < 0:
            return False
        return True

    def bfs(self, matrix, x, y, visit):
        m = len(matrix)
        n = len(matrix[0])
        dx = [0,0,-1,1]
        dy = [1,-1,0,0]
        bp, ba = False, False
        visit[x][y] = True
        q = collections.deque([(x, y)])
        while len(q) != 0:
            cur = q.popleft()
            bp, ba = self.isReach(cur[0], cur[1], m, n, bp, ba)
            if bp and ba:
                return True
            for i in range(4):
                nx = cur[0] + dx[i]
                ny = cur[1] + dy[i]

                if not self.isInBound(nx, ny, m, n) or visit[nx][ny] == True or matrix[nx][ny] > matrix[cur[0]][cur[1]]:
                    continue
                visit[nx][ny] = True
                q.append((nx, ny))
        return False


    def pacificAtlantic(self, matrix: List[List[int]]) -> List[List[int]]:
        m = len(matrix)
        n = len(matrix[0])

        res = []
        for i in range(m):
            for j in range(n):
                visit = [[False] *n for _ in range(m)]
                if self.bfs(matrix, i, j, visit):
                    res.append([i,j])
        return res


```



#### 4. 岛屿的最大面积 → **LeetCode 695. Max Area of Island**

```
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        ans = 0
        for i, l in enumerate(grid):
            for j, n in enumerate(l):
                cur = 0
                q = collections.deque([(i, j)])
                while q:
                    cur_i, cur_j = q.popleft()
                    if cur_i < 0 or cur_j < 0 or cur_i == len(grid) or cur_j == len(grid[0]) or grid[cur_i][cur_j] != 1:
                        continue
                    cur += 1
                    grid[cur_i][cur_j] = 0
                    for di, dj in [[0, 1], [0, -1], [1, 0], [-1, 0]]:
                        next_i, next_j = cur_i + di, cur_j + dj
                        q.append((next_i, next_j))
                ans = max(ans, cur)
        return ans
```



#### 5. 腐烂的橘子 → **LeetCode 994. Rotting Oranges**（可 DFS/BFS，DFS 更侧重路径探索）

所有烂橘子，是同时开始腐蚀的，不能一个个算BFS

```
class Solution:
    """
    @param grid: A matrix
    @return: The time it takes for all the oranges to rot
    """
    def isInBound(self, x, y, m, n):
        if x >= m or y >= n or x < 0 or y < 0:
            return False
        return True
        
    def bfs(self, grid, q, visit):
        m = len(grid)
        n = len(grid[0])

        step = 0
        dx = [0,0,-1,1]
        dy = [-1,1,0,0]
        while len(q) > 0:
            level = len(q)
            step += 1
            while level > 0:
                level -= 1
                cur = q.popleft()
                for i in range(4):
                    nx = cur[0] + dx[i]
                    ny = cur[1] + dy[i]
                    if not self.isInBound(nx, ny, m, n) or visit[nx][ny] or grid[nx][ny] != 1:
                        continue
                    visit[nx][ny] = True
                    q.append((nx, ny))
        return step - 1

    def rotting_oranges(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0])

        res = 0
        q = collections.deque([])
        visit = [[False] * n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 2:
                    q.append((i, j))
                    visit[i][j] = True
        res = self.bfs(grid, q, visit)

        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1 and not visit[i][j]:
                    return -1
        return res
```



#### 6. 课程表 → **LeetCode 207. Course Schedule**（拓扑排序 + DFS 环检测）

g[e[1]].append(e[0]) 含义是，e[1]链接向的所有子node

```
    def can_finish(self, num_courses: int, prerequisites: List[List[int]]) -> bool:
        g = collections.defaultdict(list)
        indegree = collections.defaultdict(int)
        for i in range(num_courses):
            g[i] = []
            indegree[i] = 0
        for e in prerequisites:
            g[e[1]].append(e[0])
            indegree[e[0]] += 1
        start = [n for n in g.keys() if indegree[n] == 0]
        if len(start) == 0:
            return False
        d = collections.deque(start)
        res = []
        while len(d) > 0:
            cur = d.popleft()
            res.append(cur)
            for t in g[cur]:
                indegree[t] -= 1
                if indegree[t] == 0:
                    d.append(t)
        return len(res) == num_courses
```



#### 7. 课程表 II → **LeetCode 210. Course Schedule II**（DFS 拓扑排序）

```
class Solution:
    """
    @param num_courses: a total of n courses
    @param prerequisites: a list of prerequisite pairs
    @return: the course order
    """
    def find_order(self, num_courses: int, prerequisites: List[List[int]]) -> List[int]:
        g = collections.defaultdict(list)
        indegree = collections.defaultdict(int)
        for i in range(num_courses):
            g[i] = []
            indegree[i] = 0
        for e in prerequisites:
            g[e[1]].append(e[0])
            indegree[e[0]] += 1
        start = [n for n in range(num_courses) if indegree[n] == 0 ]
        print (start)
        q = collections.deque(start)
        res = []
        while len(q) > 0:
            cur = q.popleft()
            res.append(cur)
            for n in g[cur]:
                indegree[n] -= 1
                if indegree[n] == 0:
                    q.append(n)
        if len(res) != num_courses:
            return []
        return res   
```



### 组合问题（无顺序，不重复选）

#### 1. 组合总和 → **LeetCode 39. Combination Sum**（元素可重复选）

```
class Solution:
    """
    @param candidates: A list of integers
    @param target: An integer
    @return: A list of lists of integers
             we will sort your return value in output
    """

    def dfs(self, can, target, curlist, s, res):
        if s > target:
            return
        if s == target:
            tmp = sorted(curlist)
            if tmp not in res:
                res.append(tmp)
            return
        for n in can:
            curlist.append(n)
            self.dfs(can, target, curlist, s + n, res)
            curlist.pop()

    def combination_sum(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        self.dfs(candidates, target, [], 0, res)

        return res
```



#### 2. 组合总和 II → **LeetCode 40. Combination Sum II**（元素不可重复选）

```
class Solution:
    """
    @param num: Given the candidate numbers
    @param target: Given the target number
    @return: All the combinations that sum to target
             we will sort your return value in output
    """
    def dfs(self, num, target, pre, curlist, s, res):
        if s > target:
            return
        if s == target:
            tmp = sorted(curlist)
            if tmp not in res:
                res.append(tmp)
        for i in range(pre, len(num)):
            curlist.append(num[i])
            self.dfs(num, target, i + 1, curlist, s + num[i], res)
            curlist.pop()

    def combination_sum2(self, num: List[int], target: int) -> List[List[int]]:
        res = []
        self.dfs(num, target, 0, [], 0, res)
        return res
```



#### 3. 组合总和 III → **LeetCode 216. Combination Sum III**（选 k 个数和为目标）

```
class Solution:
    """
    @param k: an integer
    @param n: an integer
    @return: return a List[List[int]]
    """
    def dfs(self, k, n, pre, curlist, s, res):
        if s > n or len(curlist) > k:
            return
        if s == n and len(curlist) == k:
            tmp = sorted(curlist)
            if tmp not in res:
                res.append(tmp)
            return
        for i in range(pre + 1, 10):
            curlist.append(i)
            self.dfs(k, n, i, curlist, s + i, res)
            curlist.pop()
        
    def combination_sum3(self, k: int, n: int) -> List[List[int]]:
        res = []
        self.dfs(k, n, 0, [], 0, res)
        return res
```



#### 4. 电话号码的字母组合 → **LeetCode 17. Letter Combinations of a Phone Number**（多组选择的组合）

```
class Solution:
    """
    @param digits: A digital string
    @return: all possible letter combinations
             we will sort your return value in output
    """
    def dfs(self, digits, data, idx, curlist, res):
        if len(curlist) == len(digits):
            if curlist not in res:
                res.append(list(curlist))
            return
        for c in data[digits[idx]]:
            curlist.append(c)
            self.dfs(digits, data, idx+1, curlist, res)
            curlist.pop()
        
    def letter_combinations(self, digits: str) -> List[str]:
        if digits == "":
            return []
        data = collections.defaultdict(list)
        data["2"] = ["a", "b", "c"]
        data["3"] = ["d", "e", "f"]
        data["4"] = ["g", "h", "i"]
        data["5"] = ["j", "k", "l"]
        data["6"] = ["m", "n", "o"]
        data["7"] = ["p", "q", "r", "s"]
        data["8"] = ["t", "u", "v"]
        data["9"] = ["w", "x", "y", "z"]
        res = []
        self.dfs(digits, data, 0, [], res)
        ret = []
        for o in res:
            ret.append("".join(o))
        return ret
```



#### 5. 组合 → **LeetCode 77. Combinations**（从 n 选 k 的所有组合）

到最大素材数n的剩余个数不足以组成k个数的排列的时候，直接返回

```
class Solution:
    def dfs(self, n, k, pre, curlist, res):
        if (len(curlist) + (n - pre + 1) < k):
            return
        if len(curlist) == k:
            if curlist not in res:
                res.append(list(curlist))
        if pre >= n:
            return
        for i in range(pre + 1, n + 1):
            curlist.append(i)
            self.dfs(n, k, i, curlist, res)
            curlist.pop()
    def combine(self, n: int, k: int) -> List[List[int]]:
        res = []
        self.dfs(n, k, 0, [], res)
        return res
```
选还是不选，是组合问题，用如下模板
```
class Solution {
public:
    vector<int> temp;
    vector<vector<int>> ans;

    void dfs(int cur, int n, int k) {
        // 剪枝：temp 长度加上区间 [cur, n] 的长度小于 k，不可能构造出长度为 k 的 temp
        if (temp.size() + (n - cur + 1) < k) {
            return;
        }
        // 记录合法的答案
        if (temp.size() == k) {
            ans.push_back(temp);
            return;
        }
        // 考虑选择当前位置
        temp.push_back(cur);
        dfs(cur + 1, n, k);
        temp.pop_back();
        // 考虑不选择当前位置
        dfs(cur + 1, n, k);
    }

    vector<vector<int>> combine(int n, int k) {
        dfs(1, n, k);
        return ans;
    }
};
```



### 排列问题（有顺序，全排列 / 部分排列）

#### 1. 全排列 → **LeetCode 46. Permutations**（无重复元素）

```
class Solution:
    """
    @param nums: A list of integers.
    @return: A list of permutations.
             we will sort your return value in output
    """
    def dfs(self, nums, curlist, visit, res):
        if len(curlist) > len(nums):
            return
        if len(curlist) == len(nums):
            res.append(list(curlist))
            return
        for i in nums:
            if visit[i] == True:
                continue
            curlist.append(i)
            visit[i] = True
            self.dfs(nums, curlist, visit, res)
            visit[i] = False
            curlist.pop()

    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []
        visit = collections.defaultdict(bool)
        self.dfs(nums, [], visit, res)
        return res
```



#### 2. 全排列 II → **LeetCode 47. Permutations II**（有重复元素，去重）

```
class Solution:
    """
    @param nums: A list of integers
    @return: A list of unique permutations
             we will sort your return value in output
    """
    def dfs(self, nums, curlist, visit, res):
        if len(curlist) == len(nums):

            if curlist not in res:
                res.append(list(curlist))
        for i in range(len(nums)):
            if visit[i] == True:
                continue
            visit[i] = True
            curlist.append(nums[i])
            self.dfs(nums, curlist, visit, res)
            curlist.pop()
            visit[i] = False
    def permute_unique(self, nums: List[int]) -> List[List[int]]:
        res = []
        visit = collections.defaultdict(bool)
        self.dfs(nums, [], visit, res)
        return res 
```



#### 3. 下一个排列 → **LeetCode 31. Next Permutation**（DFS 可解，更优为贪心，但 DFS 是通用思路）

a. 从后向前找到第一个升序nums[i] < nums[i  + 1], 存下i, 如果i不存在则说明是最后一个排列

b. 从后向前找第一个大于nums[i] 的j，存下j,

c. 交换nums[i], nums[j]

d. 将i + 1 到 len(nums) - 1的序列，逆序

```
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        m = len(nums)
        i = m - 2
        while i >= 0 and nums[i] >= nums[i + 1]:
            i -= 1
        if i >= 0:
            j = m - 1
            while j >= 0 and nums[j] <= nums[i]:
                j -= 1
            nums[i], nums[j] = nums[j], nums[i]

        left = i + 1
        right = m - 1
        while left < right:
            nums[left], nums[right] = nums[right], nums[left]
            left += 1
            right -= 1
```



#### 4. 字符串的排列 → **LeetCode 567. Permutation in String**（滑动窗口 + DFS 辅助判断，或纯 DFS）

```
class Solution:
    """
    @param s1: a string
    @param s2: a string
    @return: if s2 contains the permutation of s1
    """
    def check_inclusion(self, s1: str, s2: str) -> bool:
        if len(s1) > len(s2):
            return False
        m = len(s1)
        n = len(s2)
        h1 = dict()
        h2 = dict()
        for i in range(26):
            h1[chr(ord('a') + i)] = 0
            h2[chr(ord('a') + i)] = 0

        for i in range(m):
            h1[s1[i]] += 1
            h2[s2[i]] += 1

        if h1 == h2:
            return True

        for i in range(n - m):
            j = i + m
            h2[s2[i]] -= 1
            h2[s2[j]] += 1
            if h1 == h2:
                return True
        return False
```



### 子集问题（所有可能的子集）

#### 1. 子集 → **LeetCode 78. Subsets**（无重复元素）

```
class Solution:
    """
    @param nums: A set of numbers
    @return: A list of lists
             we will sort your return value in output
    """
    def dfs(self, nums, pre, curlist, res):
        m = len(nums)
        if len(curlist) > len(nums):
            return
        if sorted(curlist) not in res:
            res.append(sorted(curlist))
        for i in range(pre, m):
            curlist.append(nums[i])
            self.dfs(nums, i + 1, curlist, res)
            curlist.pop()

    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []
        visit = collections.defaultdict(bool)
        self.dfs(nums, 0, [], res)
        return res

```



#### 2. 子集 II → **LeetCode 90. Subsets II**（有重复元素，去重）

```
class Solution:
    """
    @param nums: A set of numbers.
    @return: A list of lists. All valid subsets.
             we will sort your return value in output
    """
    def dfs(self, nums, pre, curlist, res):
        if len(curlist) > len(nums):
            return
        if sorted(curlist) not in res:
            res.append(sorted(curlist))
        
        for i in range(pre, len(nums)):
            curlist.append(nums[i])
            self.dfs(nums, i + 1, curlist, res)
            curlist.pop()

    def subsets_with_dup(self, nums: List[int]) -> List[List[int]]:
        res = []
        self.dfs(nums, 0, [], res)
        return res
```



#### 3. 递增子序列 → **LeetCode 491. Increasing Subsequences**（子集 + 递增约束，去重）

基础款

```
class Solution:
    """
    @param nums: an integer array
    @return: all the different possible increasing subsequences of the given array
             we will sort your return value in output
    """
    def dfs(self, nums, pre, curlist, res):
        if pre == len(nums):
            if curlist not in res and len(curlist) > 1:
                res.append(list(curlist))
            return

        curlist.append(nums[pre])
        self.dfs(nums, pre + 1, curlist, res)
        curlist.pop()
        self.dfs(nums, pre + 1, curlist, res)

    def find_subsequences(self, nums: List[int]) -> List[List[int]]:
        res = []
        self.dfs(sorted(nums), 0, [], res)
        return res
```

```
class Solution:
    """
    @param nums: an integer array
    @return: all the different possible increasing subsequences of the given array
             we will sort your return value in output
    """
    def dfs(self, nums, pre, curlist, last, res):
        if pre == len(nums):
            if curlist not in res and len(curlist) > 1:
                res.append(list(curlist))
            return

        if nums[pre] >= last:
            curlist.append(nums[pre])
            self.dfs(nums, pre + 1, curlist, nums[pre], res)
            curlist.pop()
        if nums[pre] != last:
            self.dfs(nums, pre + 1, curlist, last, res)

    def find_subsequences(self, nums: List[int]) -> List[List[int]]:
        res = []
        self.dfs(nums, 0, [], -math.inf, res)
        return res
```

使序列合法的办法非常简单，即给「选择」做一个限定条件，只有当前的元素大于等于上一个选择的元素的时候才能选择这个元素，这样枚举出来的所有元素都是合法的

那如何保证没有重复呢？我们需要给「不选择」做一个限定条件，只有当当前的元素不等于上一个选择的元素的时候，才考虑不选择当前元素，直接递归后面的元素。因为如果有两个相同的元素，我们会考虑这样四种情况：

前者被选择，后者被选择
前者被选择，后者不被选择
前者不被选择，后者被选择
前者不被选择，后者不被选择
其中第二种情况和第三种情况其实是等价的，我们这样限制之后，舍弃了第二种，保留了第三种，于是达到了去重的目的。

```
if (nums[cur] != last) {
	dfs(cur + 1, last, nums);
}
```

先把方法2段首的递归枚举子序列的通用模板理解了，这段代码就好理解了。
首先以[1,3,3,3]为例，本文的递归的方法如果不加处理的话，最后会产生的[1,3]重复序列实质上是，[1,3,0,0] [1,0,3,0][1,0,0,3]，因为在代码中是直接push_back的，所以看起来都是[1,3]。0的意思是不选择。
在处理后（加上上述代码后）,当递归到[1,3,x,x] （x的意思是，还没决定要不要选择）的时候，此时last = 3，cur = 2，如果不加上述关键的判断的话，他会继续进行x = 0（不选择）和 x = 3（选择）成为了[1,3,0,x]和[1,3,3,x]，上述的判断就是不能进行这个x=0的操作，因为我们发现当前的x应该等于 3，他是等于last的，因此就把x =0的这个分支去掉了，这样就避免了出现[1,3,0,0]这个，同理，在 [1,0,3,x]的时候去掉了x=0的分支，避免了出现[1,0,3,0]的情况，最后只留下[1,0,0,3] 这种[1,3]

### 路径搜索与回溯（DFS + 剪枝）

#### 1. 单词搜索 → **LeetCode 79. Word Search**（网格 DFS + 回溯，标记已访问）

```
class Solution:
    """
    @param board: A list of lists of character
    @param word: A string
    @return: A boolean
    """
    def isInBound(self, x, y, m, n):
        if x >= m or y >= n or x < 0 or y < 0:
            return False
        return True 
    def dfs(self, board, x, y, level, visit, word):
        if level + 1 == len(word):
            return True
        m = len(board)
        n = len(board[0])
        dx = [0,0,1,-1]
        dy = [1,-1,0,0]
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            if not self.isInBound(nx, ny, m, n) or visit[nx][ny]:
                continue
            if level + 1 < len(word) and str(word[level + 1]) != str(board[nx][ny]):
                continue
            #print("IN")
            visit[nx][ny] = True
            if self.dfs(board, nx, ny, level + 1, visit, word):
                return True
            visit[nx][ny] = False

        return False

    def exist(self, board: List[List[str]], word: str) -> bool:
        m = len(board)
        n = len(board[0])

        for i in range(m):
            for j in range(n):
                if board[i][j] == word[0]:
                    visit = [[False] * n for _ in range(m)]
                    visit[i][j] = True
                    if self.dfs(board, i, j, 0, visit, word):
                        return True
        return False
```



#### 2. 单词搜索 II → **LeetCode 212. Word Search II**（Trie+DFS 优化）

```
class Trie:
    def __init__(self):
        self.children = collections.defaultdict(Trie)
        self.isEnd = False
        self.word = ""
    def insert(self, word):
        cur = self
        for c in word:
            cur = cur.children[c]
        cur.isEnd = True
        cur.word = str(word)

class Solution:
    """
    @param board: A list of lists of character
    @param words: A list of string
    @return: A list of string
             we will sort your return value in output
    """

    def isInBound(self, x, y, m, n):
        if x >= m or y >= n or x < 0 or y < 0:
            return False
        return True
    def dfs(self, board, x, y, visit, curtri, res):
        m = len(board)
        n = len(board[0])
        if board[x][y] not in curtri.children:
            return
        
        c = board[x][y]
        curtri = curtri.children[c]
        if curtri.word != "" and curtri.word not in res:
            res.append(curtri.word)
        
        dx = [0,0,1,-1]
        dy = [1,-1,0,0]
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            if not self.isInBound(nx, ny, m, n) or visit[nx][ny]:
                continue
            visit[nx][ny] = True
            self.dfs(board, nx, ny, visit, curtri, res)
            visit[nx][ny] = False

    def word_search_i_i(self, board: List[List[str]], words: List[str]) -> List[str]:
        m = len(board)
        n = len(board[0])
        trie = Trie()
        for w in words:
            trie.insert(w)
        res = []
        for i in range(m):
            for j in range(n):
                visit = [[False] * n for _ in range(m)]
                visit[i][j] = True
                self.dfs(board, i, j, visit, trie, res)
        return res
```



#### 3. N 皇后 → **LeetCode 51. N-Queens**（经典回溯 + DFS 剪枝）

斜向的行和列的差，或者和，是一个固定的数，每次记录Q的时候把这个固定数也记录就可以了

```
class Solution:
    """
    @param n: The number of queens
    @return: All distinct solutions
             we will sort your return value in output
    """
    column = []
    dia1 = []
    dia2 = []
    queentag = [-1] * 10
    def dfs(self, n, row, res):
        if row == n:
            res.append(list(self.queentag))
            return
        for i in range(n):
            if i in self.column or row + i in self.dia1 or row - i in self.dia2:
                continue
            self.queentag[row] = i
            self.column.append(i)
            self.dia1.append(row + i)
            self.dia2.append(row - i)
            self.dfs(n, row + 1, res)
            self.dia2.pop()
            self.dia1.pop()
            self.column.pop()

    def solve_n_queens(self, n: int) -> List[List[str]]:
        res = []
        self.dfs(n, 0, res)

        ret = []
        for s in res:
            q = s
            board = []
            for i in range(n):
                line = ""
                for j in range(n):
                    if q[i] == j:
                        line += "Q"
                    else:
                        line += "."
                board.append(line)
            ret.append(board)
        return ret
```



#### 4. N 皇后 II → **LeetCode 52. N-Queens II**（统计解的数量，DFS 剪枝）
#### 5. 解数独 → **LeetCode 37. Sudoku Solver**（DFS + 回溯 + 剪枝）

考虑行，列，9个3*3方块

```
class Solution:
    """
    @param board: the sudoku puzzle
    @return: nothing
    """
    def __init__(self):
        # 将tag变量放在__init__中，避免多个实例共享状态
        self.rowtag = [[False] * 10 for _ in range(9)]
        self.coltag = [[False] * 10 for _ in range(9)]
        self.celltag = [[[False] * 10 for _ in range(3)] for _ in range(3)]
    
    def dfs(self, board, x, y):
        # 先判断是否当前列已遍历完（x越界），推进到下一列
        if x == 9:
            y += 1
            x = 0  # 下一列从第0行开始
        # 若列也遍历完（y=9），说明数独已解完
        if y == 9:
            return True
        # 若当前格子已有数字，直接递归下一格（x+1, y）
        if board[x][y] != 0:
            return self.dfs(board, x + 1, y)  # 必须return结果，否则会继续执行后续逻辑
        # 尝试填充1-9
        for num in range(1, 10):
            # 检查行、列、单元格是否可用
            if self.rowtag[x][num] or self.coltag[y][num] or self.celltag[x//3][y//3][num]:
                continue
            # 放置数字并标记
            board[x][y] = num
            self.rowtag[x][num] = True
            self.coltag[y][num] = True
            self.celltag[x//3][y//3][num] = True
            # 递归下一格，若成功则返回True
            if self.dfs(board, x + 1, y):
                return True
            # 回溯：移除数字并取消标记
            board[x][y] = 0
            self.rowtag[x][num] = False
            self.coltag[y][num] = False
            self.celltag[x//3][y//3][num] = False
        # 若所有数字都无法填充，返回False
        return False

    def solve_sudoku(self, board: List[List[int]]):
        # 初始化tag数组（标记已有数字）
        for i in range(9):
            for j in range(9):
                if board[i][j] != 0:
                    num = board[i][j]
                    self.rowtag[i][num] = True
                    self.coltag[j][num] = True
                    self.celltag[i//3][j//3][num] = True
        # 从(0,0)开始递归求解
        self.dfs(board, 0, 0)
```



#### 6. 分割回文串 → **LeetCode 131. Palindrome Partitioning**（DFS 分割 + 回文判断）

从字符串index的位置开始向后for循环，找到第一个pal的时候，从下一个index+1开始继续查找下一个pal

```
class Solution:
    """
    @param: s: A string
    @return: A list of lists of string
    """
    def isPal(self, s):
        l = 0
        r = len(s) - 1
        while l < r:
            if s[l] != s[r]:
                return False
            l += 1
            r -= 1
        return True
    def dfs(self, s, cur, curlist, res):
        if cur == len(s):
            res.append(list(curlist))
            return
        
        for i in range(cur, len(s)):
            tmp = s[cur: i + 1]
            if not self.isPal(tmp):
                continue
            curlist.append(tmp)
            self.dfs(s, i + 1, curlist, res)
            curlist.pop()

    def partition(self, s):
        res = []
        self.dfs(s, 0, [], res)
        return res
```



#### 7. 分割回文串 II → **LeetCode 132. Palindrome Partitioning II**（DFS + 动态规划优化）

### 其他高频 DFS 题

#### 1. 目标和 → **LeetCode 494. Target Sum**（DFS + 回溯，或动态规划）

```
class Solution:
    """
    @param nums: the given array
    @param s: the given target
    @return: the number of ways to assign symbols to make sum of integers equal to target S
    """
    def __init__(self):
        self.res = 0
    def dfs(self, nums, s, idx, cur):
        if idx == len(nums):
            # 遍历完后再检查和是否等于目标
            if cur == s:
                self.res += 1
            return

        self.dfs(nums, s, idx + 1, cur + nums[idx])
        self.dfs(nums, s, idx + 1, cur - nums[idx])

    def find_target_sum_ways(self, nums: List[int], s: int) -> int:
        self.dfs(nums, s, 0, 0)
        return self.res
```

```
    def find_target_sum_ways(self, nums: List[int], s: int) -> int:
        # 使用lru_cache需要将参数转为不可变类型，这里用辅助函数处理
        from functools import lru_cache
        
        @lru_cache(maxsize=None)
        def dfs(idx, cur_sum):
            # 终止条件：处理完所有元素
            if idx == len(nums):
                return 1 if cur_sum == s else 0
            # 递归：加当前数 或 减当前数，两种情况的和
            return dfs(idx + 1, cur_sum + nums[idx]) + dfs(idx + 1, cur_sum - nums[idx])
        
        return dfs(0, 0)
```



#### 2. 不同的二叉搜索树 II → **LeetCode 95. Unique Binary Search Trees II**（DFS 构造）

#### 3. 二叉树的序列化与反序列化 → **LeetCode 297. Serialize and Deserialize Binary Tree**（DFS 递归序列化）

序列化：BFS， 反序列化：快慢指针

#### 4. 最长递增路径 → **LeetCode 329. Longest Increasing Path in a Matrix**（网格 DFS + 记忆化）

#### Clone Graph

#### Word Ladder

#### 178 · Graph Valid Tree

1. 边数 == node数 - 1  2. 连通

```
    def valid_tree(self, n: int, edges: List[List[int]]) -> bool:
        if len(edges) != nnum - 1:
            return False
        d = collections.defaultdict(list)
        for e in edges:
            d[e[0]].append(e[1])
            d[e[1]].append(e[0])
        q = collections.deque([0])
        visit = [0]
        while len(q) != 0:
            cur = q.popleft()

            for n in d[cur]:
                if n not in visit:
                    visit.append(n)
                    q.append(n)
        return len(visit) == nnum
```

