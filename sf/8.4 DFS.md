[TOC]



### 树与二叉树相关（DFS 基础场景）

#### 1. 二叉树的最大深度 → **LeetCode 104. Maximum Depth of Binary Tree**
#### 2. 二叉树的最小深度 → **LeetCode 111. Minimum Depth of Binary Tree**
#### 3. 路径总和 → **LeetCode 112. Path Sum**
#### 4. 路径总和 II → **LeetCode 113. Path Sum II**
#### 5. 二叉树中的最大路径和 → **LeetCode 124. Binary Tree Maximum Path Sum**
#### 6. 二叉树的所有路径 → **LeetCode 257. Binary Tree Paths**
#### 7. 左叶子之和 → **LeetCode 404. Sum of Left Leaves**
#### 8. 最长同值路径 → **LeetCode 687. Longest Univalue Path**
#### 9. 找树左下角的值 → **LeetCode 513. Find Bottom Left Tree Value**
#### 10. 验证二叉搜索树 → **LeetCode 98. Validate Binary Search Tree**（中序 DFS）

### 图相关（遍历与连通性）

#### 1. 岛屿数量 → **LeetCode 200. Number of Islands**（网格 DFS，经典入门）

DFS:

```
class Solution:
    """
    @param grid: a boolean 2D matrix
    @return: an integer
    """
    def isInBound(self, x, y, m, n):
        if x >= m or y >= n or x < 0 or y < 0:
            return False
        return True
    
    def dfs(self, grid, x, y, visit):
        m = len(grid)
        n = len(grid[0])
        if not self.isInBound(x, y, m, n):
            return
        dx = [0, 0, 1, -1]
        dy = [1, -1, 0, 0]
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            if not self.isInBound(nx, ny, m, n) or grid[nx][ny] != 1 or visit[nx][ny] == True:
                continue
            visit[nx][ny] = True
            self.dfs(grid, nx, ny, visit)

    def num_islands(self, grid: List[List[bool]]) -> int:
        if grid ==None:
            return 0
        if len(grid) == 0:
            return 0
        m = len(grid)
        n = len(grid[0])
        res = 0
        visit = [[False] * n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1 and visit[i][j] == False:
                    res += 1
                    self.dfs(grid, i, j, visit)
        return res
```

并查集

```
class Solution {
public:
    /**
     * @param grid: a boolean 2D matrix
     * @return: an integer
     */
    int find(unordered_map<int, int>& p, int x)
    {
        if (p[x] != x) p[x] = find(p, p[x]);
        return p[x];
    }
    int idx(int x, int y, int m)
    {
        return x * m + y;
    }
    bool isInBound(int x, int y, int m, int n)
    {
        if (x >= m || y >= n || x < 0 || y < 0)
            return false;
        return true;
    }
    int numIslands(vector<vector<bool>> &grid) {
        if (grid.size() == 0)
            return 0;
        
        int m = grid.size();
        int n = grid[0].size();

        unordered_map<int, int> p;
        for(int i = 0; i < m; i++)
            for(int j = 0; j < n; j++)
                p[idx(i, j, m)] = idx(i, j, m);

        int dx[4] = {0,0,-1,1};
        int dy[4] = {-1,1,0,0};
        for(int i = 0; i < m; i++)
        {
            for(int j = 0; j < n; j++)
            {
                if (grid[i][j] != 1)
                    continue;
                for (int d = 0; d < 4; d++)
                {
                    int nx = i + dx[d];
                    int ny = j + dy[d];
                    if (!isInBound(nx, ny, m, n) || grid[nx][ny] != 1 ||
                        p[find(p, idx(i, j, m))] == find(p, idx(nx, ny, m)))
                        continue;

                    p[find(p, idx(i, j, m))] = find(p, idx(nx, ny, m));
                }
            }
        }
        
        unordered_set<int> s;
        for(int i = 0; i < m; i++)
        {
            for(int j = 0; j < n; j++)
            {
                if (grid[i][j] == 1)
                {
                    s.insert(find(p, idx(i, j, m)));
                }
            }
        }
        return s.size();
    }
};
```



#### 2. 被围绕的区域 → **LeetCode 130. Surrounded Regions**（边界 DFS + 标记）

使用 BFS 的方法
先把从边界开始的 O 都标记为 W，这样非 W 的地方就全都需要标记为 X

```
class Solution:
    # @param {list[list[str]]} board a 2D board containing 'X' and 'O'
    # @return nothing 
    def surroundedRegions(self, board):
        # Write your code here
        if not any(board):
            return

        n, m = len(board), len(board[0])
        q = [ij for k in range(max(n,m)) for ij in ((0, k), (n-1, k), (k, 0), (k, m-1))]
        while q:
            i, j = q.pop()
            if 0 <= i < n and 0 <= j < m and board[i][j] == 'O':
                board[i][j] = 'W'
                q += (i, j-1), (i, j+1), (i-1, j), (i+1, j)

        board[:] = [['XO'[c == 'W'] for c in row] for row in board]
```

```
class Solution:
    def isInBound(self, x, y, m, n):
        return 0 <= x < m and 0 <= y < n
    def dfs(self, board, x, y):
        dx = [0,0,1,-1]
        dy = [1,-1,0,0]
        m = len(board)
        n = len(board[0])

        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            if not self.isInBound(nx, ny, m, n) or board[nx][ny] != "O":
                continue
            board[nx][ny] = "W"
            self.dfs(board, nx, ny)

    def solve(self, board: List[List[str]]) -> None:
        m = len(board)
        n = len(board[0])
        for i in range(m):
            for j in range(n):
                isEdge = (i == 0) or (j == 0) or (i == m - 1) or (j == n - 1)
                if isEdge and board[i][j] == "O":
                    board[i][j] = "W"
                    self.dfs(board, i, j)
        for i in range(m):
            for j in range(n):
                if board[i][j] == "O":
                    board[i][j] = "X"
                if board[i][j] == "W":
                    board[i][j] = "O"
```



#### 3. 太平洋大西洋水流问题 → **LeetCode 417. Pacific Atlantic Water Flow**（双向 DFS）

BFS

```
class Solution:
    def isInBound(self, x, y, m, n):
        return 0 <= x < m and 0 <= y < n
    def bfs(self, heights, edges):
        dx = [0,0,1,-1]
        dy = [1,-1,0,0]
        m = len(heights)
        n = len(heights[0])
        q = collections.deque(edges)
        visit = [[False] * n for _ in range(m)]
        for ex,ey in edges:
            visit[ex][ey] = True
        res = set()
        while len(q) > 0:
            cur = q.popleft()
            res.add(cur)
            for i in range(4):
                nx = cur[0] + dx[i]
                ny = cur[1] + dy[i]
                if not self.isInBound(nx, ny, m, n) or heights[nx][ny] < heights[cur[0]][cur[1]] or visit[nx][ny] == True:
                    continue
                visit[nx][ny] = True
                q.append((nx, ny))
        return res
    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
        m = len(heights)
        n = len(heights[0])
        pacific = []
        atlantic = []  
        for i in range(m):
            for j in range(n):
                if i == 0 or j == 0:
                    pacific.append((i, j))
                if i == m - 1 or j == n - 1:
                    atlantic.append((i, j))
        pset = self.bfs(heights, pacific)
        aset = self.bfs(heights, atlantic)
        return list(pset & aset)
```



```
class Solution:
    """
    @param matrix: the given matrix
    @return: The list of grid coordinates
             we will sort your return value in output
    """
    def isReach(self, x, y, m, n, bp, ba):
        if x == 0 or y == 0:
            bp = True
        if x == m - 1 or y == n - 1:
            ba = True
        return bp, ba
    def isInBound(self, x, y, m, n):
        if x >= m or y >= n or x < 0 or y < 0:
            return False
        return True

    def bfs(self, matrix, x, y, visit):
        m = len(matrix)
        n = len(matrix[0])
        dx = [0,0,-1,1]
        dy = [1,-1,0,0]
        bp, ba = False, False
        visit[x][y] = True
        q = collections.deque([(x, y)])
        while len(q) != 0:
            cur = q.popleft()
            bp, ba = self.isReach(cur[0], cur[1], m, n, bp, ba)
            if bp and ba:
                return True
            for i in range(4):
                nx = cur[0] + dx[i]
                ny = cur[1] + dy[i]

                if not self.isInBound(nx, ny, m, n) or visit[nx][ny] == True or matrix[nx][ny] > matrix[cur[0]][cur[1]]:
                    continue
                visit[nx][ny] = True
                q.append((nx, ny))
        return False


    def pacificAtlantic(self, matrix: List[List[int]]) -> List[List[int]]:
        m = len(matrix)
        n = len(matrix[0])

        res = []
        for i in range(m):
            for j in range(n):
                visit = [[False] *n for _ in range(m)]
                if self.bfs(matrix, i, j, visit):
                    res.append([i,j])
        return res


```

```
class Solution:
    def isInBound(self, x, y, m, n):
        if x < 0 or y < 0 or x >= m or y >= n:
            return False
        return True
    def dfs(self, heights, x, y, visit):
        if (x, y) in visit:
            return
        m = len(heights)
        n = len(heights[0])
        visit.add((x, y))
        dx = [0,0,1,-1]
        dy = [1,-1,0,0]
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            if not self.isInBound(nx, ny, m, n) or heights[nx][ny] < heights[x][y] or ((nx,ny) in visit):
                continue
            self.dfs(heights, nx, ny, visit)

    def search(self, heights, seaPoint):
        visit = set()
        for p in seaPoint:
            self.dfs(heights, p[0], p[1], visit)
        return visit
    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
        m = len(heights)
        n = len(heights[0])
        P = [(i, 0) for i in range(len(heights))] + [(0, j) for j in range(len(heights[0]))]
        A = [(i, n - 1) for i in range(len(heights))] + [(m - 1, j) for j in range(len(heights[0]))]

        pv = self.search(heights, P)
        av = self.search(heights, A)

        return list(pv & av)
		# return [[x, y] for (x, y) in pv & av]
```



#### 4. 岛屿的最大面积 → **LeetCode 695. Max Area of Island**

```
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        ans = 0
        for i, l in enumerate(grid):
            for j, n in enumerate(l):
                cur = 0
                q = collections.deque([(i, j)])
                while q:
                    cur_i, cur_j = q.popleft()
                    if cur_i < 0 or cur_j < 0 or cur_i == len(grid) or cur_j == len(grid[0]) or grid[cur_i][cur_j] != 1:
                        continue
                    cur += 1
                    grid[cur_i][cur_j] = 0
                    for di, dj in [[0, 1], [0, -1], [1, 0], [-1, 0]]:
                        next_i, next_j = cur_i + di, cur_j + dj
                        q.append((next_i, next_j))
                ans = max(ans, cur)
        return ans
```



#### 5. 腐烂的橘子 → **LeetCode 994. Rotting Oranges**（可 DFS/BFS，DFS 更侧重路径探索）

所有烂橘子，是同时开始腐蚀的，不能一个个算BFS

```
class Solution:
    """
    @param grid: A matrix
    @return: The time it takes for all the oranges to rot
    """
    def isInBound(self, x, y, m, n):
        if x >= m or y >= n or x < 0 or y < 0:
            return False
        return True
        
    def bfs(self, grid, q, visit):
        m = len(grid)
        n = len(grid[0])

        step = 0
        dx = [0,0,-1,1]
        dy = [-1,1,0,0]
        while len(q) > 0:
            level = len(q)
            step += 1
            while level > 0:
                level -= 1
                cur = q.popleft()
                for i in range(4):
                    nx = cur[0] + dx[i]
                    ny = cur[1] + dy[i]
                    if not self.isInBound(nx, ny, m, n) or visit[nx][ny] or grid[nx][ny] != 1:
                        continue
                    visit[nx][ny] = True
                    q.append((nx, ny))
        return step - 1

    def rotting_oranges(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0])

        res = 0
        q = collections.deque([])
        visit = [[False] * n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 2:
                    q.append((i, j))
                    visit[i][j] = True
        res = self.bfs(grid, q, visit)

        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1 and not visit[i][j]:
                    return -1
        return res
```



#### 6. 课程表 → **LeetCode 207. Course Schedule**（拓扑排序 + DFS 环检测）

g[e[1]].append(e[0]) 含义是，e[1]链接向的所有子node

```
    def can_finish(self, num_courses: int, prerequisites: List[List[int]]) -> bool:
        g = collections.defaultdict(list)
        indegree = collections.defaultdict(int)
        for i in range(num_courses):
            g[i] = []
            indegree[i] = 0
        for e in prerequisites:
            g[e[1]].append(e[0])
            indegree[e[0]] += 1
        start = [n for n in g.keys() if indegree[n] == 0]
        if len(start) == 0:
            return False
        d = collections.deque(start)
        res = []
        while len(d) > 0:
            cur = d.popleft()
            res.append(cur)
            for t in g[cur]:
                indegree[t] -= 1
                if indegree[t] == 0:
                    d.append(t)
        return len(res) == num_courses
```



#### 7. 课程表 II → **LeetCode 210. Course Schedule II**（DFS 拓扑排序）

```
class Solution:
    """
    @param num_courses: a total of n courses
    @param prerequisites: a list of prerequisite pairs
    @return: the course order
    """
    def find_order(self, num_courses: int, prerequisites: List[List[int]]) -> List[int]:
        g = collections.defaultdict(list)
        indegree = collections.defaultdict(int)
        for i in range(num_courses):
            g[i] = []
            indegree[i] = 0
        for e in prerequisites:
            g[e[1]].append(e[0])
            indegree[e[0]] += 1
        start = [n for n in range(num_courses) if indegree[n] == 0 ]
        print (start)
        q = collections.deque(start)
        res = []
        while len(q) > 0:
            cur = q.popleft()
            res.append(cur)
            for n in g[cur]:
                indegree[n] -= 1
                if indegree[n] == 0:
                    q.append(n)
        if len(res) != num_courses:
            return []
        return res   
```



### 组合问题（无顺序，不重复选）

#### 1. 组合总和 → **LeetCode 39. Combination Sum**（元素可重复选， 无重复元素）

```
class Solution:
    def dfs(self, can, idx, target, curlist, s, res):
        if s > target:
            return
        if s == target:
            res.append(list(curlist))
            return
        for i in range(idx, len(can)):
            curlist.append(can[i])
            self.dfs(can, i, target, curlist, s + can[i], res)
            curlist.pop()

    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        self.dfs(candidates, 0, target, [], 0, res)
        return res
```

```
    void dfs(vector<int>& candidates, int target, vector<vector<int>>& ans, vector<int>& combine, int idx) {
        if (idx == candidates.size()) {
            return;
        }
        if (target == 0) {
            ans.emplace_back(combine);
            return;
        }
        // 直接跳过
        dfs(candidates, target, ans, combine, idx + 1);
        // 选择当前数
        if (target - candidates[idx] >= 0) {
            combine.emplace_back(candidates[idx]);
            dfs(candidates, target - candidates[idx], ans, combine, idx);
            combine.pop_back();
        }
    }
```



#### 2. 组合总和 II → **LeetCode 40. Combination Sum II**（元素不可重复选， 有重复元素）

```
class Solution:
    def dfs(self, can, target, idx, curlist, sum, res):
        if sum > target:
            return
        if target == sum:
            res.append(list(curlist))
        
        for i in range(idx, len(can)):
            if i > idx and can[i] == can[i - 1]:
                continue
            curlist.append(can[i])
            self.dfs(can, target, i + 1, curlist, sum + can[i], res)
            curlist.pop()

    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        candidates.sort()
        self.dfs(candidates, target, 0, [], 0, res)
        return res
```



#### 3. 组合总和 III → **LeetCode 216. Combination Sum III**（选 k 个数和为目标）

```
class Solution:
    def dfs(self, k, n, idx, curlist, sum, res):
        if sum > n  or len(curlist) > k:
            return
        if sum == n and len(curlist) == k:
            res.append(curlist[:])
        for i in range(idx, 10):
            remain = n - sum
            if i > remain:
                continue
            curlist.append(i)
            self.dfs(k, n, i + 1, curlist, sum + i, res)
            curlist.pop()
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        res = []
        self.dfs(k, n, 1, [], 0, res)
        return res
```



#### 4. 电话号码的字母组合 → **LeetCode 17. Letter Combinations of a Phone Number**（多组选择的组合）

```
class Solution:
    """
    @param digits: A digital string
    @return: all possible letter combinations
             we will sort your return value in output
    """
    def dfs(self, digits, data, idx, curlist, res):
        if len(curlist) == len(digits):
            if curlist not in res:
                res.append(list(curlist))
            return
        for c in data[digits[idx]]:
            curlist.append(c)
            self.dfs(digits, data, idx+1, curlist, res)
            curlist.pop()
        
    def letter_combinations(self, digits: str) -> List[str]:
        if digits == "":
            return []
        data = collections.defaultdict(list)
        data["2"] = ["a", "b", "c"]
        data["3"] = ["d", "e", "f"]
        data["4"] = ["g", "h", "i"]
        data["5"] = ["j", "k", "l"]
        data["6"] = ["m", "n", "o"]
        data["7"] = ["p", "q", "r", "s"]
        data["8"] = ["t", "u", "v"]
        data["9"] = ["w", "x", "y", "z"]
        res = []
        self.dfs(digits, data, 0, [], res)
        ret = []
        for o in res:
            ret.append("".join(o))
        return ret
```



#### 5. 组合 → **LeetCode 77. Combinations**（从 n 选 k 的所有组合）

原始版本

```
class Solution:
    def dfs(self, n, k, idx, curlist, res):
        if len(curlist) + (n - idx + 1) < k:
            return
        if len(curlist) > k:
            return
        if len(curlist) == k:
            res.append(curlist[:])
        for i in range(idx, n+1):
            curlist.append(i)
            self.dfs(n, k, i + 1, curlist, res)
            curlist.pop()
    def combine(self, n: int, k: int) -> List[List[int]]:
        res = []
        self.dfs(n, k, 1, [], res)
        return res
```



到最大素材数n的剩余个数不足以组成k个数的排列的时候，直接返回

```
class Solution:
    def dfs(self, n, k, pre, curlist, res):
    	# len(curlist)当前用的个数，加上，还剩下的可以选的数，达不到k个。
        if (len(curlist) + (n - pre + 1) < k):
            return
        if len(curlist) == k:
            if curlist not in res:
                res.append(list(curlist))
        if pre >= n:
            return
        for i in range(pre + 1, n + 1):
            curlist.append(i)
            self.dfs(n, k, i, curlist, res)
            curlist.pop()
    def combine(self, n: int, k: int) -> List[List[int]]:
        res = []
        self.dfs(n, k, 0, [], res)
        return res
```
选还是不选，是组合问题，用如下模板
```
class Solution {
public:
    vector<int> temp;
    vector<vector<int>> ans;

    void dfs(int cur, int n, int k) {
        // 剪枝：temp 长度加上区间 [cur, n] 的长度小于 k，不可能构造出长度为 k 的 temp
        if (temp.size() + (n - cur + 1) < k) {
            return;
        }
        // 记录合法的答案
        if (temp.size() == k) {
            ans.push_back(temp);
            return;
        }
        // 考虑选择当前位置
        temp.push_back(cur);
        dfs(cur + 1, n, k);
        temp.pop_back();
        // 考虑不选择当前位置
        dfs(cur + 1, n, k);
    }

    vector<vector<int>> combine(int n, int k) {
        dfs(1, n, k);
        return ans;
    }
};
```



### 排列问题（有顺序，全排列 / 部分排列）

#### 1. 全排列 → **LeetCode 46. Permutations**（无重复元素）

```
class Solution:
    """
    @param nums: A list of integers.
    @return: A list of permutations.
             we will sort your return value in output
    """
    def dfs(self, nums, curlist, visit, res):
        if len(curlist) > len(nums):
            return
        if len(curlist) == len(nums):
            res.append(list(curlist))
            return
        for i in nums:
            if visit[i] == True:
                continue
            curlist.append(i)
            visit[i] = True
            self.dfs(nums, curlist, visit, res)
            visit[i] = False
            curlist.pop()

    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []
        visit = collections.defaultdict(bool)
        self.dfs(nums, [], visit, res)
        return res
```



#### 2. 全排列 II → **LeetCode 47. Permutations II**（有重复元素，去重）

```
class Solution:
    def dfs(self, nums, curlist, visit, res):
        if len(curlist) > len(nums):
            return
        if len(curlist) == len(nums):
            res.append(curlist[:])
        
        for i in range(len(nums)):
            if i in visit:
                continue
            if i > 0 and nums[i - 1] == nums[i] and (i - 1) not in visit:
                continue
            curlist.append(nums[i])
            visit.append(i)
            self.dfs(nums, curlist, visit, res)
            visit.pop()
            curlist.pop()
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()
        self.dfs(nums, [], [], res)
        return res
```

```python
i > 0 and nums[i - 1] == nums[i] and (i - 1) not in visit
```

| 部分                   | 含义                                                         |
| ---------------------- | ------------------------------------------------------------ |
| `i > 0`                | 避免 `i-1` 越界（只有第 2 个及以后元素才需要判断重复）       |
| `nums[i-1] == nums[i]` | 当前元素和前一个元素值相同（是重复元素）                     |
| `(i-1) not in visit`   | 前一个重复元素**未被选中**（说明是「同一层遍历」遇到重复，而非递归深层） |

**核心逻辑：区分「同一层重复」和「不同层重复」**

全排列去重的关键是：

- ❌ **同一层重复**：比如第一层遍历选第 1 个`1`，和选第 2 个`1`，会生成完全一样的排列（如`[1,1,2]`），必须跳过；
- ✅ **不同层重复**：比如第一层选第 1 个`1`，第二层选第 2 个`1`，是合法的（排列需要包含所有元素），必须保留。





#### 3. 下一个排列 → **LeetCode 31. Next Permutation**（DFS 可解，更优为贪心，但 DFS 是通用思路）

a. 从后向前找到第一个升序nums[i] < nums[i  + 1], 存下i, 如果i不存在则说明是最后一个排列

b. 从后向前找第一个大于nums[i] 的j，存下j,

c. 交换nums[i], nums[j]

d. 将i + 1 到 len(nums) - 1的序列，逆序

```
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        m = len(nums)
        i = m - 2
        while i >= 0 and nums[i] >= nums[i + 1]:
            i -= 1
        if i >= 0:
            j = m - 1
            while j >= i and nums[j] <= nums[i]:
                j -= 1
            nums[i], nums[j] = nums[j], nums[i]

        left = i + 1
        right = m - 1
        while left < right:
            nums[left], nums[right] = nums[right], nums[left]
            left += 1
            right -= 1
```



#### 4. 字符串的排列 → **LeetCode 567. Permutation in String**（滑动窗口 + DFS 辅助判断，或纯 DFS）

```
class Solution:
    """
    @param s1: a string
    @param s2: a string
    @return: if s2 contains the permutation of s1
    """
    def check_inclusion(self, s1: str, s2: str) -> bool:
        if len(s1) > len(s2):
            return False
        m = len(s1)
        n = len(s2)
        h1 = dict()
        h2 = dict()
        for i in range(26):
            h1[chr(ord('a') + i)] = 0
            h2[chr(ord('a') + i)] = 0

        for i in range(m):
            h1[s1[i]] += 1
            h2[s2[i]] += 1

        if h1 == h2:
            return True

        for i in range(n - m):
            j = i + m
            h2[s2[i]] -= 1
            h2[s2[j]] += 1
            if h1 == h2:
                return True
        return False
```



### 子集问题（所有可能的子集）

#### 1. 子集 → **LeetCode 78. Subsets**（无重复元素）

```
class Solution:
    def dfs(self, nums, pre, curlist, res):
        if pre > len(nums):
            return
        
        res.append(curlist[:])

        for i in range(pre, len(nums)):
            curlist.append(nums[i])
            self.dfs(nums, i + 1, curlist, res)
            curlist.pop()

    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []
        self.dfs(nums, 0, [],res)
        return res
```

```
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []
        n = len(nums)
        
        def helper(i, tmp):
            res.append(tmp)
            for j in range(i, n):
                helper(j + 1,tmp + [nums[j]] )
        helper(0, [])
        return res  
```



#### 2. 子集 II → **LeetCode 90. Subsets II**（有重复元素，去重）

```
class Solution:
    def dfs(self, nums, idx, curlist, res):
        if len(curlist) > len(nums):
            return
        res.append(curlist[:])

        for i in range(idx, len(nums)):
            if i > idx and nums[i - 1] == nums[i]:
                continue
            curlist.append(nums[i])
            self.dfs(nums, i + 1, curlist, res)
            curlist.pop()

    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        res = []
        self.dfs(nums, 0, [], res)
        return res
```

```
from typing import List

class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        # 初始化结果集和路径（对应 Java 的 res 和 path）
        self.res = []
        self.path = []
        # 先排序（去重的前提，与 Java Arrays.sort 一致）
        nums.sort()
        # 开始回溯，起始索引为 0
        self.backtrack(0, nums)
        return self.res
    
    def backtrack(self, start: int, nums: List[int]) -> None:
        # 每次进入回溯就把当前路径加入结果集（子集问题的核心：所有路径都是解）
        self.res.append(self.path.copy())  # 对应 Java 的 new ArrayList<>(path)，深拷贝避免引用问题
        
        # 从 start 开始遍历，避免重复选择同一元素的不同顺序
        for i in range(start, len(nums)):
            # 去重逻辑：同一层遍历中，跳过与前一个元素相同的元素（i > start 保证不跳过同一元素的不同层）
            if i > start and nums[i] == nums[i-1]:
                continue
            # 选择当前元素
            self.path.append(nums[i])
            # 递归回溯，下一层起始索引为 i+1（不重复选当前及之前元素）
            self.backtrack(i + 1, nums)
            # 回溯：撤销选择（移除最后一个元素）
            self.path.pop()
```



#### 3. 递增子序列 → **LeetCode 491. Non-decreasing Subsequences**（子集 + 递增约束，去重）

非递减序列，相当于已经排序了，因此直接在同一层用set去重即可

基础款

```
class Solution:
    def dfs(self, nums, idx, curlist, res):
        if idx > len(nums):
            return
        if len(curlist) >= 2:
            res.append(curlist[:])
    
        used = set()
        for i in range(idx, len(nums)):
            if nums[i] in used:
                continue
            if len(curlist) and nums[i] < curlist[-1]:
                continue

            used.add(nums[i])
            curlist.append(nums[i])
            self.dfs(nums, i + 1, curlist, res)
            curlist.pop()
    def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        res = []
        self.dfs(nums, 0, [], res)
        return res
```

```
class Solution:
    """
    @param nums: an integer array
    @return: all the different possible increasing subsequences of the given array
             we will sort your return value in output
    """
    def dfs(self, nums, pre, curlist, last, res):
        if pre == len(nums):
            if curlist not in res and len(curlist) > 1:
                res.append(list(curlist))
            return

        if nums[pre] >= last:
            curlist.append(nums[pre])
            self.dfs(nums, pre + 1, curlist, nums[pre], res)
            curlist.pop()
        if nums[pre] != last:
            self.dfs(nums, pre + 1, curlist, last, res)

    def find_subsequences(self, nums: List[int]) -> List[List[int]]:
        res = []
        self.dfs(nums, 0, [], -math.inf, res)
        return res
```

使序列合法的办法非常简单，即给「选择」做一个限定条件，只有当前的元素大于等于上一个选择的元素的时候才能选择这个元素，这样枚举出来的所有元素都是合法的

那如何保证没有重复呢？我们需要给「不选择」做一个限定条件，只有当当前的元素不等于上一个选择的元素的时候，才考虑不选择当前元素，直接递归后面的元素。因为如果有两个相同的元素，我们会考虑这样四种情况：

前者被选择，后者被选择
前者被选择，后者不被选择
前者不被选择，后者被选择
前者不被选择，后者不被选择
其中第二种情况和第三种情况其实是等价的，我们这样限制之后，舍弃了第二种，保留了第三种，于是达到了去重的目的。

```
if (nums[cur] != last) {
	dfs(cur + 1, last, nums);
}
```

先把方法2段首的递归枚举子序列的通用模板理解了，这段代码就好理解了。
首先以[1,3,3,3]为例，本文的递归的方法如果不加处理的话，最后会产生的[1,3]重复序列实质上是，[1,3,0,0] [1,0,3,0][1,0,0,3]，因为在代码中是直接push_back的，所以看起来都是[1,3]。0的意思是不选择。
在处理后（加上上述代码后）,当递归到[1,3,x,x] （x的意思是，还没决定要不要选择）的时候，此时last = 3，cur = 2，如果不加上述关键的判断的话，他会继续进行x = 0（不选择）和 x = 3（选择）成为了[1,3,0,x]和[1,3,3,x]，上述的判断就是不能进行这个x=0的操作，因为我们发现当前的x应该等于 3，他是等于last的，因此就把x =0的这个分支去掉了，这样就避免了出现[1,3,0,0]这个，同理，在 [1,0,3,x]的时候去掉了x=0的分支，避免了出现[1,0,3,0]的情况，最后只留下[1,0,0,3] 这种[1,3]

### 路径搜索与回溯（DFS + 剪枝）

#### 1. 单词搜索 → **LeetCode 79. Word Search**（网格 DFS + 回溯，标记已访问）

```
class Solution:
    def isInBound(self, x, y, m, n):
        return 0 <= x < m and 0 <= y < n
        
    def dfs(self, board, word, x, y, depth, visit):
        if depth == len(word):
            return True
        m = len(board)
        n = len(board[0])
        dx = [0,0,1,-1]
        dy = [1,-1,0,0]

        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            if not self.isInBound(nx, ny, m, n) or visit[nx][ny] or board[nx][ny] != word[depth]:
                continue
            visit[nx][ny] = True
            if self.dfs(board, word, nx, ny, depth + 1, visit):
                return True
            visit[nx][ny] = False 

    def exist(self, board: List[List[str]], word: str) -> bool:
        m = len(board)
        n = len(board[0])

        for i in range(m):
            for j in range(n):
                if board[i][j] != word[0]:
                    continue
                visit = [[False] * n for _ in range(m)]
                visit[i][j] = True
                if self.dfs(board, word, i, j, 1, visit):
                    return True
        return False
```



#### 2. 单词搜索 II → **LeetCode 212. Word Search II**（Trie+DFS 优化）

```
class Trie:
    def __init__(self):
        self.children = [None] * 26
        self.isEnd = False
        self.word = ""
    def insert(self, word):
        cur = self
        for ch in word:
            idx = ord(ch) - ord('a')
            if not cur.children[idx]:
                cur.children[idx] = Trie()
            cur = cur.children[idx]
        cur.isEnd = True
        cur.word = word 

class Solution:
    def isInBound(self, x, y, m, n):
        return 0 <= x < m and 0 <= y < n
    def dfs(self, board, trie, x, y, visit, res):
        m = len(board)
        n = len(board[0])
        dx = [0,0,1,-1]
        dy = [1,-1,0,0]

        if trie.isEnd == True:
            res.append(trie.word)
            trie.isEnd = False

        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            if not self.isInBound(nx, ny, m, n) or visit[nx][ny] == True:
                continue
            targetChar = ord(board[nx][ny]) - ord('a')
            if not trie.children[targetChar]:
                continue
            visit[nx][ny] = True
            self.dfs(board, trie.children[targetChar], nx, ny, visit, res)
            visit[nx][ny] = False

    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        treeRoot = Trie()
        for w in words:
            treeRoot.insert(w)
    
        m = len(board)
        n = len(board[0])
        res = []
        for i in range(m):
            for j in range(n):
                targetChar = ord(board[i][j]) - ord('a')
                if not treeRoot.children[targetChar]:
                    continue
                visit = [[False] * n for _ in range(m)]
                visit[i][j] = True
                self.dfs(board, treeRoot.children[targetChar], i, j, visit, res)
        return res
        
```



#### 3. N 皇后 → **LeetCode 51. N-Queens**（经典回溯 + DFS 剪枝）

斜向的行和列的差，或者和，是一个固定的数，每次记录Q的时候把这个固定数也记录就可以了

方向一的斜线为从左上到右下方向，同一条斜线上的每个位置满足行下标与列下标之差相等，例如 (0,0) 和 (3,3) 在同一条方向一的斜线上。因此使用行下标与列下标之差即可明确表示每一条方向一的斜线。

```
class Solution:
    def __init__(self):
        self.col = []
        self.diag1 = []
        self.diag2 = []
        self.queenPos = []
    def dfs(self, n, row, res):
        if n == row:
            res.append(self.queenPos[:])
            return
        for i in range(n):
            if i in self.col or (row + i) in self.diag1 or (row - i) in self.diag2:
                continue
            self.col.append(i)
            self.diag1.append(row + i)
            self.diag2.append(row - i)
            self.queenPos.append(i)
            self.dfs(n, row + 1, res)
            self.queenPos.pop()
            self.diag1.pop()
            self.diag2.pop()
            self.col.pop()

    def solveNQueens(self, n: int) -> List[List[str]]:
        if n == 0:
            return []
        res = []
        self.dfs(n, 0, res)
        ans = []
        for qpos in res:
            board = []
            for i in range(n):
                srow = ["Q" if j == qpos[i] else "." for j in range(n)]
                board.append("".join(srow))
            ans.append(board)
        return ans
```



#### 4. N 皇后 II → **LeetCode 52. N-Queens II**（统计解的数量，DFS 剪枝）

#### 5. 解数独 → **LeetCode 37. Sudoku Solver**（DFS + 回溯 + 剪枝）

考虑行，列，9个3*3方块

```
class Solution:
    """
    @param board: the sudoku puzzle
    @return: nothing
    """
    def __init__(self):
        # 将tag变量放在__init__中，避免多个实例共享状态
        self.rowtag = [[False] * 10 for _ in range(9)]
        self.coltag = [[False] * 10 for _ in range(9)]
        self.celltag = [[[False] * 10 for _ in range(3)] for _ in range(3)]
    
    def dfs(self, board, x, y):
        # 先判断是否当前列已遍历完（x越界），推进到下一列
        if x == 9:
            y += 1
            x = 0  # 下一列从第0行开始
        # 若列也遍历完（y=9），说明数独已解完
        if y == 9:
            return True
        # 若当前格子已有数字，直接递归下一格（x+1, y）
        if board[x][y] != 0:
            return self.dfs(board, x + 1, y)  # 必须return结果，否则会继续执行后续逻辑
        # 尝试填充1-9
        for num in range(1, 10):
            # 检查行、列、单元格是否可用
            if self.rowtag[x][num] or self.coltag[y][num] or self.celltag[x//3][y//3][num]:
                continue
            # 放置数字并标记
            board[x][y] = num
            self.rowtag[x][num] = True
            self.coltag[y][num] = True
            self.celltag[x//3][y//3][num] = True
            # 递归下一格，若成功则返回True
            if self.dfs(board, x + 1, y):
                return True
            # 回溯：移除数字并取消标记
            board[x][y] = 0
            self.rowtag[x][num] = False
            self.coltag[y][num] = False
            self.celltag[x//3][y//3][num] = False
        # 若所有数字都无法填充，返回False
        return False

    def solve_sudoku(self, board: List[List[int]]):
        # 初始化tag数组（标记已有数字）
        for i in range(9):
            for j in range(9):
                if board[i][j] != 0:
                    num = board[i][j]
                    self.rowtag[i][num] = True
                    self.coltag[j][num] = True
                    self.celltag[i//3][j//3][num] = True
        # 从(0,0)开始递归求解
        self.dfs(board, 0, 0)
```



#### 6. 分割回文串 → **LeetCode 131. Palindrome Partitioning**（DFS 分割 + 回文判断）

从字符串index的位置开始向后for循环，找到第一个pal的时候，从下一个index+1开始继续查找下一个pal

```
class Solution:
    """
    @param: s: A string
    @return: A list of lists of string
    """
    def isPal(self, s):
        l = 0
        r = len(s) - 1
        while l < r:
            if s[l] != s[r]:
                return False
            l += 1
            r -= 1
        return True
    def dfs(self, s, cur, curlist, res):
        if cur == len(s):
            res.append(list(curlist))
            return
        
        for i in range(cur, len(s)):
            tmp = s[cur: i + 1]
            if not self.isPal(tmp):
                continue
            curlist.append(tmp)
            self.dfs(s, i + 1, curlist, res)
            curlist.pop()

    def partition(self, s):
        res = []
        self.dfs(s, 0, [], res)
        return res
```



#### 7. 分割回文串 II → **LeetCode 132. Palindrome Partitioning II**（DFS + 动态规划优化）

### 其他高频 DFS 题

#### 1. 目标和 → **LeetCode 494. Target Sum**（DFS + 回溯，或动态规划）

```
class Solution:
    """
    @param nums: the given array
    @param s: the given target
    @return: the number of ways to assign symbols to make sum of integers equal to target S
    """
    def __init__(self):
        self.res = 0
    def dfs(self, nums, s, idx, cur):
        if idx == len(nums):
            # 遍历完后再检查和是否等于目标
            if cur == s:
                self.res += 1
            return

        self.dfs(nums, s, idx + 1, cur + nums[idx])
        self.dfs(nums, s, idx + 1, cur - nums[idx])

    def find_target_sum_ways(self, nums: List[int], s: int) -> int:
        self.dfs(nums, s, 0, 0)
        return self.res
```

```
    def find_target_sum_ways(self, nums: List[int], s: int) -> int:
        # 使用lru_cache需要将参数转为不可变类型，这里用辅助函数处理
        from functools import lru_cache
        
        @lru_cache(maxsize=None)
        def dfs(idx, cur_sum):
            # 终止条件：处理完所有元素
            if idx == len(nums):
                return 1 if cur_sum == s else 0
            # 递归：加当前数 或 减当前数，两种情况的和
            return dfs(idx + 1, cur_sum + nums[idx]) + dfs(idx + 1, cur_sum - nums[idx])
        
        return dfs(0, 0)
```



#### 2. 不同的二叉搜索树 II → **LeetCode 95. Unique Binary Search Trees II**（DFS 构造）

```
 class Solution {
        /*
        dp[i] = i个不同的数组成的二叉搜索数的个数
        假设 i = 5
        当根节点等于 1 时 ，其余数字都比1大，只能在右边 dp[i] += dp[4]
        当根节点等于 2 时，左边有一个1比2小，右边有三个比2大的数字 dp[i] += dp[1] * dp[3]
        当根节点等于 3 时，左边有两个数比3小，右边有两个数比3大的数字 dp[i] += dp[2] * dp[2]
        ...
        知道根节点等于5，左边有4个数字比5小，只能放在5的左边,dp[i] += dp[4]
         */
        public int numTrees(int n) {
            int[] dp = new int[n + 1];
            dp[0] = 1;
            dp[1] = 1;
            for (int i = 2; i <= n; i++) {
                for (int j = 1; j <= i; j++) {
                    int leftNum = dp[j - 1];
                    int rightNum = dp[i - j];
                    dp[i] += leftNum * rightNum;
                }
            }
            return dp[n];
        }
    }
```

1. `dp[i]` 表示节点数为 `i` 的不同二叉搜索树的数量。

2. `dp[0]` = 1：当没有节点时，只有一种空树。`dp[1]` = 1：当只有一个节点时，只有一种单节点树。

3. - 对于节点数 `i`，尝试每一个可能的节点作为根节点。
    - 设根节点为 `j`（`1 <= j <= i`），那么：
        - 左子树有 `j - 1` 个节点。 右子树有 `i - j` 个节点。
    - 所以，左子树和右子树的组合数是 `dp[j - 1] * dp[i - j]`。
    - 不同的根节点会产生不同的树形结构，需要将这些组合数累加到 `dp[i]`。

4. `dp[n]` 就是节点数为 `n` 的所有不同二叉搜索树的数量。

    

#### 3. 二叉树的序列化与反序列化 → **LeetCode 297. Serialize and Deserialize Binary Tree**（DFS 递归序列化）

序列化：BFS， 反序列化：快慢指针

#### 4. 最长递增路径 → **LeetCode 329. Longest Increasing Path in a Matrix**（网格 DFS + 记忆化）

#### Clone Graph

```
class Solution:
    """
    @param node: A undirected graph node
    @return: A undirected graph node
    """
    def getnodes(self, root):
        res = []
        visit = [root]
        q = collections.deque([root])
        while len(q) != 0:
            cur = q.popleft()
            res.append(cur)
            for n in cur.neighbors:
                if n not in visit:
                    q.append(n)
                    visit.append(n)
        return res


    def clone_graph(self, node: UndirectedGraphNode) -> UndirectedGraphNode:
        if node is None:
            return node
        nodes = self.getnodes(node)
        print(len(nodes))
        mapping = {}
        for n in nodes:
            mapping[n] = UndirectedGraphNode(n.label)
        
        for n in nodes:
            for nb in n.neighbors:
                mapping[n].neighbors.append(mapping[nb])
        return mapping[node]
```

```
/**
 * Definition for undirected graph.
 * struct UndirectedGraphNode {
 *     int label;
 *     vector<UndirectedGraphNode *> neighbors;
 *     UndirectedGraphNode(int x) : label(x) {};
 * };
 */

class Solution {
public:
    /**
     * @param node: A undirected graph node
     * @return: A undirected graph node
     */
    UndirectedGraphNode* cloneGraph(UndirectedGraphNode* node) {
        if (!node)
            return nullptr;
        queue<UndirectedGraphNode*> q;
        q.push(node);
        unordered_map<int, UndirectedGraphNode*> visit;
        UndirectedGraphNode* root = new UndirectedGraphNode(node->label);
        visit[node->label] = root;
        while (!q.empty())
        {
            auto cur = q.front(); q.pop();
            for (auto n : cur->neighbors)
            {
                if (!visit.count(n->label))
                {
                    UndirectedGraphNode* t = new UndirectedGraphNode(n->label);
                    visit[n->label] = t;
                    visit[cur->label]->neighbors.push_back(t);
                    q.push(n);
                }
                else
                {
                    visit[cur->label]->neighbors.push_back(visit[n->label]);
                }
            }
        }
        return root;
    }
};
```

```

class Solution {
public:
    /**
     * @param node: A undirected graph node
     * @return: A undirected graph node
     */
    UndirectedGraphNode* dfs(UndirectedGraphNode* node, unordered_map<int, UndirectedGraphNode*>& visit)
    {
        if (!node)
            return nullptr;
        
        auto it = visit.find(node->label);
        if (it == visit.end())
        {
            UndirectedGraphNode* current = new UndirectedGraphNode(node->label);
            visit.insert(make_pair(current->label, current));
            for (auto c : node->neighbors)
            {
                UndirectedGraphNode* child = dfs(c, visit);
                current->neighbors.push_back(child);
                visit.insert(make_pair(child->label, child));
            }
        }

        return node;
    }

    UndirectedGraphNode* cloneGraph(UndirectedGraphNode* node) {
        if (!node)
        {
            return nullptr;
        }

        unordered_map<int, UndirectedGraphNode*> visit;
        return dfs(node, visit);
    }
};
```



#### Word Ladder

```
    def ladder_length(self, start: str, end: str, dict: Set[str]) -> int:
        dict.add(end)
        inc = "abcdefghijklmnopqrstuvwxyz"
        q = collections.deque([start])
        dist = {}
        dist[start] = 1
        while len(q) > 0:
            cur = q.popleft()
            if cur == end:
                return dist[cur]
            for i in range(len(cur)):
                for c in inc:
                    tmp = cur[:i] + str(c) + cur[i + 1:]
                    if tmp in dist or tmp not in dict:
                        continue
                    dist[tmp] = dist[cur] + 1
                    q.append(tmp)
        return -1
```



#### 178 · Graph Valid Tree

1. 边数 == node数 - 1  2. 连通

```
    def valid_tree(self, n: int, edges: List[List[int]]) -> bool:
        if len(edges) != nnum - 1:
            return False
        d = collections.defaultdict(list)
        for e in edges:
            d[e[0]].append(e[1])
            d[e[1]].append(e[0])
        q = collections.deque([0])
        visit = [0]
        while len(q) != 0:
            cur = q.popleft()

            for n in d[cur]:
                if n not in visit:
                    visit.append(n)
                    q.append(n)
        return len(visit) == nnum
```

# 宽搜路径回溯

```
from collections import deque

def bfs_maze_path_optimized(maze: list[list[int]]) -> list[tuple[int, int]]:
    if not maze or maze[0][0] == 1:
        return []
    
    m, n = len(maze), len(maze[0])
    dirs = [(-1,0), (1,0), (0,-1), (0,1)]
    queue = deque()
    queue.append((0, 0))
    visited = [[False]*n for _ in range(m)]
    visited[0][0] = True
    # 父节点字典：key=(x,y), value=(父x, 父y)
    parent = {}
    
    # 第一步：BFS 遍历，记录父节点
    while queue:
        x, y = queue.popleft()
        
        if x == m-1 and y == n-1:
            break
        
        for dx, dy in dirs:
            nx, ny = x + dx, y + dy
            if 0 <= nx < m and 0 <= ny < n and maze[nx][ny] == 0 and not visited[nx][ny]:
                visited[nx][ny] = True
                parent[(nx, ny)] = (x, y)  # 记录父节点
                queue.append((nx, ny))
    
    # 第二步：从终点回溯到起点
    path = []
    current = (m-1, n-1)
    # 若终点无父节点，说明无路径
    if current not in parent and current != (0,0):
        return []
    
    # 回溯：从终点到起点
    while current in parent:
        path.append(current)
        current = parent[current]
    path.append((0, 0))
    # 反转：得到从起点到终点的路径
    path.reverse()
    
    return path
```

