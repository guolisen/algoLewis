### 一、二叉树遍历（基础核心）

1. **LeetCode 144. Binary Tree Preorder Traversal（前序遍历）**
    - **题目描述**：给定二叉树的根节点，返回其节点值的前序遍历结果（遍历顺序：根节点 → 左子树 → 右子树）。
    - **示例**：输入二叉树 `1->null->2->3`（根 1，右子树 2，2 的左子树 3），输出 `[1,2,3]`。
    - 思路：递归法（根 - 左 - 右顺序访问）；迭代法（用栈，先压根，再循环弹出栈顶，压右子树、左子树）。
    
2. **LeetCode 94. Binary Tree Inorder Traversal（中序遍历）**
    - **题目描述**：给定二叉树的根节点，返回其节点值的中序遍历结果（遍历顺序：左子树 → 根节点 → 右子树）。
    - **示例**：输入二叉树 `1->null->2->3`，输出 `[1,3,2]`。
    - 思路：递归法（左 - 根 - 右顺序）；迭代法（用栈，先将左子树全部入栈，弹出栈顶访问根，再处理右子树）。
    
3. **LeetCode 145. Binary Tree Postorder Traversal（后序遍历）**
    - **题目描述**：给定二叉树的根节点，返回其节点值的后序遍历结果（遍历顺序：左子树 → 右子树 → 根节点）。
    - **示例**：输入二叉树 `1->null->2->3`，输出 `[3,2,1]`。
    - 思路：递归法（左 - 右 - 根顺序）；迭代法（用栈，类似前序但调整顺序为根 - 右 - 左，最后反转结果）。
    
4. **LeetCode 102. Binary Tree Level Order Traversal（层序遍历）**
    - **题目描述**：给定二叉树的根节点，返回其节点值的层序遍历结果（按层级从左到右访问，结果为二维列表，每层一个子列表）。
    - **示例**：输入二叉树 `3->9->20->null->null->15->7`，输出 `[[3],[9,20],[15,7]]`。
    - 思路：BFS（队列实现，每层节点依次入队，遍历并记录）；DFS 也可实现但 BFS 更直观。
    
5. **LeetCode 103. Binary Tree Zigzag Level Order Traversal（锯齿形层序遍历）**
    - **题目描述**：给定二叉树的根节点，返回其节点值的锯齿形层序遍历结果（奇数层从左到右，偶数层从右到左，结果为二维列表）。
    - **示例**：输入二叉树 `3->9->20->null->null->15->7`，输出 `[[3],[20,9],[15,7]]`。
    - 思路：基于层序遍历，用队列记录每层节点，奇数层正序、偶数层逆序（或用双端队列调整插入顺序）。
    
6. **LeetCode 987. Vertical Order Traversal of a Binary Tree（垂直遍历）**
    - **题目描述**：给定二叉树的根节点，按 “垂直列” 遍历节点（根节点列索引为 0，左子树列索引 - 1，右子树列索引 + 1），同列节点按行索引（深度）升序排列，行索引相同则按节点值升序排列，返回结果为二维列表。
    
    - **示例**：输入二叉树 `3->9->20->null->null->15->7`，输出 `[[9],[3,15],[20],[7]]`。
    
    - 思路：hash[val] = col
    
        ```
            queue<pair<TreeNode*, int>> q;
            q.push({root, 0});
            map<int, vector<int>> hash;
            while (!q.empty())
            {
                auto cur = q.front(); q.pop();
                hash[cur.second].push_back(cur.first->val);
                if (cur.first->left){
                    q.push({cur.first->left, cur.second - 1});
                }
                if (cur.first->right){
                    q.push({cur.first->right, cur.second + 1});
                }
            }
        
            vector<vector<int>> res;
            for (auto v : hash)
            {
                res.push_back(v.second);
            }
            return res;
        ```
    
        

### 二、二叉树结构与属性判断

1. **LeetCode 101. Symmetric Tree（判断二叉树是否对称）**
    - **题目描述**：给定二叉树的根节点，判断该树是否是对称的（即镜像对称，左子树与右子树镜像相同）。
    
    - **示例**：输入 `1->2->2->3->4->4->3`，返回 `true`；输入 `1->2->2->null->3->null->3`，返回 `false`。
    
    - 思路：递归法（比较左子树的左与右子树的右、左子树的右与右子树的左是否对称）；迭代法（用队列，成对入队对称节点，依次比较）。
    
        ```
            bool issym(TreeNode* left, TreeNode* right)
            {
                if ((!left && right) || (left && !right))   // 有一边是nullptr肯定不是对称，return false
                    return false;
                if (!left && !right)
                    return true;
                if (left->val != right->val)
                    return false;
                return issym(left->left, right->right) && issym(left->right, right->left);
            }
        	return issym(root->left, root->right);
        ```
    
        
    
2. **LeetCode 104. Maximum Depth of Binary Tree（二叉树的最大深度）**
    - **题目描述**：给定二叉树的根节点，返回该树的最大深度（根节点到最远叶子节点的最长路径上的节点数）。
    
    - **示例**：输入 `3->9->20->null->null->15->7`，返回 `3`。
    
    - 思路：递归法（根节点深度为 1 + max (左子树深度，右子树深度)）；BFS 法（层序遍历的层数即为最大深度）。
    
    - 先序计数
    
        ```
                if (root == nullptr)
                    return;
                maxdepth = max(maxdepth, depth);
                postorder(root->left, depth + 1);
                postorder(root->right, depth + 1);
        ```
    
        
    
3. **LeetCode 111. Minimum Depth of Binary Tree（二叉树的最小深度）**
   
    - **题目描述**：给定二叉树的根节点，返回该树的最小深度（根节点到最近叶子节点的最短路径上的节点数）。
    
    - **示例**：输入 `3->9->20->null->null->15->7`，返回 `2`（根 3 到叶子 9 的路径长度）。
    
    - 思路：递归法（注意叶子节点定义，若左 / 右子树为空，深度为 1 + 非空子树深度）；BFS 法（遇到第一个叶子节点时的层数即为最小深度）。
    
    - 后序，如果root == None return true, 如果l，r都返回true则计算dept是否为最小
    
        **判断是不是leaf，然后是的话后续操作的模板**
    
        ```
                if (root == nullptr)
                    return true;
                auto l = postorder(root->left, depth + 1);
                auto r = postorder(root->right, depth + 1);
                if (l && r)
                    mindepth = min(mindepth, depth);
        
                return false;
        ```
    
        
    
4. **LeetCode 110. Balanced Binary Tree（判断平衡二叉树）**
    - **题目描述**：给定二叉树的根节点，判断该树是否为平衡二叉树（每个节点的左右子树高度差不超过 1）。
    - **示例**：输入 `3->9->20->null->null->15->7`，返回 `true`；输入 `1->2->2->3->3->null->null->4->4`，返回 `false`。
    - 思路：递归法，同时计算每个节点的高度，若左右子树高度差 > 1 则不平衡；或后序遍历，自底向上判断。
    - 平衡二叉树，不是BST，只需要判断两个子树高度差1即可， 后序
    
    ```
        int postorder(TreeNode* root, int depth)
        {
            if (root == nullptr)
                return depth;
    
            int l = postorder(root->left, depth + 1);
            int r = postorder(root->right, depth + 1);
            if (abs(l - r) > 1)
            {
                res = false;
            }
    
            return max(l, r);
        }
    ```
    
    
    
5. **LeetCode 958. Check Completeness of a Binary Tree（判断完全二叉树）**
    - **题目描述**：给定二叉树的根节点，判断该树是否为完全二叉树（除最后一层外，每层节点全满，最后一层节点从左到右连续排列，无空缺）。
    
    - **示例**：输入 `1->2->3->4->5->6`，返回 `true`；输入 `1->2->3->4->5->null->7`，返回 `false`（最后一层 6 缺失，7 在右侧）。
    
    - 思路：层序遍历，若出现空节点后还有非空节点，则不是完全二叉树。
    
    -    宽搜，如果有left,right是null 就标记flag = true, 后面再遇到不空的就认为不是完全二叉树
    
        ```
        while(q)
        {
        	// left
        	if(cur.left)
        		if (flag == true)
        			return false
        		q.push(cur.left)
        	else
        		flag = true
        	//----------------------------------
        	// right
        	if(cur.right)
        		if (flag == true)
        			return false
        		q.push(cur.right)
        	else
        		flag = true
        }
        ```
    
        
    
6. **LeetCode 98. Validate Binary Search Tree（判断二叉搜索树）**
    - **题目描述**：给定二叉树的根节点，判断该树是否为二叉搜索树（BST：左子树所有节点值 <根节点值，右子树所有节点值> 根节点值，且左右子树均为 BST）。
    
    - **示例**：输入 `2->1->3`，返回 `true`；输入 `5->1->4->null->null->3->6`，返回 `false`（4 的左子树 3 < 5 不满足）。
    
    - 思路：递归法（中序遍历，记录前驱节点值，确保当前节点值大于前驱）；或递归时传递上下界，确保节点值在合法区间。
    
        先序   ； 参数： root , min, max
    
        ```
        class Solution:
            def dfs(self, root, minv, maxv):
                if root == None:
                    return True
                if root.val <= minv or root.val >= maxv:
                    return False
                
                return self.dfs(root.left, minv, root.val) and self.dfs(root.right, root.val, maxv)
        
            def is_valid_b_s_t(self, root: TreeNode) -> bool:
                return self.dfs(root, -math.inf, math.inf)
        ```
    
        
    
7. **LeetCode 543. Diameter of Binary Tree（二叉树的直径）**
    - **题目描述**：给定二叉树的根节点，返回该树的直径（任意两节点之间的最长路径长度，路径可不经过根节点，长度为路径上的边数）。
    
    - **示例**：输入 `1->2->3->4->5`，返回 `3`（路径 4-2-1-3 或 5-2-1-3，边数 3）。
    
    - 思路：递归法，计算每个节点的 “左深度 + 右深度”，取最大值即为直径。
    
        直径：左子树的最深长度，加上右子树最深长度，加1
    
        ```
                if (root == nullptr)
                    return 0;
                int l = postorder(root->left, res);
                int r = postorder(root->right, res);
        
                if (res < (l + r + 1))
                {
                    res = l + r + 1;
                }
        
                return max(l + 1, r + 1);
                
        ```
    
        
    
8. **LeetCode 563. Binary Tree Tilt（二叉树的坡度）**
    - **题目描述**：给定二叉树的根节点，计算整个树的坡度（每个节点的坡度 = 左子树所有节点值之和与右子树所有节点值之和的绝对差，总坡度为所有节点坡度之和）。
    
    - **示例**：输入 `1->2->3`，返回 `1`（节点 2 坡度 0，节点 3 坡度 0，节点 1 坡度 | 2-3|=1，总和 1）。
    
    - 思路：递归法，后序遍历计算每个节点的坡度（左右子树和的绝对差），并累加所有节点的坡度。
    
        ```
            int postorder(TreeNode* root, int& res)
            {
                if (root == nullptr)
                    return 0;
                int l = postorder(root->left, res);
                int r = postorder(root->right, res);
        
                res += abs(l - r);
                return l + r + root->val;
            }
        ```

### 三、二叉树路径问题

1. **LeetCode 112. Path Sum（路径总和）**
    - **题目描述**：给定二叉树的根节点和目标和 `targetSum`，判断是否存在从根节点到叶子节点的路径，该路径上所有节点值之和等于 `targetSum`。
    
    - **示例**：输入 `5->4->8->11->null->13->4->7->2->null->null->null->1`，`targetSum=22`，返回 `true`（路径 5-4-11-2 之和为 22）。
    
    - 思路：递归法，从根到叶子节点的路径和是否等于目标值；或 BFS，记录节点到根的路径和。
    
        用这个leaf判断模板计算sum
    
        ```
                if (root == nullptr)
                    return true;
                auto l = postorder(root->left, depth + 1);
                auto r = postorder(root->right, depth + 1);
                if (l && r)
                    mindepth = min(mindepth, depth);
        
                return false;
        ```
    
        
    
2. **LeetCode 113. Path Sum II（路径总和 II）**(同上)
    - **题目描述**：给定二叉树的根节点和目标和 `targetSum`，找出所有从根节点到叶子节点的路径，其节点值之和等于 `targetSum`，返回路径列表（每个路径为节点值组成的列表）。
    - **示例**：输入同上，`targetSum=22`，输出 `[[5,4,11,2]]`。
    - 思路：递归法，回溯记录路径，当叶子节点路径和等于目标值时保存路径；或 BFS，同时记录路径和节点。
    
3. **LeetCode 687. Longest Univalue Path（最长同值路径）**
    - **题目描述**：给定二叉树的根节点，返回最长同值路径的长度（路径上所有节点值相同，长度为路径上的边数，路径可从任意节点出发，不一定要经过根）。
    
    - **示例**：输入 `5->4->5->1->1->null->5`，返回 `2`（右子树 5-5 的边数 2）。
    
    - 思路：递归法，计算每个节点的 “左同值链长度 + 右同值链长度”，取最大值；同值链长度为当前节点与子节点值相同时的长度 + 1。
    
        **先序遍历所有node，对于每个node再用后序遍历算相同的node数**
    
        ```
            int count(TreeNode* root, int val)
            {
                if(!root || root->val != val)
                    return 0;
                int l = count(root->left, val) + 1;
                int r = count(root->right, val) + 1;
        
                return max(l, r);
            }
            void dfs(TreeNode* root)
            {
                if (root == nullptr)
                    return;
                
                int res = count(root->left, root->val) + count(root->right, root->val);
                if (res > maxlen)
                    maxlen = res;
                dfs(root->left);
                dfs(root->right);
        
            }
        ```
    
        
    
4. **LeetCode 124. Binary Tree Maximum Path Sum（二叉树中的最大路径和）**
   
    - **题目描述**：给定二叉树的根节点，返回该树中最大的路径和（路径可从任意节点出发，到达任意节点，路径至少包含一个节点，节点值可正可负）。
    
    - **示例**：输入 `1->2->3`，返回 `6`（路径 2-1-3 之和）；输入 `-10->9->20->15->7`，返回 `42`（路径 15-20-7 之和）。
    
    - 思路：递归法，计算每个节点的 “最大贡献值”（节点值 + max (左贡献，右贡献，0)），同时更新全局最大路径和（节点值 + 左贡献 + 右贡献）。
    
    - 后序
    
        ```
            int countMax(TreeNode * root, int& maxVal)
            {
                if (!root)
                    return 0;
                
                int leftsum = countMax(root->left, maxVal);
                if (leftsum < 0)   // 如果小于零肯定不会增加最后的结果，因此直接忽略
                    leftsum = 0;
                int rightsum = countMax(root->right, maxVal);
                if (rightsum < 0)  // 如果小于零肯定不会增加最后的结果，因此直接忽略
                    rightsum = 0;
                maxVal = max(maxVal, root->val + leftsum + rightsum);
        
                return max(root->val + leftsum, root->val + rightsum);
            }
        ```
    
        
    
5. **LeetCode 257. Binary Tree Paths（二叉树的所有路径）**
    - **题目描述**：给定二叉树的根节点，返回所有从根节点到叶子节点的路径，路径以字符串形式表示（如 `"1->2->5"`）。
    - **示例**：输入 `1->2->3->null->5`，输出 `["1->2->5", "1->3"]`。
    - 思路：递归法，回溯记录路径，到达叶子节点时将路径转为字符串保存；或 BFS，同时记录节点和路径。

### 四、二叉树构造与修改

1. **LeetCode 105. Construct Binary Tree from Preorder and Inorder Traversal（从前序与中序遍历序列构造二叉树）**
   
    - **题目描述**：给定二叉树的前序遍历数组 `preorder` 和中序遍历数组 `inorder`，构造并返回该二叉树。
    
    - **示例**：`preorder = [3,9,20,15,7]`，`inorder = [9,3,15,20,7]`，返回根节点为 3，左子树 9，右子树 20（20 的左右子树 15、7）。
    
    - 思路：前序的第一个元素是根，在中序中找到根的位置，划分左右子树区间，递归构造左右子树。
    
        ```
                if len(preorder) == 0 or len(inorder) == 0:
                    return None
                if len(preorder) == 1:
                    return TreeNode(preorder[0])
        
                curRoot = TreeNode(preorder[0])
                idx = inorder.index(preorder[0])
                curRoot.left = self.dfs(preorder[1:idx + 1], inorder[:idx])
                curRoot.right = self.dfs(preorder[idx + 1:], inorder[idx + 1:])
                return curRoot
        ```
    
        
    
2. **LeetCode 106. Construct Binary Tree from Inorder and Postorder Traversal（从中序与后序遍历序列构造二叉树）**
    - **题目描述**：给定二叉树的中序遍历数组 `inorder` 和后序遍历数组 `postorder`，构造并返回该二叉树。
    
    - **示例**：`inorder = [9,3,15,20,7]`，`postorder = [9,15,7,20,3]`，返回同上的二叉树。
    
    - 思路：后序的最后一个元素是根，在中序中找到根的位置，划分左右子树区间，递归构造左右子树。
    
        ```
                if postorder == None or len(postorder) == 0:
                    return None
                if len(postorder) == 1:
                    return TreeNode(postorder[0])
        
                curNode = TreeNode(postorder[-1])
                idx = inorder.index(postorder[-1])
        
                curNode.left = self.dfs(inorder[:idx], postorder[:idx])
                curNode.right = self.dfs(inorder[idx + 1:], postorder[idx: -1])
                return curNode
        ```
    
        
    
3. **LeetCode 654. Maximum Binary Tree（最大二叉树）**
   
    - **题目描述**：给定一个不含重复元素的整数数组 `nums`，构造最大二叉树（根为数组中的最大值，左子树为最大值左侧子数组构造的最大二叉树，右子树为右侧子数组构造的最大二叉树）。
    
    - **示例**：`nums = [3,2,1,6,0,5]`，返回根为 6，左子树根 3（右子树 2，2 的右子树 1），右子树根 5（左子树 0）。
    
    - 思路：递归法，在数组中找到最大值作为根，划分左右子数组，递归构造左右子树。
    
        用上两题的模板
    
        ```
            def dfs(self, nums):
                if len(nums) == 0:
                    return None
                if len(nums) == 1:
                    return TreeNode(nums[0])
        
                idx = nums.index(max(nums))
                curNode = TreeNode(nums[idx])
                curNode.left = self.dfs(nums[:idx])
                curNode.right = self.dfs(nums[idx + 1:])
                return curNode
        ```
    
        
    
4. **LeetCode 617. Merge Two Binary Trees（合并二叉树）**
   
    - **题目描述**：给定两个二叉树 `root1` 和 `root2`，合并为一个新二叉树（若两节点重叠，新节点值为两节点值之和；若只有一个节点存在，新节点为该节点）。
    
    - **示例**：`root1 = 1->3->2->5`，`root2 = 2->1->3->null->4->null->7`，合并后根为 3，左子树 4（左 5，右 4），右子树 5（右 7）。
    
    - 思路：递归法，若两树节点都存在则值相加，否则取非空节点；或迭代法，用队列处理节点对。
    
        **用上面两题的模板**
    
    ```
        def dfs(self, t1, t2):
            if t1 == None:
                return t2
            if t2 == None:
                return t1
            
            curNode = TreeNode(t1.val + t2.val)
    
            curNode.left = self.dfs(t1.left, t2.left)
            curNode.right = self.dfs(t1.right, t2.right)
    
            return curNode
    ```
    
    
    
5. **LeetCode 226. Invert Binary Tree（翻转二叉树）**
    - **题目描述**：给定二叉树的根节点，翻转该二叉树（交换每个节点的左右子树）。
    
    - **示例**：输入 `4->2->7->1->3->6->9`，输出 `4->7->2->9->6->3->1`。
    
    - 思路：递归法，交换左右子树后递归翻转；或迭代法，用队列层序遍历，交换每个节点的左右子树。
    
    - **后序遍历**
    
        ```
            def dfs(self, root):
                if root == None:
                    return
                self.dfs(root.left)
                self.dfs(root.right)
                root.left, root.right = root.right, root.left
        ```
    
        
    
6. **LeetCode 669. Trim a Binary Search Tree（修剪二叉搜索树）**
   
    - **题目描述**：给定二叉搜索树的根节点和范围 `[low, high]`，修剪该树使所有节点值都在 `[low, high]` 内（修剪后的树仍为 BST）。
    
    - **示例**：输入 `3->0->4->null->2->null->null->1`，`low=1`，`high=3`，输出 `3->2->null->1`。
    
    - 思路：递归法，若根节点值小于 low 则修剪右子树；若大于 high 则修剪左子树；否则递归修剪左右子树。
    
        重新构造
    
        ```
            def dfs(self, root, minimum, maximum):
                if root == None:
                    return None
                curNode = None
                if minimum <= root.val and root.val <= maximum:
                    curNode = TreeNode(root.val)
                else:
                    if root.val < minimum:
                        return self.dfs(root.right, minimum, maximum)   # root小于min，则root和root左边的树，都剪掉
                    elif root.val >= maximum:
                        return self.dfs(root.left, minimum, maximum)    # root大于max，则root和root右边的树，都剪掉
                
                curNode.left = self.dfs(root.left, minimum, maximum)
                curNode.right = self.dfs(root.right, minimum, maximum)
        
                return curNode
        ```
    
        

### 五、二叉搜索树（BST）专项

1. **LeetCode 235. Lowest Common Ancestor of a Binary Search Tree（二叉搜索树的最近公共祖先）**
   
    - **题目描述**：给定二叉搜索树的根节点和两个节点 `p`、`q`，找到它们的最近公共祖先（LCA：两节点的公共祖先中最深的那个）。
    
    - **示例**：输入 BST `6->2->8->0->4->7->9->null->null->3->5`，`p=2`，`q=8`，返回 `6`；`p=2`，`q=4`，返回 `2`。
    
    - 思路：利用 BST 性质，若根节点值在 p、q 之间则是公共祖先；若根节点值大于 p、q 则递归左子树；否则递归右子树。
    
        ```
            def dfs(self, root, p, q):
                if root == None:
                    return None
                if root == p or root == q:
                    return root
                if root.val >= p.val and root.val >= q.val:
                    return self.dfs(root.left, p, q)
                elif root.val <= p.val and root.val <= q.val:
                    return self.dfs(root.right, p, q)
                return root
        ```
    
        ```
            def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
                ancestor = root
                while True:
                    if p.val < ancestor.val and q.val < ancestor.val:
                        ancestor = ancestor.left
                    elif p.val > ancestor.val and q.val > ancestor.val:
                        ancestor = ancestor.right
                    else:
                        break
                return ancestor
        ```
    

   1.1  **LeetCode 236. Lowest Common Ancestor of a Binary Tree **

后序遍历，只要有一个true最后返回true

    ```
        bool dfs(TreeNode* root, TreeNode* p, TreeNode* q) {
            if (root == nullptr) 
            	return false;
            bool lson = dfs(root->left, p, q);
            bool rson = dfs(root->right, p, q);
            if ((lson && rson) || ((root->val == p->val || root->val == q->val) && (lson || rson))) {
                ans = root;
            } 
            return lson || rson || (root->val == p->val || root->val == q->val);
        }
    ```



2. **LeetCode 700. Search in a Binary Search Tree（二叉搜索树中的搜索）**
   
    - **题目描述**：给定二叉搜索树的根节点和目标值 `val`，在树中搜索值为 `val` 的节点，返回该节点（若不存在返回 `null`）。
    - **示例**：输入 BST `4->2->7->1->3`，`val=2`，返回节点 `2`（及其子树）。
    - 思路：递归法，若根节点值等于目标则返回；若小于目标则递归右子树；否则递归左子树；或迭代法。
    
    ```
        def dfs(self, root, val):
            if root == None:
                return None
            if root.val < val:
                return self.dfs(root.right, val)
            elif root.val > val:
                return self.dfs(root.left, val)
            return root
    ```
    
3. **LeetCode 530. Minimum Absolute Difference in BST（二叉搜索树的最小绝对差）**
    - **题目描述**：给定二叉搜索树的根节点，返回树中任意两不同节点值之间的最小绝对差。
    
    - **示例**：输入 BST `4->2->6->1->3`，返回 `1`（2 和 3 的差）。
    
    - 思路：中序遍历 BST（有序），记录前驱节点值，计算当前节点与前驱的绝对差，取最小值。
    
        **对每个结点查找，最近大于(左子树的最右子树)，最近小于（右子树的最左子树），算出diff**
    
           ```
        class Solution:
            """
            @param root: the root
            @return: the minimum absolute difference between values of any two nodes
            """
            mindiff = 0x3f3f3f3f
            def count(self, root):
                if root.left:
                    p = root.left
                    while p.right:
                        p = p.right
                    self.mindiff = min(self.mindiff, abs(p.val - root.val))
                if root.right:
                    p = root.right
                    while p.left:
                        p = p.left
                    self.mindiff = min(self.mindiff, abs(p.val - root.val))
                return self.mindiff
        
            def dfs(self, root):
                if root == None:
                    return 0x3f3f3f3f
                self.count(root)
                self.dfs(root.left)
                self.dfs(root.right)
            def get_minimum_difference(self, root: TreeNode) -> int:
                self.dfs(root)
                return self.mindiff
           ```
    
           
    
4. **LeetCode 501. Find Mode in Binary Search Tree（二叉搜索树中的众数）**
    - **题目描述**：给定二叉搜索树的根节点，返回树中的所有众数（出现次数最多的元素，可能有多个）。
    - **示例**：输入 BST `1->null->2->2`，返回 `[2]`；输入 BST `0`，返回 `[0]`。
    - 思路：中序遍历（有序），统计连续相同值的次数，更新众数列表。
    - hash
    
    ```
        def dfs(self, root, h):
            if root == None:
                return
            h[root.val] += 1
            self.dfs(root.left, h)
            self.dfs(root.right, h)
    
        def find_mode(self, root: TreeNode) -> List[int]:
            if root == None:
                return None
            h = collections.defaultdict(int)
            self.dfs(root, h)
            freq = max(h.values())
            res = [k for k,v in h.items() if v == freq]
            return res
    ```
    
    
    
5. **LeetCode 538. Convert BST to Greater Tree（把二叉搜索树转换为累加树）**
   
    - **题目描述**：给定二叉搜索树的根节点，将其转换为累加树（每个节点的新值 = 原树中大于或等于该节点值的所有节点值之和）。
    
    - **示例**：输入 BST `5->2->13`，转换后为 `18->20->13`（5=5+13，2=2+5+13，13=13）。
    
    - 思路：反中序遍历（右 - 根 - 左），维护累加和，依次更新节点值为累加和。
    
        ```
        class Solution {
        public:
            int sum = 0;
            TreeNode* convertBST(TreeNode* root) {
                if (root != nullptr) {
                    convertBST(root->right);
                    sum += root->val;
                    root->val = sum;
                    convertBST(root->left);
                }
                return root;
            }
        };
        ```
    
        
    
    - 右边的都是大于当前的，遍历右 - 根 - 左
    
        每个节点需要考虑
    
        ``` 
                u
               /
             root
            /   \
           l     r
           
           1. root的val应该是 root.val + u + r , 因为u和r是比root大的数
           2. 当前返回应该是 root.val + l + r ， 这里要返回的是当前子树下面的所有数的和
        ```
    
    ```
        def dfs(self, root, u):
            if root == None:
                return 0
            r = self.dfs(root.right, u)
            root.val += r
            ret = root.val
            root.val += u
            l = self.dfs(root.left, root.val)
    
            return ret + l
    ```
    
    
    
6. **LeetCode 333. Largest BST Subtree（最大 BST 子树）** <<<
   
    - **题目描述**：给定二叉树的根节点，找到其中最大的二叉搜索树（BST）子树，返回该子树的节点数（若整棵树是 BST，则返回总节点数）。
    
    - **示例**：输入 `10->5->15->1->8->null->7`，最大 BST 子树为 `5->1->8`，返回 `3`。
    
    - 思路：递归法，判断当前子树是否为 BST，同时记录 BST 的大小、最小值、最大值，更新全局最大 BST 子树。
    
           判断是否是BST树，1. 左右子树都是BST  2. 当前节点的值大于左子树中的最大值 3. 当前节点的值小于右子树的最小值
           
           ```
            def dfs(self, root):
                if root == None:
                    return True, 0, -math.inf, math.inf
            
                lbst, lsize, lmax, lmin = self.dfs(root.left)
                rbst, rsize, rmax, rmin = self.dfs(root.right)
                bst = lbst and rbst and root.val > lmax and root.val < rmin
            
                bstNodeSize = 0
                if bst:
                    bstNodeSize = lsize + rsize + 1
                else:
                    bstNodeSize = max(lsize, rsize)
                retmax = max(root.val, max(lmax, rmax))
                retmin = min(root.val, min(lmin, rmin))
                return bst, bstNodeSize, retmax, retmin
       
       
       ​         
            def largest_b_s_t_subtree(self, root: TreeNode) -> int:
                if root == None:
                    return 0
                bst, msize, retmax, retmin = self.dfs(root)
                return msize
           ```
       
       
       ​    

### 六、二叉树公共祖先问题

1. **LeetCode 236. Lowest Common Ancestor of a Binary Tree（二叉树的最近公共祖先）**
    - **题目描述**：给定二叉树的根节点和两个节点 `p`、`q`，找到它们的最近公共祖先（LCA：两节点的公共祖先中最深的那个，节点可以是自身的祖先）。
    
    - **示例**：输入二叉树 `3->5->1->6->2->0->8->null->null->7->4`，`p=5`，`q=1`，返回 `3`；`p=5`，`q=4`，返回 `5`。
    
    - 思路：递归法，若根节点是 p 或 q 则返回；否则递归左右子树，若左右都有结果则根是公共祖先，否则返回非空的那个。
    
        后序遍历，只要有一个true最后返回true
    
            ```
            bool dfs(TreeNode* root, TreeNode* p, TreeNode* q) {
                if (root == nullptr) 
                	return false;
                bool lson = dfs(root->left, p, q);
                bool rson = dfs(root->right, p, q);
                if ((lson && rson) || ((root->val == p->val || root->val == q->val) && (lson || rson))) {
                    ans = root;
                } 
                return lson || rson || (root->val == p->val || root->val == q->val);
            }
            ```
    
2. **LeetCode 1650. Lowest Common Ancestor of a Binary Tree III（二叉树的最近公共祖先 III）**
   
    - **题目描述**：二叉树不是bst
    
    - 
    
        ```
        class Solution:
            """
            @param: root: The root of the binary tree.
            @param: A: A TreeNode
            @param: B: A TreeNode
            @return: Return the LCA of the two nodes.
            """
            res = None
            def dfs(self, root, A, B):
                if root == None:
                    return 0
        
                count = 0
                if root.val == A.val or root.val == B.val:
                    count += 1
        
                l = self.dfs(root.left, A, B)
                r = self.dfs(root.right, A, B)
                if l == 2 or r == 2:
                    return 2
                count += l + r
                if count == 2:
                    self.res = root
                return count
        
            def lowestCommonAncestor3(self, root, A, B):
                self.dfs(root, A, B)
                return self.res
        ```
    
        

### 七、其他高频题

1. **LeetCode 116. Populating Next Right Pointers in Each Node（填充每个节点的下一个右侧节点指针）**
    - **题目描述**：给定完美二叉树（所有叶子节点在同一层，每个父节点都有两个子节点）的根节点，填充每个节点的 `next` 指针，使其指向同一层的右侧节点（最后一个节点 `next` 为 `null`）。
    - **示例**：输入 `1->2->3->4->5->6->7`，填充后 `2.next=3`，`4.next=5`，`5.next=6`，`6.next=7` 等。
    - 思路：层序遍历（BFS），每层节点依次连接 `next` 指针；或递归法，利用已连接的 `next` 指针处理子节点。
    
    **1534 · Convert Binary Search Tree to Sorted Doubly Linked List**
    
    题目：将节点node用left和right链接成双向链表
    
    **中序遍历所有node，然后连起来**
    
    ```
    class Solution:
        """
        @param root: root of a tree
        @return: head node of a doubly linked list
        """
        lnode = []
        def dfs(self, root):
            if root == None:
                return None
            self.dfs(root.left)
            self.lnode.append(root)
            self.dfs(root.right)
        def treeToDoublyList(self, root):
            if root == None:
                return None
            self.dfs(root)
            head = TreeNode(-1)
            p = head
            
            for n in self.lnode:
                p.right = n
                n.left = p
                p = n
            p.right = head.right
            head.right.left = p
            return head.right
    ```
    
    
    
2. **LeetCode 297. Serialize and Deserialize Binary Tree（二叉树的序列化与反序列化）** <<<<<<<<<<<<<<<
   
    - **题目描述**：设计算法将二叉树序列化为字符串，再将字符串反序列化为原始二叉树（序列化格式自定义）。
    - **示例**：序列化 `1->2->3->null->null->4->5` 为 `"1,2,3,null,null,4,5"`，反序列化后恢复原树。
    - 思路：序列化用层序或前序遍历，记录空节点；反序列化则根据遍历序列重建树（层序用队列，前序用递归）。
    
    ```
    class Solution:
        """
        @param root: An object of TreeNode, denote the root of the binary tree.
        This method will be invoked first, you should design your own algorithm 
        to serialize a binary tree which denote by a root node to a string which
        can be easily deserialized by your own "deserialize" method later.
        """
        def serialize(self, root):
            if root is None:
                return ""
                
            # use bfs to serialize the tree
            queue = deque([root])
            bfs_order = []
            while queue:
                node = queue.popleft()
                bfs_order.append(str(node.val) if node else '#')
                if node:
                    queue.append(node.left)
                    queue.append(node.right)
                
            return ' '.join(bfs_order)
    
        """
        @param data: A string serialized by your serialize method.
        This method will be invoked second, the argument data is what exactly
        you serialized at method "serialize", that means the data is not given by
        system, it's given by your own serialize method. So the format of data is
        designed by yourself, and deserialize it here as you serialize it in 
        "serialize" method.
        """
        def deserialize(self, data):
            # None or ""
            if not data:
                return None
    
            bfs_order = [
                TreeNode(int(val)) if val != '#' else None
                for val in data.split()
            ]
            root = bfs_order[0]
            fast_index = 1
            
            nodes, slow_index = [root], 0
            while slow_index < len(nodes):
                node = nodes[slow_index]
                slow_index += 1
                node.left = bfs_order[fast_index]
                node.right = bfs_order[fast_index + 1]
                fast_index += 2
                
                if node.left:
                    nodes.append(node.left)
                if node.right:
                    nodes.append(node.right)
            
            return root
    ```
    
    
    
3. **LeetCode 404. Sum of Left Leaves（左叶子之和）**
   
    - **题目描述**：给定二叉树的根节点，返回所有左叶子节点的值之和（左叶子指父节点的左子节点，且自身无左右子树）。
    
    - **示例**：输入 `3->9->20->null->null->15->7`，左叶子为 9 和 15，返回 `24`。
    
    - 思路：递归法，判断节点的左子节点是否为叶子，若是则累加其值，否则递归左右子树；或迭代法（BFS/DFS）。
    
    - 列出所有左叶子，然后加在一起
    
        ```
            def dfs(self, root, flag, res):
                if root == None:
                    return None
                self.dfs(root.left, True, res)
                self.dfs(root.right, False, res)
                if flag and not root.left and not root.right:
                    res.append(root)
        
            def sum_of_left_leaves(self, root: TreeNode) -> int:
                if root == None:
                    return 0
                res = []
                self.dfs(root, False, res)
                s = 0
                for n in res:
                    s += n.val
                return s
        ```
    
        
    
4. **LeetCode 513. Find Bottom Left Tree Value（找树左下角的值）**
    - **题目描述**：给定二叉树的根节点，找到该树最底层（最深层）最左边节点的值。
    
    - **示例**：输入 `2->1->3`，返回 `1`；输入 `1->2->3->4->null->5->6->null->null->7`，返回 `7`。
    
    - 思路：层序遍历（BFS），记录每层第一个节点，最后一层的第一个节点即为结果；或 DFS，优先遍历左子树，记录最深层的第一个节点。
    
        BFS

```
    def find_bottom_left_value(self, root: TreeNode) -> int:
        if root == None:
            return None
           
        q = collections.deque([root])
        res = None
        while len(q) > 0:
            level = len(q)
            res = None
            while level > 0:
                level -= 1
                cur = q.popleft()
                if res == None:
                    res = cur
                if cur.left:
                    q.append(cur.left)
                if cur.right:
                    q.append(cur.right)
        return res.val
```

