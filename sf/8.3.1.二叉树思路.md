### 一、二叉树遍历（基础核心）

1. **LeetCode 144. Binary Tree Preorder Traversal（前序遍历）**
    - 思路：递归法（根 - 左 - 右顺序访问）；迭代法（用栈，先压根，再循环弹出栈顶，压右子树、左子树）。
2. **LeetCode 94. Binary Tree Inorder Traversal（中序遍历）**
    - 思路：递归法（左 - 根 - 右顺序）；迭代法（用栈，先将左子树全部入栈，弹出栈顶访问根，再处理右子树）。
3. **LeetCode 145. Binary Tree Postorder Traversal（后序遍历）**
    - 思路：递归法（左 - 右 - 根顺序）；迭代法（用栈，类似前序但调整顺序为根 - 右 - 左，最后反转结果）。
4. **LeetCode 102. Binary Tree Level Order Traversal（层序遍历）**
    - 思路：BFS（队列实现，每层节点依次入队，遍历并记录）；DFS 也可实现但 BFS 更直观。
5. **LeetCode 103. Binary Tree Zigzag Level Order Traversal（锯齿形层序遍历）**
    - 思路：基于层序遍历，用队列记录每层节点，奇数层正序、偶数层逆序（或用双端队列调整插入顺序）。
6. **LeetCode 987. Vertical Order Traversal of a Binary Tree（垂直遍历）**
    - 思路：DFS 或 BFS 遍历，记录每个节点的 “列索引” 和 “行索引”，按列索引分组，同列内按行索引、节点值排序。

### 二、二叉树结构与属性判断

1. **LeetCode 101. Symmetric Tree（判断二叉树是否对称）**
    - 思路：递归法（比较左子树的左与右子树的右、左子树的右与右子树的左是否对称）；迭代法（用队列，成对入队对称节点，依次比较）。
2. **LeetCode 104. Maximum Depth of Binary Tree（二叉树的最大深度）**
    - 思路：递归法（根节点深度为 1 + max (左子树深度，右子树深度)）；BFS 法（层序遍历的层数即为最大深度）。
3. **LeetCode 111. Minimum Depth of Binary Tree（二叉树的最小深度）**
    - 思路：递归法（注意叶子节点定义，若左 / 右子树为空，深度为 1 + 非空子树深度）；BFS 法（遇到第一个叶子节点时的层数即为最小深度）。
4. **LeetCode 110. Balanced Binary Tree（判断平衡二叉树）**
    - 思路：递归法，同时计算每个节点的高度，若左右子树高度差 > 1 则不平衡；或后序遍历，自底向上判断。
5. **LeetCode 958. Check Completeness of a Binary Tree（判断完全二叉树）**
    - 思路：层序遍历，若出现空节点后还有非空节点，则不是完全二叉树。
6. **LeetCode 98. Validate Binary Search Tree（判断二叉搜索树）**
    - 思路：递归法（中序遍历，记录前驱节点值，确保当前节点值大于前驱）；或递归时传递上下界，确保节点值在合法区间。
7. **LeetCode 543. Diameter of Binary Tree（二叉树的直径）**
    - 思路：递归法，计算每个节点的 “左深度 + 右深度”，取最大值即为直径。
8. **LeetCode 563. Binary Tree Tilt（二叉树的坡度）**
    - 思路：递归法，后序遍历计算每个节点的坡度（左右子树和的绝对差），并累加所有节点的坡度。

### 三、二叉树路径问题

1. **LeetCode 112. Path Sum（路径总和）**
    - 思路：递归法，从根到叶子节点的路径和是否等于目标值；或 BFS，记录节点到根的路径和。
2. **LeetCode 113. Path Sum II（路径总和 II）**
    - 思路：递归法，回溯记录路径，当叶子节点路径和等于目标值时保存路径；或 BFS，同时记录路径和节点。
3. **LeetCode 687. Longest Univalue Path（最长同值路径）**
    - 思路：递归法，计算每个节点的 “左同值链长度 + 右同值链长度”，取最大值；同值链长度为当前节点与子节点值相同时的长度 + 1。
4. **LeetCode 124. Binary Tree Maximum Path Sum（二叉树中的最大路径和）**
    - 思路：递归法，计算每个节点的 “最大贡献值”（节点值 + max (左贡献，右贡献，0)），同时更新全局最大路径和（节点值 + 左贡献 + 右贡献）。
5. **LeetCode 257. Binary Tree Paths（二叉树的所有路径）**
    - 思路：递归法，回溯记录路径，到达叶子节点时将路径转为字符串保存；或 BFS，同时记录节点和路径。

### 四、二叉树构造与修改

1. **LeetCode 105. Construct Binary Tree from Preorder and Inorder Traversal（从前序与中序遍历序列构造二叉树）**
    - 思路：前序的第一个元素是根，在中序中找到根的位置，划分左右子树区间，递归构造左右子树。
2. **LeetCode 106. Construct Binary Tree from Inorder and Postorder Traversal（从中序与后序遍历序列构造二叉树）**
    - 思路：后序的最后一个元素是根，在中序中找到根的位置，划分左右子树区间，递归构造左右子树。
3. **LeetCode 654. Maximum Binary Tree（最大二叉树）**
    - 思路：递归法，在数组中找到最大值作为根，划分左右子数组，递归构造左右子树。
4. **LeetCode 617. Merge Two Binary Trees（合并二叉树）**
    - 思路：递归法，若两树节点都存在则值相加，否则取非空节点；或迭代法，用队列处理节点对。
5. **LeetCode 226. Invert Binary Tree（翻转二叉树）**
    - 思路：递归法，交换左右子树后递归翻转；或迭代法，用队列层序遍历，交换每个节点的左右子树。
6. **LeetCode 669. Trim a Binary Search Tree（修剪二叉搜索树）**
    - 思路：递归法，若根节点值小于 low 则修剪右子树；若大于 high 则修剪左子树；否则递归修剪左右子树。

### 五、二叉搜索树（BST）专项

1. **LeetCode 235. Lowest Common Ancestor of a Binary Search Tree（二叉搜索树的最近公共祖先）**
    - 思路：利用 BST 性质，若根节点值在 p、q 之间则是公共祖先；若根节点值大于 p、q 则递归左子树；否则递归右子树。
2. **LeetCode 700. Search in a Binary Search Tree（二叉搜索树中的搜索）**
    - 思路：递归法，若根节点值等于目标则返回；若小于目标则递归右子树；否则递归左子树；或迭代法。
3. **LeetCode 530. Minimum Absolute Difference in BST（二叉搜索树的最小绝对差）**
    - 思路：中序遍历 BST（有序），记录前驱节点值，计算当前节点与前驱的绝对差，取最小值。
4. **LeetCode 501. Find Mode in Binary Search Tree（二叉搜索树中的众数）**
    - 思路：中序遍历（有序），统计连续相同值的次数，更新众数列表。
5. **LeetCode 538. Convert BST to Greater Tree（把二叉搜索树转换为累加树）**
    - 思路：反中序遍历（右 - 根 - 左），维护累加和，依次更新节点值为累加和。
6. **LeetCode 333. Largest BST Subtree（最大 BST 子树）**
    - 思路：递归法，判断当前子树是否为 BST，同时记录 BST 的大小、最小值、最大值，更新全局最大 BST 子树。

### 六、二叉树公共祖先问题

1. **LeetCode 236. Lowest Common Ancestor of a Binary Tree（二叉树的最近公共祖先）**
    - 思路：递归法，若根节点是 p 或 q 则返回；否则递归左右子树，若左右都有结果则根是公共祖先，否则返回非空的那个。
2. **LeetCode 1650. Lowest Common Ancestor of a Binary Tree III（二叉树的最近公共祖先 III）**
    - 思路：利用节点的父指针，类似链表相交问题，用双指针遍历，相遇时即为公共祖先。

### 七、其他高频题

1. **LeetCode 116. Populating Next Right Pointers in Each Node（填充每个节点的下一个右侧节点指针）**
    - 思路：层序遍历（BFS），每层节点依次连接 next 指针；或递归法，利用已连接的 next 指针处理子节点。
2. **LeetCode 297. Serialize and Deserialize Binary Tree（二叉树的序列化与反序列化）**
    - 思路：序列化用层序或前序遍历，记录空节点；反序列化则根据遍历序列重建树（层序用队列，前序用递归）。
3. **LeetCode 404. Sum of Left Leaves（左叶子之和）**
    - 思路：递归法，判断节点的左子节点是否为叶子，若是则累加其值，否则递归左右子树；或迭代法（BFS/DFS）。
4. **LeetCode 513. Find Bottom Left Tree Value（找树左下角的值）**
    - 思路：层序遍历（BFS），记录每层第一个节点，最后一层的第一个节点即为结果；或 DFS，优先遍历左子树，记录最深层的第一个节点。