## 基础：

### 627 · 最长回文串 Longest Palindrome

所有字符随意组合出的最长回文串

1. hash统计
2. 偶数长度直接加到结果上
3. 奇数减一剩下的偶数长度加到结果上。
4. 如果存在奇数，最后结果加一，不存在不加  “aaaa”, "abbbb"

### 458 · 目标最后位置

二分查找

### 200 · 最长回文子串 Longest Palindromic Substring

1. 非动态规划。从最长len开始判断，逐渐简短，第一个找到的回文串就是结果。

2. 动态规划：区间动态规划

   **字串两端是否相等**

   ```
   if (s[i] == s[j])
   {
       if (i + 1 > j - 1 || f[i + 1][j - 1])
       {
           f[i][j] = true;
           maxlen = len;
           res = s.substr(i, len);
       }
   }
   ```

   

### 667 · 最长的回文序列 Longest Palindromic Subsequence

1. f\[i][j]:   i ~ j 之间最大的回文长度
2. 区间DP

### 841 · 字符串替换

1. 字符串hash
2. 常规算法，建立a b的hash map以后，a可以排序

### 148 · 颜色分类

1. 三个指针l r idx，动idx，发现0，和左边l交换，发现1，继续往下，发现2，和右边交换

### 404 · 子数组求和 II

前缀和

### 539 · 移动零

同向双指针

### 144 · 交错正负数

1. partition 将正负数分开两边，多的在前面
2. 从两边开始向中心开始交换
3. l = 1，
4. 如果正负个数相等，r = len - 2

### 382 · 三角形计数   443 · 两数之和 II

for 循环最大边的位置 i，接下来的任务就是在 0~i-1 之间找到两数之和 > S[i]

### 461 · 无序数组K小元素

1. partition
2. 堆

### 62 · Search in Rotated Sorted Array（比较左端点，想象成一个菱形）

想象成一个菱形，如果是上半部分，就判断是上坡，还是下坡，最后决定是r = mid或l = mid + 1

和左端点比较，确定是上半部还是下半部，判断坡度，确定是上升还是下降



### 178 · 图是否是树

1. 判断是否是树，a. 是否有环 b. 是否全连在一起，而不是两个分开的图
2. 并查集
3. 同一条边的两端点的父亲，如果一样，说明有环
4. 所有端点的父亲只有一个

### 52 · 下一个排列

1. 从后往前找第一个变小的数a（第一个降序）

2. 从后往前找第一个比前面a大的数，与a交换

3. 升序a后面的数

### 838 · Subarray Sum Equals K

求sum的基本思路之一，前缀和+ 哈希, hash一部分出现的次数，如果另外的sum - k等于hash中的值，这hash对应的数为目标和的次数
