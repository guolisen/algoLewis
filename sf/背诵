[TOC]



## 二分

[l, r)    while (l < r)    结束的时候 l == r

[l, r]    while (l <= r)  结束的时候 r < l



target <= mid

r = mid

mid <= target

l = mid



< > 常规判断，(<) 有= 左半边，无等号右半边

![img](https://images2015.cnblogs.com/blog/638419/201704/638419-20170425122731162-503571755.png)

```
如果有等号，target就会在当前if分支

如果想找到target必须带等号，想找旁边的数，就不带等号


while (l < r)

0 1 2 3 4 5
1 2 3 3 7 7

mid < target   (l = mid)    左              
      no=       =      
3     1(2)     3(3)   // 如果有等于号（如果当找到target时），就会移动left，就会找最后边的3, 如果没有等于号，当3时就会移动right(mid - 1)，得到1(2)
5     3(3)     3(3)   // 如果有等号，target就会在当前if分支
<=1   0(1)     0(1) 
>=8   5(7)     5(7)

target < mid   (r = mid)    右
      no=       =      
3     4(7)     2(3)  // 如果有=，只要mid == target，r就会往左移，最终获得最左边的3.
5     4(7)     4(7)  // 如果没有=，当3时就会移动l(mid + 1)，得到4(7)
7     5(7)     4(7)  // 如果没有=，当mid == 3时, l(mid + 1)，l不能等于mid，所以肯定得不到target，而得到target右边的值
1     1(2)     0(1) 
<=0   0(1)     0(1)     
>=8   5(7)     5(7)


两种代码格式是固定的，只需要考虑是否加=号，只考虑最后迭代的几步即可

if (mid > target)      // 如果mid == target(查找target)，就会连续的r=mid，结果是最左边的target，
{					   
    r = mid;      // 如果求target的位置，都用这个分支，如果是求target左边或者右边的位置，用另外一个分支
}
else                   // 如果mid != target，就会一直l = mid + 1, 就会得到target右边第一个位置
{
    l = mid + 1;
}


```

```
while (l <= r)

0 1 2 3 4 5
1 2 3 3 7 7

mid < target
      no=         = 
     r   l      r   l      
1   -1   0      0   1       
3    1   2      3   4
5    3   4      3   4
<=0 -1   0     -1   0      
>=8  5   6      5   6

mid > target
      no=       =    
     r   l    r   l       
3    3   4    1   2
5    3   4    3   4
7    5   6    3   4
1    0   1   -1   0
<=0 -1   0   -1   0    
>=8  5   6    5   6
```

457 · 经典二分查找问题
```
class Solution {
public:
    int findPosition(vector<int> &nums, int target) {
        if (nums.empty())
            return -1;
        int m = nums.size();
        int l = 0;
        int r = m - 1;
        while (l < r)
        {
            int mid = (l + r) / 2;
            if (nums[mid] >= target)
            {
                r = mid;
            }
            else
            {
                l = mid + 1;
            }
        }

        if (nums[l] == target)
            return l;
        return -1;
    }
};
```
## 宽搜 深搜
433 · 岛屿的个数

```
class Solution {
public:
    /**
     * @param grid: a boolean 2D matrix
     * @return: an integer
     */

    bool isInBound(int x, int y, int m, int n)
    {
        if (x < 0 || x >= m || y < 0 || y >= n)
            return false;
        return true;
    }
    void bfs(vector<vector<bool>> &grid, int x, int y)
    {
        int m = grid.size();
        int n = grid[0].size();
        int dx[] = {-1, 1, 0, 0};
        int dy[] = {0, 0, 1, -1};
        queue<pair<int, int>> q;
        q.push({x, y});
        while (!q.empty())
        {
            auto pos = q.front(); q.pop();
            for (int d = 0; d < 4; d++)
            {
                int nx = pos.first + dx[d];
                int ny = pos.second + dy[d];
                if (!isInBound(nx, ny, m, n) || grid[nx][ny] != true)
                    continue;
                q.push({nx, ny});
                grid[nx][ny] = false;
            }
        }
    }
    int numIslands(vector<vector<bool>> &grid) {
        if (grid.empty())
            return 0;
        int m = grid.size();
        int n = grid[0].size();

        int res = 0;
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (grid[i][j])
                {
                    res++;
                    bfs(grid, i, j);
                }
            }
        }
        return res;
    }
};
```

15 · 全排列

深搜重点是状态还原

```
class Solution:
    """
    @param nums: A list of integers.
    @return: A list of permutations.
             we will sort your return value in output
    """
    def dfs(self, nums, order, cur, res):
        if len(cur) == len(nums):
            if cur not in res:
                res.append(list(cur))
            return
        m = len(nums)
        for i in range(m):
            if i in order:
                continue
            order.append(i)
            cur.append(nums[i])
            self.dfs(nums, order, cur, res)
            cur.pop(len(cur) - 1)
            order.pop(len(order) - 1)

    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []
        self.dfs(nums, [], [], res)
        return res
```
```
class Solution {
public:
    void dfs(vector<int>& nums, int level, vector<bool> visit, vector<int> cur, vector<vector<int>>& res)
    {
        if (level == nums.size())
        {
            res.push_back(cur);
            return;
        }
        int m = nums.size();
        for (int i = 0; i < m; i++)
        {
            if (visit[i])
                continue;
            visit[i] = true;
            cur.push_back(nums[i]);
            dfs(nums, level + 1, visit, cur, res);
            cur.pop_back();
            visit[i] = false;
        }
    }
    vector<vector<int>> permute(vector<int> &nums) {
        int m = nums.size();
        vector<vector<int>> res;
        vector<bool> visit(m, false);
        dfs(nums, 0, visit, {}, res);
        return res;
    }
};
```

## 记录BFS路径

```
from collections import deque
from typing import List, Dict, Optional

def bfs_shortest_path(graph: Dict[int, List[int]], start: int, target: int) -> Optional[List[int]]:
    """
    BFS寻找最短路径并返回路径列表
    
    参数:
        graph: 邻接表表示的图
        start: 起点
        target: 目标节点
    
    返回:
        最短路径列表（从start到target），若不可达则返回None
    """
    if start not in graph or target not in graph:
        return None  # 节点不在图中
    
    visited = set()          # 记录已访问节点，避免重复
    queue = deque([start])   # BFS队列
    visited.add(start)
    prev = {}                # 存储前驱节点：key是当前节点，value是前驱
    
    # BFS遍历
    while queue:
        current = queue.popleft()
        
        if current == target:
            break  # 首次到达目标，退出循环
        
        # 遍历邻居节点
        for neighbor in graph[current]:
            if neighbor not in visited:
                visited.add(neighbor)
                prev[neighbor] = current  # 记录前驱
                queue.append(neighbor)
    
    # 若目标节点没有前驱，说明不可达
    if target not in prev and start != target:
        return None
    
    # 回溯重建路径
    path = []
    current = target
    while current != start:
        path.append(current)
        current = prev[current]  # 向前驱移动
    path.append(start)  # 加入起点
    path.reverse()      # 反转得到正确顺序
    
    return path


# 示例使用
if __name__ == "__main__":
    # 邻接表表示图
    graph = {
        0: [1, 2],
        1: [0, 3],
        2: [0, 3],
        3: [1, 2, 4],
        4: [3]
    }
    start = 0
    target = 4
    path = bfs_shortest_path(graph, start, target)
    print(f"从 {start} 到 {target} 的最短路径: {path}")  # 输出: [0, 1, 3, 4] 或 [0, 2, 3, 4]
```



## GCD

845 · Greatest Common Divisor

```
int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}

def gcd(self, a: int, b: int) -> int:
    return self.gcd(b, a % b) if b else a;
```

## Partition·	
```
        int m = A.size();
        int l = 0;
        int r = m - 1;
        while (l <= r)
        {
            while (l <= r && A[l] < 0) { l++; }
            while (l <= r && A[r] >= 0) { r--; }
            if (l < r)
            {
                swap(A[l], A[r]);
            }
        }
```

快速排序算法模板 —— 模板题 AcWing 785. 快速排序
```
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
归并排序算法模板 —— 模板题 AcWing 787. 归并排序
```
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int mid = l + r >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);
    
    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];
    
    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];
    
    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```

C++

```cpp
#include <vector>
#include <algorithm>  // 用于 swap

// 直接操作 vector<int>，l=左边界，r=右边界（闭区间）
void quick_sort(std::vector<int>& q, int l, int r) {
    if (l >= r) return;

    int i = l - 1, j = r + 1;
    int x = q[(l + r) >> 1];  // 取中间元素作为基准

    while (i < j) {
        do i++; while (q[i] < x);  // 找到 >=x 的元素
        do j--; while (q[j] > x);  // 找到 <=x 的元素
        if (i < j) std::swap(q[i], q[j]);  // 交换
    }

    // 递归处理左右两部分
    quick_sort(q, l, j);
    quick_sort(q, j + 1, r);
}

// 重载：无需手动传边界，直接排序整个 vector
void quick_sort(std::vector<int>& q) {
    if (q.empty()) return;
    quick_sort(q, 0, q.size() - 1);
}
```
```c++
#include <vector>
#include <algorithm>  // 用于 swap

// 直接操作 vector<int>，l=左边界，r=右边界（闭区间）
void quick_sort(std::vector<int>& q, int l, int r) {
    if (l >= r) return;

    // 三点平均法计算 pivot：左(l)、中(mid)、右(r) 三个元素的平均值
    int mid = (l + r) >> 1;  // 中间位置
    int pivot = (q[l] + q[mid] + q[r]) / 3;  // 三点平均值作为基准

    int i = l - 1, j = r + 1;
    int x = pivot;  // 基准值改为三点平均值

    while (i < j) {
        do i++; while (q[i] < x);  // 找到 >=x 的元素
        do j--; while (q[j] > x);  // 找到 <=x 的元素
        if (i < j) std::swap(q[i], q[j]);  // 交换
    }

    // 递归处理左右两部分（仍用 j 分割，逻辑不变）
    quick_sort(q, l, j);
    quick_sort(q, j + 1, r);
}

// 重载：无需手动传边界，直接排序整个 vector
void quick_sort(std::vector<int>& q) {
    if (q.empty()) return;
    quick_sort(q, 0, q.size() - 1);
}
```
```c++
#include <iostream>
#include <vector>

int main() {
    // 测试极端有序数组（升序），三点平均法更高效
    std::vector<int> q = {1,2,3,4,5,6,7,8,9};
    quick_sort(q);

    for (int x : q) std::cout << x << " ";  // 输出：1 2 3 4 5 6 7 8 9
    return 0;
}
```


2. 归并排序（对应 AcWing 787）

```cpp
#include <vector>

// 辅助函数：合并两个有序区间 [l, mid] 和 [mid+1, r]
void merge(std::vector<int>& q, int l, int mid, int r) {
    std::vector<int> tmp;  // 临时存储合并结果
    int i = l, j = mid + 1;

    // 双指针合并
    while (i <= mid && j <= r) {
        if (q[i] <= q[j]) tmp.push_back(q[i++]);
        else tmp.push_back(q[j++]);
    }

    // 处理剩余元素
    while (i <= mid) tmp.push_back(q[i++]);
    while (j <= r) tmp.push_back(q[j++]);

    // 复制回原 vector
    for (int k = 0; k < tmp.size(); k++) {
        q[l + k] = tmp[k];
    }
}

// 主函数：分治排序
void merge_sort(std::vector<int>& q, int l, int r) {
    if (l >= r) return;

    int mid = (l + r) >> 1;
    merge_sort(q, l, mid);     // 左半部分排序
    merge_sort(q, mid + 1, r); // 右半部分排序
    merge(q, l, mid, r);       // 合并两个有序区间
}

// 重载：直接排序整个 vector
void merge_sort(std::vector<int>& q) {
    if (q.empty()) return;
    merge_sort(q, 0, q.size() - 1);
}
```

C++ 使用示例

```cpp
#include <iostream>
#include <vector>

int main() {
    // 快速排序示例
    std::vector<int> q1 = {3, 1, 4, 1, 5, 9, 2, 6};
    quick_sort(q1);  // 直接调用，无需传边界
    for (int x : q1) std::cout << x << " ";  // 输出：1 1 2 3 4 5 6 9
    std::cout << std::endl;

    // 归并排序示例
    std::vector<int> q2 = {7, 5, 3, 2, 4, 6, 8, 1};
    merge_sort(q2);  // 直接调用，无需传边界
    for (int x : q2) std::cout << x << " ";  // 输出：1 2 3 4 5 6 7 8
    return 0;
}
```





Python 实现（贴近原逻辑，简洁高效）

Python 版本保留了原算法的核心思想（双指针分区、分治合并），适配 Python 的列表（`list`），并优化了边界处理（避免索引越界）。

1. 快速排序（对应 AcWing 785）

```python
def quick_sort(q, l=None, r=None):
    # 首次调用时默认处理整个列表（l=0, r=len(q)-1）
    if l is None:
        l = 0
    if r is None:
        r = len(q) - 1
    
    if l >= r:
        return
    
    # 取中间元素作为基准（避免极端情况）
    i, j = l - 1, r + 1
    x = q[(l + r) // 2]  # 整数除法，等价于 C++ 的 l + r >> 1

    while i < j:
        # 找到 >=x 的元素（循环条件与 C++ 一致）
        i += 1
        while q[i] < x:
            i += 1
        # 找到 <=x 的元素
        j -= 1
        while q[j] > x:
            j -= 1
        # 交换元素
        if i < j:
            q[i], q[j] = q[j], q[i]
    
    # 递归处理左右两部分（用 j 分割，与 C++ 逻辑一致）
    quick_sort(q, l, j)
    quick_sort(q, j + 1, r)
```

2. 归并排序（对应 AcWing 787）

```python
def merge_sort(q):
    # 递归终止条件：列表长度 <=1 时已有序
    if len(q) <= 1:
        return q
    
    # 分割数组（中间位置）
    mid = len(q) // 2
    left = merge_sort(q[:mid])  # 左半部分排序
    right = merge_sort(q[mid:])  # 右半部分排序
    
    # 双指针合并
    res = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            res.append(left[i])
            i += 1
        else:
            res.append(right[j])
            j += 1
    
    # 拼接剩余元素
    res.extend(left[i:])
    res.extend(right[j:])
    return res
```

Python 使用示例

```python
# 快速排序示例（原地修改列表）
arr1 = [3, 1, 4, 1, 5, 9, 2, 6]
quick_sort(arr1)
print(arr1)  # 输出：[1, 1, 2, 3, 4, 5, 6, 9]

# 归并排序示例（返回新列表，不修改原列表）
arr2 = [2.1, 5.3, 1.2, 4.0]
sorted_arr2 = merge_sort(arr2)
print(sorted_arr2)  # 输出：[1.2, 2.1, 4.0, 5.3]

# 字符串列表排序（支持任意可比较类型）
arr3 = ["apple", "banana", "cherry", "date"]
quick_sort(arr3)
print(arr3)  # 输出：['apple', 'banana', 'cherry', 'date']
```

1. **逻辑一致性**：所有版本严格遵循原 C 语言模板的核心逻辑（快速排序的双指针分区、归并排序的分治合并），确保排序结果和效率一致。
2. **兼容性**：C++ 支持数组和 `vector`，Python 支持列表（`list`），且均支持任意可比较类型（整数、浮点数、字符串等）。
3. **边界处理**：快速排序用中间元素作为基准（避免极端情况导致的超时），归并排序用局部临时数组（C++）或切片（Python）避免全局变量问题。
4. **易用性**：C++ 提供重载函数适配 `vector`，Python 支持默认参数（无需手动传入边界），使用更简洁。


## 前缀和

前缀和 有两种形式

404 · 子数组求和 II

```c++
#include <numeric>
class Solution {
public:
    int subarraySumII(vector<int> &a, int start, int end) {
        int m = a.size();
        vector<int> sum(m + 1, 0);
        partial_sum(a.begin(), a.end(), sum.begin() + 1);

        int res = 0;
        for (int len = 1; len <= m; len++)
        {
            for (int i = 0; i < m - len + 1; i++)
            {
                int j = i + len - 1;
                int s = sum[j + 1] - sum[i];
                if (s <= end && s >= start)
                    res++;
            }
        }
        return res;
    }
};
```
1. S = [0 for _ in range(m + 1)]

2.         for i in range(1, m + 1):
               S[i] = S[i - 1] + a[i - 1]

3. ps = S[j + 1] - S[i]

```python
    def subarray_sum_i_i(self, a: List[int], start: int, end: int) -> int:
        m = len(a)
        S = [0 for _ in range(m + 1)]
        for i in range(1, m + 1):
            S[i] = S[i - 1] + a[i - 1]

        res = 0
        for L in range(1, m + 1):
            for i in range(m - L + 1):
                j = i + L - 1
                ps = S[j + 1] - S[i]
                if ps >= start and ps <= end:
                    res += 1
        return res
```
138 · Subarray Sum

```
class Solution:
    def subarraySum(self, nums):
            prefix_hash = {0: -1}
            prefix_sum = 0
            for i, num in enumerate(nums):
                prefix_sum += num
                if prefix_sum in prefix_hash:
                    return prefix_hash[prefix_sum] + 1, i
                prefix_hash[prefix_sum] = i
                
            return -1, -1
```



## Heap

4 · 丑数 II
```
import heapq

class Solution:
    def nth_ugly_number(self, n: int) -> int:
        heap = []
        heapq.heappush(heap, 1)

        factor = [2, 3, 5]

        res = 1
        visit = [1]
        for i in range(n):
            cur = heapq.heappop(heap)
            res = cur
            for k in factor:
                if cur * k not in visit:
                    visit.append(cur * k)
                    heapq.heappush(heap, cur * k)
        return res
```
```
class Solution {
public:
    int nthUglyNumber(int n) {
        priority_queue<long long, vector<long long>, greater<long long>> q;
        q.push(1);
        unordered_set<long long> visit;
        long long res = 0;
        for (int i = 0; i < n; i++)
        {
            auto cur = q.top(); q.pop();
            res = cur;
            if (!visit.count(cur * 2))
            {
                q.push(cur * 2);
                visit.insert(cur * 2);
            }
            if (!visit.count(cur * 3))
            {
                q.push(cur * 3);
                visit.insert(cur * 3);
            }
            if (!visit.count(cur * 5))
            {
                q.push(cur * 5);
                visit.insert(cur * 5);
            }
        }
        return (int)res;
    }
};
```
## 并查集

### 1179 · Friend Circles

```c++
class Solution {
public:
    int find(vector<int>& p, int x)
    {
        if (p[x] != x) p[x] = find(p, p[x]);
        return p[x];
    }
    int findCircleNum(vector<vector<int>> &M) {
        if (M.empty())
            return 0;
        int m = M.size();
        int n = M[0].size();
        vector<int> p(m);
        for (int i = 0; i < m; i++)
        {
            p[i] = i;
        }

        for (int i = 0; i < m; i++)
        {
            for (int j = i + 1; j < n; j++)     //上三角
            {
                if (M[i][j] == 1)
                {
                    p[find(p, i)] = find(p, j);
                }
            }
        }

        set<int> resset;
        for (int i = 0; i < m; i++)
        {
            resset.insert(find(p, i));
        }

        return resset.size();
    }
};
```
```python
class Solution:
    """
    @param nodes: a array of Undirected graph node
    @return: a connected set of a Undirected graph
    """
    p = collections.defaultdict(int)
    def find(self, x):
        if (self.p[x] != x): 
            self.p[x] = self.find(self.p[x])
        return self.p[x]
    def connectedSet(self, nodes: List[UndirectedGraphNode]) -> List[List[int]]:
        for n in nodes:
            self.p[n.label] = n.label
        
        for n in nodes:
            for ne in n.neighbors:
                if self.find(n.label) != self.find(ne.label):
                    self.p[self.find(n.label)] = self.find(ne.label)
        
        h = collections.defaultdict(list)
        for n in nodes:
            h[self.find(n.label)].append(n.label)

        res = []
        for g,l in h.items():
            res.append(sorted(l))
        return res

```


## tri树

### 442 · Implement Trie (Prefix Tree)

```
class Trie {
public:
    /*
     * @param word: a word
     * @return: nothing
     */
    int son[100000][26];
    int cnt[100000];
    int idx = 0;
    void insert(string &word) {
        int m = word.size();
        int p = 0;
        for (int i = 0; i < m; i++)
        {
            int u = word[i] - 'a';
            if (!son[p][u]) son[p][u] = ++idx;
            p = son[p][u];
        }
        cnt[p]++;
    }

    /*
     * @param word: A string
     * @return: if the word is in the trie.
     */
    bool search(string &word) {
        int m = word.size();
        int p = 0;
        for (int i = 0; i < m; i++)
        {
            int u = word[i] - 'a';
            if (!son[p][u]) 
                return false;
            p = son[p][u];
        }
        return cnt[p]? true: false;
    }

    /*
     * @param prefix: A string
     * @return: if there is any word in the trie that starts with the given prefix.
     */
    bool startsWith(string &prefix) {
        int m = prefix.size();
        int p = 0;
        for (int i = 0; i < m; i++)
        {
            int u = prefix[i] - 'a';
            if (!son[p][u]) 
                return false;
            p = son[p][u];
        }
        return true;
    }
};
```
### leetcode 208. Implement Trie (Prefix Tree)
```
class Trie:
    def __init__(self):
        self.children = [None] * 26
        self.isEnd = False
    
    def searchPrefix(self, prefix: str) -> "Trie":
        node = self
        for ch in prefix:
            ch = ord(ch) - ord("a")
            if not node.children[ch]:
                return None
            node = node.children[ch]
        return node

    def insert(self, word: str) -> None:
        node = self
        for ch in word:
            ch = ord(ch) - ord("a")
            if not node.children[ch]:
                node.children[ch] = Trie()
            node = node.children[ch]
        node.isEnd = True

    def search(self, word: str) -> bool:
        node = self.searchPrefix(word)
        return node is not None and node.isEnd

    def startsWith(self, prefix: str) -> bool:
        return self.searchPrefix(prefix) is not None
```



### 1848 · Word Search III

## priority_queue lamda

612 · K个最近的点
```
/**
 * Definition for a point.
 * struct Point {
 *     int x;
 *     int y;
 *     Point() : x(0), y(0) {}
 *     Point(int a, int b) : x(a), y(b) {}
 * };
 */

class Solution {
public:
    /**
     * @param points: a list of points
     * @param origin: a point
     * @param k: An integer
     * @return: the k closest points
     */
    int dist(Point& p1, Point& p2)
    {
        return pow(p2.x - p1.x, 2) + pow(p2.y - p1.y, 2);
    }
    vector<Point> kClosest(vector<Point> &points, Point origin, int k) {
        int m = points.size();
        priority_queue<Point, vector<Point>, std::function<bool(Point&, Point&)>> q(
            [&](Point& a, Point& b)
            {
                int dista = dist(a, origin);
                int distb = dist(b, origin);
                if (dista > distb)
                {
                    return true;
                }
                else if (dista == distb)
                {
                    if (a.x != b.x)
                    {
                        return a.x > b.x;
                    }
                    else
                    {
                        return a.y > b.y;
                    }
                }
                return false;
            }
        );

        for (auto p : points)
        {
            q.push(p);
        }

        vector<Point> res;
        for (int i = 0; i < k; i++)
        {
            res.push_back(q.top());
            q.pop();
        }
        return res;
    }
};
```

## vector初始化

```
vector<vector<int>> dp(m, vector<int>(n, 1));
```

## 质数

### 1324 · Count Primes

```
class Solution {
public:
    vector<int> primes;
    int cnt = 0;   
    bool st[2000000];     
    int res = 0;
    Solution(): primes(2000000, 0) {}

    void get_primes(int n)
    {
        for (int i = 2; i <= n; i ++ )
        {
            if (!st[i]) 
            {
                primes[cnt ++ ] = i;
            }
            for (int j = 0; primes[j] <= n / i; j ++ )
            {
                st[primes[j] * i] = true;
                if (i % primes[j] == 0) break;
            }
        }
    }

    int countPrimes(int n) {
        get_primes(n);

        for (auto c : primes)
            if (c != 0 && c != n)
                res++;
        return res;
    }
};
```
```
class Solution:
    def count_primes(self, n: int) -> int:
        if n <= 2:
            return 0
        res = 0
        is_primes = [True for _ in range(n)]
        for i in range(2, n):
            if is_primes[i]:
                res += 1
                for j in range(2, n):
                    if i * j >= n:
                        break
                    is_primes[i*j] = False
        return res
```



## LIS 

## LCS

## LCA

### 88 · Lowest Common Ancestor of a Binary Tree(LCA) 二叉树最近公共祖先

```
class Solution {
public:
    TreeNode* ans;
    bool dfs(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == nullptr) return false;
        bool lson = dfs(root->left, p, q);
        bool rson = dfs(root->right, p, q);
        if ((lson && rson) || ((root->val == p->val || root->val == q->val) && (lson || rson))) 
        {
            ans = root;
        } 
        return lson || rson || (root->val == p->val || root->val == q->val);
    }
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        dfs(root, p, q);
        return ans;
    }
};
```

```
class Solution:
    res = None
    def dfs(self, root, A, B):
        if root == None:
            return False
        l = self.dfs(root.left, A, B)
        r = self.dfs(root.right, A, B)
        if self.res != None:
            return False
        if root.val == A.val or root.val == B.val:
            if l or r:
                self.res = root
            return True
        if l and r:
            self.res = root
        return l or r

    def lowestCommonAncestor(self, root, A, B):
        if self.dfs(root, A, B):
            return root
        return self.res
```

## 二分+旋转

### 159 · Find Minimum in Rotated Sorted Array

要让r = mid 在有边，因为右边才是最小值的位置

```
class Solution {
public:
    int findMin(vector<int> &nums) {
        int m = nums.size();
        if (nums[0] < nums[m - 1])
            return nums[0];
        int l = 0;
        int r = m - 1;
        while (l < r)
        {
            int mid = (l + r) / 2;
            if (nums[mid] < nums[0])
            {
                r = mid;
            }
            else
            {
                l = mid + 1;
            }
        }
        return nums[l];
    }
};
```

### 62 · Search in Rotated Sorted Array（比较左端点，想象成一个菱形）

想象成一个菱形，如果是上半部分，就判断是上坡，还是下坡，最后决定是r = mid或l = mid + 1

和左端点比较，确定是上半部还是下半部，判断坡度，确定是上升还是下降



159 单增加，62不确定是增加还是下降





### 587 · Two Sum - Unique pairs

双指针模板：

```
   def two_sum6(self, nums: List[int], target: int) -> int:
        m = len(nums)
        nums.sort()
        l = 0
        r = m - 1
        res = 0
        stor = []
        while l < r:
            s = nums[l] + nums[r]
            if s == target:
                t = [nums[l], nums[r]]
                if t not in stor:
                    res += 1
                    stor.append(t)
                l += 1
            elif s > target:
                r -= 1
            else:
                l += 1
        return res
```



## 图论

邻接表，邻接矩阵





## 思路

```
Level 1:
13 · Implement strStr()    KMP, 字符串hash，On2

458 · Last Position of Target  二分

627 · Longest Palindrome   统计，基数 - 1 = 偶数

200 · Longest Palindromic Substring  

415 · Valid Palindrome   isalnum()

1790 · Rotate String II   

* 667 · Longest Palindromic Subsequence  动态规划

594 · strStr II

* 841 · String Replace  s.replace

```

```
Level 2 双指针
607 · Two Sum III - Data structure design

31 · Partition Array

57 · 3Sum

* 148 · Sort Colors

404 · Subarray Sum II

587 · Two Sum - Unique pairs

976 · 4Sum II

228 · Middle of Linked List  快慢指针

* 539 · Move Zeroes  同向双指针

5 · Kth Largest Element   堆

144 · Interleaving Positive and Negative Numbers python heapq

* 382 · Triangle Count   双向双指针两边

* 443 · Two Sum - Greater than target   双向双指针两边

461 · Kth Smallest Numbers in Unsorted Array   heapq -n

533 · Two Sum - Closest to target

608 · Two Sum II - Input array is sorted

609 · Two Sum - Less than or equal to target


```

```
Level 3  二分
457 · Classical Binary Search

458 · Last Position of Target

628 · Maximum Subtree        分治深搜

* 75 · Find Peak Element       二分，判断在左坡，和其余

* 159 · Find Minimum in Rotated Sorted Array     二分 要让r = mid 在有边，因为右边才是最小值的位置

* 460 · Find K Closest Elements     用二分找到target，isleftNear()

586 · Sqrt(x) II

183 · Wood Cut     木板长度二分

14 · First Position of Target

458 · Last Position of Target

* 62 · Search in Rotated Sorted Array

447 · Search in a Big Sorted Array

* 585 · Maximum Number in Mountain Sequence

```

```
Level 4 BFS
433 · Number of Islands

127 · Topological Sorting

* 137 · Clone Graph    用一个map[原]=新, 遍历出所有node, 然后链接。

611 · Knight Shortest Path

* 120 · Word Ladder

* 178 · Graph Valid Tree     1. 边数 == node数 - 1  2. 连通

431 · Connected Component in Undirected Graph

* 598 · Zombie in Matrix       

605 · Sequence Reconstruction

615 · Course Schedule

616 · Course Schedule II

618 · Search Graph Nodes

630 · Knight Shortest Path II

573 · Build Post Office II

892 · Alien Dictionary

```

```
level 5
453 · Flatten Binary Tree to Linked List

596 · Minimum Subtree

900 · Closest Binary Search Tree Value

88 · Lowest Common Ancestor of a Binary Tree

619 · Binary Tree Longest Consecutive Sequence III

902 · Kth Smallest Element in a BST

* 85 · Insert Node in a Binary Search Tree

175 · Invert Binary Tree

597 · Subtree with Maximum Average

11 · Search Range in Binary Search Tree

95 · Validate Binary Search Tree

87 · Remove Node in Binary Search Tree

901 · Closest Binary Search Tree Value II

85 · Insert Node in a Binary Search Tree

175 · Invert Binary Tree

597 · Subtree with Maximum Average

11 · Search Range in Binary Search Tree

* 95 · Validate Binary Search Tree

87 · Remove Node in Binary Search Tree

901 · Closest Binary Search Tree Value II

```



```
Level 7
138 · Subarray Sum
Easy
4 · Ugly Number II    堆
Medium
657 · Insert Delete GetRandom O(1)
Medium
685 · First Unique Number in Data Stream
Medium
134 · LRU Cache

```





## Python `collections` 模块详细代码示例

### 1. namedtuple - 命名元组

```python
from collections import namedtuple

# 创建命名元组类型
Employee = namedtuple('Employee', ['name', 'id', 'title', 'salary'])

# 实例化
emp1 = Employee('John Doe', 12345, 'Software Engineer', 85000)
emp2 = Employee('Jane Smith', 54321, 'Data Scientist', 92000)

# 访问字段
print(emp1.name)      # 输出: John Doe
print(emp2.title)     # 输出: Data Scientist

# 转换为字典
emp_dict = emp1._asdict()
print(emp_dict)       # 输出: {'name': 'John Doe', 'id': 12345, ...}

# 替换字段值
emp1 = emp1._replace(salary=90000)
print(emp1.salary)    # 输出: 90000
```

### 2. deque - 双端队列

```python
from collections import deque

# 创建双端队列
d = deque(['a', 'b', 'c'])

# 添加元素
d.append('d')         # 右侧添加
d.appendleft('z')     # 左侧添加
print(d)              # 输出: deque(['z', 'a', 'b', 'c', 'd'])

# 移除元素
right_item = d.pop()  # 移除并返回右侧元素
left_item = d.popleft() # 移除并返回左侧元素
print(right_item)     # 输出: 'd'
print(left_item)      # 输出: 'z'

# 旋转队列
d.rotate(1)           # 向右旋转1位
print(d)              # 输出: deque(['c', 'a', 'b'])
d.rotate(-1)          # 向左旋转1位
print(d)              # 输出: deque(['a', 'b', 'c'])

# 限制队列长度
limited_d = deque(maxlen=3)
for i in range(5):
    limited_d.append(i)
print(limited_d)      # 输出: deque([2, 3, 4], maxlen=3)
```

### 3. Counter - 计数器

```python
from collections import Counter

# 创建计数器
words = ['apple', 'banana', 'apple', 'orange', 'banana', 'apple']
word_counts = Counter(words)

print(word_counts)        # 输出: Counter({'apple': 3, 'banana': 2, 'orange': 1})
print(word_counts['apple'])  # 输出: 3

# 更新计数器
word_counts.update(['apple', 'kiwi'])
print(word_counts)        # 输出: Counter({'apple': 4, 'banana': 2, 'orange': 1, 'kiwi': 1})

# 获取最常见元素
print(word_counts.most_common(2))  # 输出: [('apple', 4), ('banana', 2)]

# 数学运算
c1 = Counter(a=3, b=1)
c2 = Counter(a=1, b=2)
print(c1 + c2)           # 输出: Counter({'a': 4, 'b': 3})
print(c1 - c2)           # 输出: Counter({'a': 2})
print(c1 & c2)           # 输出: Counter({'a': 1, 'b': 1}) (交集)
print(c1 | c2)           # 输出: Counter({'a': 3, 'b': 2}) (并集)
```

### 4. defaultdict - 默认字典

```python
from collections import defaultdict

# 创建默认值为0的字典
dd_int = defaultdict(int)
words = ['apple', 'banana', 'apple']
for word in words:
    dd_int[word] += 1
print(dd_int)            # 输出: defaultdict(<class 'int'>, {'apple': 2, 'banana': 1})

# 默认值为列表的字典
dd_list = defaultdict(list)
data = [('a', 1), ('b', 2), ('a', 3), ('b', 4)]
for key, value in data:
    dd_list[key].append(value)
print(dd_list)           # 输出: defaultdict(<class 'list'>, {'a': [1, 3], 'b': [2, 4]})

# 自定义默认值工厂函数
def default_factory():
    return {'count': 0, 'total': 0}

dd_custom = defaultdict(default_factory)
dd_custom['a']['count'] += 1
dd_custom['a']['total'] += 10
print(dd_custom)         # 输出: defaultdict(<function default_factory...>, {'a': {'count': 1, 'total': 10}})
```

### 5. OrderedDict - 有序字典

```python
from collections import OrderedDict

# 创建有序字典
od = OrderedDict()
od['a'] = 1
od['b'] = 2
od['c'] = 3
print(od)                # 输出: OrderedDict([('a', 1), ('b', 2), ('c', 3)])

# 保持插入顺序
od['d'] = 4
print(list(od.keys()))   # 输出: ['a', 'b', 'c', 'd']

# 移动元素到末尾
od.move_to_end('a')
print(list(od.keys()))   # 输出: ['b', 'c', 'd', 'a']

# 弹出元素
last_item = od.popitem(last=True)  # LIFO顺序
first_item = od.popitem(last=False) # FIFO顺序
print(last_item)         # 输出: ('a', 4)
print(first_item)        # 输出: ('b', 2)

# 有序字典相等性测试
od1 = OrderedDict([('a', 1), ('b', 2)])
od2 = OrderedDict([('b', 2), ('a', 1)])
print(od1 == od2)        # 输出: False (顺序不同)
```

### 6. ChainMap - 链式映射

```python
from collections import ChainMap

# 创建ChainMap
dict1 = {'a': 1, 'b': 2}
dict2 = {'b': 3, 'c': 4}
chain = ChainMap(dict1, dict2)

# 查找键 (搜索顺序: dict1 -> dict2)
print(chain['a'])        # 输出: 1 (来自dict1)
print(chain['b'])        # 输出: 2 (来自dict1)
print(chain['c'])        # 输出: 4 (来自dict2)

# 更新操作只影响第一个映射
chain['c'] = 5           # 更新dict1
print(dict1)             # 输出: {'a': 1, 'b': 2, 'c': 5}
print(dict2)             # 输出: {'b': 3, 'c': 4} (未改变)

# 添加新映射
dict3 = {'d': 6}
new_chain = chain.new_child(dict3)
print(new_chain['d'])    # 输出: 6

# 获取所有键 (可能有重复)
print(list(chain.keys()))  # 输出: ['a', 'b', 'c']

# 获取所有值 (可能有重复)
print(list(chain.values()))  # 输出: [1, 2, 5, 3, 4]
```

##  数组初始化
```
611 · 骑士的最短路线
visit = [[False] * n for _ in range(m)]
127 · 拓扑排序
de = [g for g in graph if indegree[g] == 0]
indegree = {x : 0 for x in graph}

dp = [False for _ in range(m)]
dp = [[False] * n for _ in range(m)]
dp = [[[False] * p for _ in range(n)] for _ in range(m)]
```



## 算法复杂度和问题规模

在算法竞赛和实际编程中，时间复杂度与问题规模的关系决定了算法是否能在规定时间内（通常为1秒）完成计算。以下是常见时间复杂度及其能处理的问题规模总结（基于现代计算机约 **10^8 - 10^9 次操作/秒** 的估算）：

---

### **1. O(1) — 常数时间**
- **能处理的规模**：任意大（与输入规模无关）。
- **示例**：哈希表查询、数学公式计算。

---

### **2. O(log n) — 对数时间**
- **能处理的规模**：近乎无限（如 `n ≤ 10^18`）。
- **示例**：二分查找、快速幂、平衡树操作。

---

### **3. O(√n) — 平方根时间**
- **能处理的规模**：`n ≤ 10^14`。
- **示例**：质数判定（试除法）、因数枚举。

---

### **4. O(n) — 线性时间**
- **能处理的规模**：`n ≤ 10^7 - 10^8`。
- **示例**：遍历数组、线性动态规划。

---

### **5. O(n log n) — 线性对数时间**
- **能处理的规模**：`n ≤ 10^5 - 10^6`。
- **示例**：快速排序、归并排序、线段树/树状数组操作。

---

### **6. O(n²) — 平方时间**
- **能处理的规模**：`n ≤ 10^3 - 10^4`。
- **示例**：冒泡排序、朴素动态规划（如最长公共子序列）。

---

### **7. O(n³) — 立方时间**
- **能处理的规模**：`n ≤ 200 - 500`。
- **示例**：Floyd-Warshall 算法、三重循环暴力。

---

### **8. O(2ⁿ) — 指数时间**
- **能处理的规模**：`n ≤ 20 - 25`（递归/暴力搜索）。
- **示例**：子集枚举、暴力回溯。

---

### **9. O(n!) — 阶乘时间**
- **能处理的规模**：`n ≤ 10 - 12`。
- **示例**：全排列生成、旅行商问题（TSP）暴力解。

---

### **关键注意事项**
1. **常数因子**：大O记号忽略常数，但实际中若常数过大（如 `10^6`），可能使 O(n) 算法超时。
2. **内存访问**：缓存友好性（如连续数组遍历 vs 链表跳跃）影响实际速度。
3. **语言差异**：C++ 比 Python/Java 更快，可放宽规模约 2-10 倍。
4. **问题限制**：某些题目时间宽松（如 2-5秒），可适当扩大规模。

---

### **参考对照表**
| 时间复杂度 | 安全规模（C++） | 安全规模（Python） |
| ---------- | --------------- | ------------------ |
| O(n!)      | n ≤ 11          | n ≤ 10             |
| O(2ⁿ)      | n ≤ 24          | n ≤ 20             |
| O(n³)      | n ≤ 500         | n ≤ 200            |
| O(n²)      | n ≤ 10^4        | n ≤ 5×10³          |
| O(n log n) | n ≤ 10^6        | n ≤ 10^5           |
| O(n)       | n ≤ 10^8        | n ≤ 10^7           |

---

通过选择合适的时间复杂度算法，可以避免超时问题。在设计算法时，优先考虑更低时间复杂度的解法，并结合问题约束调整优化。



