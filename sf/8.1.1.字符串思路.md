### 一、基础操作类

1. **LeetCode 344. Reverse String（反转字符串数组）**
    - 双指针：左右指针分别从数组首尾出发，交换元素后向中间移动，直到相遇。时间 O (n)，空间 O (1)。
2. **LeetCode 541. Reverse String II（每 k 个字符反转一次）**
    - 分段处理：遍历字符串，每 2k 个字符为一段，反转前 k 个字符（若剩余不足 k 个则全反转）。用双指针反转每段的前 k 个。
3. **LeetCode 709. To Lower Case（转为小写）**
    - 遍历字符：若为大写字母（'A'-'Z'），通过 `c += 32` 转为小写（ASCII 码差值），其他字符不变。
4. **LeetCode 151. Reverse Words in a String（反转字符串中的单词）**
    - 步骤：① 去除首尾和中间多余空格；② 反转整个字符串；③ 逐个反转每个单词（双指针定位单词边界）。
5. **LeetCode 557. Reverse Words in a String III（反转每个单词的字符）**
    - 遍历字符串，用双指针定位每个单词（空格分隔），反转单词内字符，保持单词顺序不变。
6. **LeetCode 205. Isomorphic Strings（同构字符串）**
    - 双向映射：用两个哈希表分别记录 `s[i]→t[i]` 和 `t[i]→s[i]`，确保字符映射唯一（如 s 中同一字符始终对应 t 中同一字符，反之亦然）。
7. **LeetCode 290. Word Pattern（单词规律）**
    - 类似同构字符串：分割字符串为单词列表，用哈希表建立 `pattern字符→单词` 和 `单词→pattern字符` 的双向映射，检查一致性。
8. **LeetCode 387. First Unique Character in a String（字符串中的第一个唯一字符）**
    - 统计频次：用哈希表记录每个字符出现次数，再遍历字符串找到第一个频次为 1 的字符。
9. **LeetCode 451. Sort Characters By Frequency（根据字符出现频率排序）**
    - 步骤：① 哈希表统计频次；② 按频次降序排序字符（用桶排序或 sort 自定义 comparator）；③ 按频次拼接字符。

### 二、字符串匹配类

1. **LeetCode 28. Find the Index of the First Occurrence in a String（实现 strStr ()）**
    - 暴力法：遍历主串，对每个位置匹配子串，不匹配则回溯（时间 O (n*m)）；或用 KMP 算法（预处理子串生成 next 数组，优化匹配，时间 O (n+m)）。

2. **LeetCode 459. Repeated Substring Pattern（重复的子字符串）**

    判断当前字符串是不是用重复的substring组成的，例如abab是,  abc不是

    - 假设字符串由子串 s 重复 k 次组成，则 `s + s` 中必"包含"(在第一个s中，而不是第二个s开始)原字符串（排除首尾字符后查找）；或枚举可能的子串长度（约数），检查是否能重复构成原串。

        ```
        return (s + s).find(s, 1) != len(s)
        ```

3. **LeetCode 1392. Longest Happy Prefix（最长快乐前缀）**
    - 快乐前缀即 “既是前缀又是后缀的最长子串”，用 KMP 算法的 next 数组：next 数组最后一个值即为最长快乐前缀的长度。 字符串hash

4. **LeetCode 10. Regular Expression Matching（正则表达式匹配，含。和*）** <<
    - 动态规划：`dp[i][j]` 表示 s [0..i-1] 与 p [0..j-1] 是否匹配。分情况讨论：p [j-1] 是普通字符、'.' 或 '*'（* 需考虑匹配 0 次或多次）。

5. **LeetCode 44. Wildcard Matching（通配符匹配，含？和*）** <<
    - 贪心 + 双指针：用 i、j 遍历 s 和 p，star 记录 * 位置，match 记录 s 中与 * 匹配的位置。遇到 * 时记录并跳过，不匹配时回溯到上一个 * 继续尝试。

### 三、回文串相关

1. **LeetCode 125. Valid Palindrome（验证回文串）**
    - 预处理：过滤非字母数字字符，转为小写；双指针从首尾向中间移动，比较字符是否相等。

2. **LeetCode 680. Valid Palindrome II（最多删除一个字符判断回文）**

    最多删除一个。有可能不删除。

    1. 先将两边相同的排除l+1 r-1
    2. 第一次遇到的不相同的字符，这两个必然需要删掉一个，因为不相同
    3. 删除头部的字符，或者删除尾部的字符，判断

    ```
    if (isPal(s, nl, r) || isPal(s, l, nr))
                return true;
    ```

    - 双指针：遇到不相等的字符时，尝试跳过左字符或右字符，递归 / 迭代检查剩余子串是否为回文（最多一次跳过）。

3. **LeetCode 5. Longest Palindromic Substring（最长回文子串）**

    - 中心扩展法：以每个字符（或两个字符中间）为中心，向两边扩展，记录最长回文子串（时间 O (n²)）；或动态规划（**`dp[i][j]` 表示 s [i..j] 是否为回文**）。

    - 区间dp

        ```
                 for i in range(L):
                    dp[i][i] = True
                    
         for M in range(1, L + 1):
                    for i in range(L - M + 1):
                        j = i + M - 1
                        if s[i] == s[j]:
                            if i + 1 > j - 1 or dp[i + 1][j - 1]:
                                dp[i][j] = True
                                mlen = M
                                mstr = s[i: j + 1] 
                return mstr
        ```

        i + 1 > j - 1 表示当i == j 或者i +1 = j 的时候（长度是1或者2的），`dp[i][j]` 肯定是true，肯定是回文串，s[i] == s[j]

4. **LeetCode 516. Longest Palindromic Subsequence（最长回文子序列）**

    - 动态规划：`dp[i][j]` 表示 s [i..j] 中最长回文子序列长度。若 s [i] == s [j]，则 `dp[i][j] = dp[i+1][j-1] + 2`；否则取 `max(dp[i+1][j], dp[i][j-1])`。

        ```
                 for (int i = 0; i < m; i++)
                {
                    dp[i][i] = 1;
                }
               
         for (int len = 2; len <= m; len++)
                {
                    for(int i = 0; i < m - len + 1; i++)
                    {
                        int j = i + len - 1;
                        if (s[i] == s[j])
                        {
                            dp[i][j] = dp[i + 1][j - 1] + 2;
                        }
                        else
                        {
                            dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
                        }
                    }
                }
                return dp[0][m - 1];
        ```

        

5. **LeetCode 266. Palindrome Permutation（回文排列, 判断给定字符串的某个排列是否是回文,整个字符串）**

    如果出现两次奇数则返回false

    - 统计字符频次：回文排列要求最多一个字符出现奇数次（奇数长度时中间字符），其他均为偶数次。用哈希表或位运算检查。

6. **LeetCode 409. Longest Palindrome（最长回文串）**

    1.偶数次直接加到res 2. 奇数次的减1将其余的偶数部分加到res 3.如果存在奇数，最后res += 1

    - 统计频次：所有偶数频次直接相加，奇数频次取最大偶数（减 1），最后若有剩余奇数可加 1（作为中间字符）。

### 四、字符串修改与拼接

1. **LeetCode 392. Is Subsequence（判断子序列）**

    两个字符串s和t, 判断s是否是t的子序列  **注意是子序列，不是子串**

    - 双指针：i 遍历 s（子序列），j 遍历 t（主串）。若 s [i] == t [j]，i++；j 遍历完后，若 i 达到 s 长度则为子序列。

        ```
            def is_subsequence(self, s: str, t: str) -> bool:
                i, j = 0, 0
                while i < len(s) and j < len(t):
                    if s[i] == t[j]:
                        i += 1
                    j += 1
                return i == len(s)
        ```

        

2. **LeetCode 910. Remove All Occurrences of a Substring（删除子串的所有出现）**栈

    ```
    class Solution:
        def removeOccurrences(self, s: str, part: str) -> str:
            m = len(part)
            res = ""
            for ch in s:
                # 模拟从左至右匹配的过程
                res += ch
                if len(res) >= m and res[-m:] == part:
                    # 如果匹配成功，那么删去对应后缀
                    res = res[:-m]
            return res
    ```

    

    - 栈模拟：遍历字符串，将字符入栈，当栈长度大于part，**且栈中的字符串尾字符和part尾字符相同**，检查是否匹配，匹配则弹出对应字符（相当于删除）。

        ```
        class Solution:
            def removeOccurrences(self, s: str, part: str) -> str:
                res = ""
                m = len(part)
                for c in s:
                    res += c
                    if len(res) >= len(part) and res[-1] == part[-1] and res[-m:] == part:
                        res = res[:-m]
                return res
        ```

        

3. **LeetCode 8. String to Integer (atoi)（字符串转整数）**
    - 分步处理：① 跳过前导空格；② 处理正负号；③ 提取连续数字，检查溢出（超过 int 范围则截断为边界值）。
    - `INT_MIN, INT_MAX = -2**31, 2**31 - 1`
    
4. **LeetCode 14. Longest Common Prefix（最长公共前缀）**

> 用第一个字符串作为基准就可以，如果其他字符串长于第一个字符串，前缀肯定在第一个字符串内。
> 纵向比较`strs[0][i]`的字符，第一个不同出现的时候那当前prefix即为结果
> 纵向循环，每循环一边结束就将这次循环的`strs[0][i]`加入prefix的末尾
> 全部循环完，返回prefix<

- 纵向比较：以第一个字符串为基准，逐个字符与其他字符串对应位置比较，直到不匹配或某字符串结束。

    ```
            for i in range(m):
                for j in range(1, len(strs)):
                    if i >= len(strs[j]) or strs[0][i] != strs[j][i]:
                        return prefix
                prefix += strs[0][i]
            return prefix
    ```

5. **LeetCode 415. Add Strings（字符串相加）**

    > 保证num1长度长于num2 ，用if else

    > 先将两个数的字符串反转

    > 用num1的长度开始循环每个位的数字，如果num2对用位置有数则加上，没有不加，算进位
    >
    > 最终将最终进位加到最后一位
    >
    > 最后反转

    - 模拟加法：双指针从两字符串末尾出发，逐位相加，记录进位，结果逆序拼接（处理不同长度和剩余进位）。

6. **LeetCode 43. Multiply Strings（字符串相乘）**
    - 模拟乘法：两数长度为 m、n，结果最多 m+n 位。用数组记录每位乘积，再处理进位，最后转为字符串（跳过前导 0）。

### 五、动态规划相关字符串题

1. **LeetCode 1143. Longest Common Subsequence（LCS）** (最长公共子序列)

    - 动态规划：`dp[i][j]` 表示 text1 [0..i-1] 与 text2 [0..j-1] 的 LCS 长度。若字符相等，`dp[i][j] = dp[i-1][j-1] + 1`；否则取 `max(dp[i-1][j], dp[i][j-1])`。

     f [ i \]\[ j ] 为第一个序列前i个字符中，和第二个序列前j个字符中的公共序列。所有在第一个序列的前i个字母中出现的，且在第二个序列中的前j个字母中出现的子序列

       转移方程是看最后一个字符是否选取，

     	1. a[i],b[j], 都选‘f[i - 1\][j - 1] + 1’ 
     	2. 都不选 f[i - 1\][j - 1]
     	3. 选a[i]  `f[i - 1][j]`
     	4. 选b[j]  `f[i][j - 1]`

    其中情况2被包含在情况3，4中，因此不需要考虑

    含有i-1，j-1这种dp一般遍历都从1开始，dp长度len + 1

       ```
    class Solution:
        def longestCommonSubsequence(self, text1: str, text2: str) -> int:
            l1 = len(text1)
            l2 = len(text2)
            # 初始化 (l2+1) 行、(l1+1) 列的全 0 二维数组（避免索引越界）
            f = [[0] * (l1 + 1) for _ in range(l2 + 1)]
            
            # 循环范围修正：i 对应 text2（行），j 对应 text1（列），从 1 开始到长度
            for i in range(1, l2 + 1):
                for j in range(1, l1 + 1):
                    # 取上方或左方的最大值
                    f[i][j] = max(f[i - 1][j], f[i][j - 1])
                    # 若当前字符相同，取左上角 +1
                    if text2[i - 1] == text1[j - 1]:  # 注意字符串索引需减 1（因为 i/j 从 1 开始）
                        f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1)
            
            return f[l2][l1]  # 返回最终右下角的结果
       ```

       

2. **LeetCode 72. Edit Distance（编辑距离）**

    给定两个字符src, dest，求用最少步数将src转换位dest，步骤只能用3中insert, delete, replace。

    

    - 动态规划：`dp[i][j]` 表示 word1 [0..i-1] 到 word2 [0..j-1] 的最小步数。若字符相等，`dp[i][j] = dp[i-1][j-1]`；否则取 `min(插入、删除、替换) + 1`。

        含有i-1，j-1这种dp一般遍历都从1开始，dp长度len + 1

        ```
        `f[i][j]`为word1前i个字符到word2的前j个字符的转化的最小步。 由于要计算i - 1 j - 1，为了方便dp都从1开始算，原始的word前面加一个" "
        含有i-1，j-1这种dp一般遍历都从1开始，dp长度len + 1
        
           > - 在word1中插入一个字符，相当于`dp[i][j - 1] + 1`，消消乐
           > - 在word1中删除一个字符，相当于`dp[i - 1][j] + 1`，消消乐
           > - 在word1和word2修改最后一个字符，相当于`dp[i - 1][j - 1] + 1`，消消乐
           > - word1最后一个字符和word2最后 一个字符相等的话 `dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])`
        这四重情况在一起求一个min   
        dp[i][j] = min(dp[i][j - 1] + 1, dp[i - 1][j] + 1, dp[i - 1][j - 1] + 1, dp[i - 1][j - 1])
        
            def min_distance(self, word1: str, word2: str) -> int:
                m = len(word1)
                n = len(word2)
                if m == 0:
                    return n
                if n == 0:
                    return m
                nword1 = " " + word1
                nword2 = " " + word2
        
                dp = [[0] * (n + 1) for _ in range(m + 1)]
                for i in range(m + 1):
                    dp[i][0] = i
                for j in range(n + 1):
                    dp[0][j] = j
        
                for i in range(1, m + 1):
                    for j in range(1, n + 1):
                        dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1
                        if nword1[i] == nword2[j]:
                            dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
                        else:
                            dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + 1)
                return dp[m][n]
           
        ```

        

3. **LeetCode 115. Distinct Subsequences（不同的子序列）**  <<< 

    - 动态规划：`dp[i][j]` 表示 s [0..i-1] 中 t [0..j-1] 的出现次数。若 s [i-1] == t [j-1]，`dp[i][j] = dp[i-1][j-1] + dp[i-1][j]`；否则 `dp[i][j] = dp[i-1][j]`。

4. **LeetCode 91. Decode Ways（解码方法）**

    字符的映射位A - 1, B- 2.....以此类推，现在给一个数例如 “12” 求这个12 能表示几种解码（2）     AB (1 2) or L (12)

    - 动态规划：`dp[i]` 表示前 i 个字符的解码方式数。若 s [i-1] 不为 '0'，`dp[i] += dp[i-1]`；若 s [i-2..i-1] 是 10-26 之间的数，`dp[i] += dp[i-2]`。

    ```
     类似爬楼梯，算到当前s[i]的方式，相加
    
    直接按下标来写的。其实可以这样考虑，当前位若不为 0，一定可以独立编码，所以 dp[i] = dp[i - 1]，然后再去考虑能不能后两位联合编码，后两位联合编码要满足两个条件：1.前一位不为字符 '0'; 2.这两位构成的数小于等于 26 。如果这两个条件都满足，就在原来的基础加上联合编码的种类 dp[i] += dp[i - 2]，等等！还要考虑越界的问题，也就是 i = 1 时怎么办 ？很简单，就是在前面的基础上加一，这个一指的就是后两位联合编码。
    
    class Solution:
        def numDecodings(self, s: str) -> int:
            if s[0] == '0':
                return 0
            m = len(s)
            f = [0 for _ in range(m)]
            f[0] = 1
            for i in range(1, m):
                if s[i] != '0':
                    f[i] += f[i - 1]
                if s[i - 1] != '0' and (int(s[i - 1]) * 10 + int(s[i])) <= 26:
                    if i > 1:
                        f[i] += f[i - 2]
                    else:
                        f[i] += 1
            return f[m - 1]
    ```

    

### 六、哈希表结合字符串

1. **LeetCode 242. Valid Anagram（有效的字母异位词）**

    异位单词：Two strings are anagram if they can be the same after change the order of characters.

    - 哈希表 / 数组统计频次：两字符串长度必须相等，统计每个字符出现次数，比较是否完全一致。

        排序，比较是否相等

2. **LeetCode 49. Group Anagrams（字母异位词分组）**

    给出一个单词列表，将能互相异构的单词分到同一组 ["eat","tea","bat"]  -->> [["eat","tea"], ["bat"]]

    - 哈希表分组：对每个单词排序（排序后相同的为异位词），以排序结果为 key，原单词为 value 存入哈希表，最后取 values 即为分组。

        可以先排序，然后hash

3. **LeetCode 438. Find All Anagrams in a String（找到所有字母异位词）**

    ```
    Input : s =  "cbaebabacd", p = "abc"
    Output : [0, 6]          cba 和 acd 都是p的异构
    ```

    - 滑动窗口 + 哈希表：用数组记录目标子串的字符频次，窗口在主串中滑动，维护窗口内频次，与目标比对，一致则记录起始索引。

        ```
            def findAnagrams(self, s: str, p: str) -> List[int]:
                m = len(s)
                n = len(p)
                if n > m:
                    return []
                hs = [0] * 26
                hp = [0] * 26
                for i in range(n):
                    hs[ord(s[i]) - 97] += 1
                    hp[ord(p[i]) - 97] += 1
                res = []
                if hp == hs:
                    res.append(0)
                
                for i in range(m - n):
                    hs[ord(s[i]) - 97] -= 1
                    hs[ord(s[i + n]) - 97] += 1
                    if hs == hp:
                        res.append(i + 1)
                return res
        ```

        

4. **LeetCode 128. Longest Consecutive Sequence（最长连续序列）**

    Given an unsorted array `num` of integers, find the length of the longest consecutive elements sequence.

    ```
    [100, 4, 200, 1, 3, 2]      4
    ```

    - 哈希表去重 + 查找：将数字存入哈希表，遍历每个数，若为序列起点（前一个数不存在），则向后扩展计算连续长度，记录最大值。

        ```
            def longestConsecutive(self, nums: List[int]) -> int:
                if len(nums) == 0:
                    return 0
                m = len(nums)
                ns = set(nums)  # 去重
        
                maxlen = 1
                for c in ns:
                    if c - 1 not in ns:   # 前一个数不存在 说明当前的数开始的序列还没有计算过
                        curlen = 1
                        curchr = c
                        while curchr + 1 in ns:
                            curlen += 1
                            maxlen = max(maxlen, curlen)
                            curchr += 1
        
                return maxlen
        ```

        

### 七、其他高频题

1. **LeetCode 20. Valid Parentheses（有效的括号）**
    - 栈匹配：左括号入栈，右括号与栈顶左括号匹配则出栈，不匹配或栈空则无效，最后栈必须为空。

2. **LeetCode 76. Minimum Window Substring（最小覆盖子串）**

    Given two strings `source` and `target`. Return the minimum substring of `source` which contains each char of `target`.

    ``` 
    src="abc", target="ac"    output="abc"
    ```

    - 滑动窗口：用哈希表记录目标字符频次，窗口右扩至包含所有目标字符，再左缩至最小，记录最短窗口。

    - 动一下右边，跟新结果，处理左边

        ```
            def min_window(self, s: str, t: str) -> str:
                sh = collections.defaultdict(int)
                th = collections.defaultdict(int)
                for c in t:
                    th[c] += 1
                
                l = 0
                curlen = 0
                res = ""
                for r in range(len(s)):
                    sh[s[r]] += 1
                    if th[s[r]] and sh[s[r]] <= th[s[r]]:
                        curlen += 1
                    while l < len(s) and sh[s[l]] > th[s[l]]:
                        sh[s[l]] -= 1
                        l += 1
                    if curlen == len(t):
                        if res == "" or len(res) > (r - l + 1):
                            res = s[l:r + 1]
                return res
        ```

        

3. **LeetCode 3. Longest Substring Without Repeating Characters（无重复字符的最长子串）**

    找出字符串中，最长的没有重复字符的字串。“bbbbbb”  最长是 “b”

    - 滑动窗口 + 哈希表：窗口内无重复字符，右指针扩展，遇重复则左指针跳至重复字符下一位，记录最大窗口长度。

          移动窗口右侧，从i开始往后找，直到有重复的。算当前字串长度，更新res。
      
           把s[i]的hash减一，向右移动i

        ```
        class Solution:
            def lengthOfLongestSubstring(self, s: str) -> int:
                m = len(s)
                h = collections.defaultdict(int)
                j = 0
                res = ""
                for i in range(m):
                    while j < m and h[s[j]] == 0:
                        h[s[j]] += 1
                        j += 1
                    if (j - i + 1) > len(res):
                        res = s[i: j]
                    h[s[i]] -= 1
                return len(res)
        ```

        

4. **LeetCode 443. String Compression（字符串压缩）**

    “aabcccccaaa” -> "a2b1c5a3"

    ```\
    def compress(self, s: str) -> str:
        if s == "":
            return ""
    
        cur = s[0]
        count = 1
        res = ""
        for i in range(1, len(s)):
            if cur == s[i]:
                count += 1
            else:
                res += cur + str(count)
                cur = s[i]
                count = 1
        res += cur + str(count)
        if len(res) < len(s):
            return res
        return s
    ```

原地压缩：双指针遍历，count 记录连续字符次数，当前字符与下一个不同时，写入字符和次数（次数 > 1 才写），返回新长度。

三指针：

一个指针标记当前字符，另一个指针找这个字符有连续多少个，最后一个指针标记当前在数组中的读写位置。

```
class Solution:
    def compress(self, chars: List[str]) -> int:
        n = len(chars)
        i = 0
        write = 0
        while i < n:
            j = i
            while j < n and chars[j] == chars[i]:
                j += 1
            chars[write] = chars[i]
            write += 1
            if j - i > 1:
                for c in str(j-i):
                    chars[write] = c
                    write += 1
            i = j
        return write
```

