### 一、基础操作类

1. **LeetCode 344. Reverse String（反转字符串数组）**
    - 双指针：左右指针分别从数组首尾出发，交换元素后向中间移动，直到相遇。时间 O (n)，空间 O (1)。
2. **LeetCode 541. Reverse String II（每 k 个字符反转一次）**
    - 分段处理：遍历字符串，每 2k 个字符为一段，反转前 k 个字符（若剩余不足 k 个则全反转）。用双指针反转每段的前 k 个。
3. **LeetCode 709. To Lower Case（转为小写）**
    - 遍历字符：若为大写字母（'A'-'Z'），通过 `c += 32` 转为小写（ASCII 码差值），其他字符不变。
4. **LeetCode 151. Reverse Words in a String（反转字符串中的单词）**
    - 步骤：① 去除首尾和中间多余空格；② 反转整个字符串；③ 逐个反转每个单词（双指针定位单词边界）。
5. **LeetCode 557. Reverse Words in a String III（反转每个单词的字符）**
    - 遍历字符串，用双指针定位每个单词（空格分隔），反转单词内字符，保持单词顺序不变。
6. **LeetCode 205. Isomorphic Strings（同构字符串）**
    - 双向映射：用两个哈希表分别记录 `s[i]→t[i]` 和 `t[i]→s[i]`，确保字符映射唯一（如 s 中同一字符始终对应 t 中同一字符，反之亦然）。
7. **LeetCode 290. Word Pattern（单词规律）**
    - 类似同构字符串：分割字符串为单词列表，用哈希表建立 `pattern字符→单词` 和 `单词→pattern字符` 的双向映射，检查一致性。
8. **LeetCode 387. First Unique Character in a String（字符串中的第一个唯一字符）**
    - 统计频次：用哈希表记录每个字符出现次数，再遍历字符串找到第一个频次为 1 的字符。
9. **LeetCode 451. Sort Characters By Frequency（根据字符出现频率排序）**
    - 步骤：① 哈希表统计频次；② 按频次降序排序字符（用桶排序或 sort 自定义 comparator）；③ 按频次拼接字符。

### 二、字符串匹配类

1. **LeetCode 28. Find the Index of the First Occurrence in a String（实现 strStr ()）**
    - 暴力法：遍历主串，对每个位置匹配子串，不匹配则回溯（时间 O (n*m)）；或用 KMP 算法（预处理子串生成 next 数组，优化匹配，时间 O (n+m)）。
2. **LeetCode 459. Repeated Substring Pattern（重复的子字符串）**
    - 假设字符串由子串 s 重复 k 次组成，则 `s + s` 中必包含原字符串（排除首尾字符后查找）；或枚举可能的子串长度（约数），检查是否能重复构成原串。
3. **LeetCode 1392. Longest Happy Prefix（最长快乐前缀）**
    - 快乐前缀即 “既是前缀又是后缀的最长子串”，用 KMP 算法的 next 数组：next 数组最后一个值即为最长快乐前缀的长度。
4. **LeetCode 10. Regular Expression Matching（正则表达式匹配，含。和*）**
    - 动态规划：`dp[i][j]` 表示 s [0..i-1] 与 p [0..j-1] 是否匹配。分情况讨论：p [j-1] 是普通字符、'.' 或 '*'（* 需考虑匹配 0 次或多次）。
5. **LeetCode 44. Wildcard Matching（通配符匹配，含？和*）**
    - 贪心 + 双指针：用 i、j 遍历 s 和 p，star 记录 * 位置，match 记录 s 中与 * 匹配的位置。遇到 * 时记录并跳过，不匹配时回溯到上一个 * 继续尝试。

### 三、回文串相关

1. **LeetCode 125. Valid Palindrome（验证回文串）**
    - 预处理：过滤非字母数字字符，转为小写；双指针从首尾向中间移动，比较字符是否相等。
2. **LeetCode 680. Valid Palindrome II（最多删除一个字符判断回文）**
    - 双指针：遇到不相等的字符时，尝试跳过左字符或右字符，递归 / 迭代检查剩余子串是否为回文（最多一次跳过）。
3. **LeetCode 5. Longest Palindromic Substring（最长回文子串）**
    - 中心扩展法：以每个字符（或两个字符中间）为中心，向两边扩展，记录最长回文子串（时间 O (n²)）；或动态规划（`dp[i][j]` 表示 s [i..j] 是否为回文）。
4. **LeetCode 516. Longest Palindromic Subsequence（最长回文子序列）**
    - 动态规划：`dp[i][j]` 表示 s [i..j] 中最长回文子序列长度。若 s [i] == s [j]，则 `dp[i][j] = dp[i+1][j-1] + 2`；否则取 `max(dp[i+1][j], dp[i][j-1])`。
5. **LeetCode 266. Palindrome Permutation（回文排列）**
    - 统计字符频次：回文排列要求最多一个字符出现奇数次（奇数长度时中间字符），其他均为偶数次。用哈希表或位运算检查。
6. **LeetCode 409. Longest Palindrome（最长回文串）**
    - 统计频次：所有偶数频次直接相加，奇数频次取最大偶数（减 1），最后若有剩余奇数可加 1（作为中间字符）。

### 四、字符串修改与拼接

1. **LeetCode 392. Is Subsequence（判断子序列）**
    - 双指针：i 遍历 s（子序列），j 遍历 t（主串）。若 s [i] == t [j]，i++；j 遍历完后，若 i 达到 s 长度则为子序列。
2. **LeetCode 910. Remove All Occurrences of a Substring（删除子串的所有出现）**
    - 栈模拟：遍历字符串，将字符入栈，若栈尾长度等于子串长度，检查是否匹配，匹配则弹出对应字符（相当于删除）。
3. **LeetCode 8. String to Integer (atoi)（字符串转整数）**
    - 分步处理：① 跳过前导空格；② 处理正负号；③ 提取连续数字，检查溢出（超过 int 范围则截断为边界值）。
4. **LeetCode 14. Longest Common Prefix（最长公共前缀）**
    - 纵向比较：以第一个字符串为基准，逐个字符与其他字符串对应位置比较，直到不匹配或某字符串结束。
5. **LeetCode 415. Add Strings（字符串相加）**
    - 模拟加法：双指针从两字符串末尾出发，逐位相加，记录进位，结果逆序拼接（处理不同长度和剩余进位）。
6. **LeetCode 43. Multiply Strings（字符串相乘）**
    - 模拟乘法：两数长度为 m、n，结果最多 m+n 位。用数组记录每位乘积，再处理进位，最后转为字符串（跳过前导 0）。

### 五、动态规划相关字符串题

1. **LeetCode 1143. Longest Common Subsequence（LCS）**
    - 动态规划：`dp[i][j]` 表示 text1 [0..i-1] 与 text2 [0..j-1] 的 LCS 长度。若字符相等，`dp[i][j] = dp[i-1][j-1] + 1`；否则取 `max(dp[i-1][j], dp[i][j-1])`。
2. **LeetCode 72. Edit Distance（编辑距离）**
    - 动态规划：`dp[i][j]` 表示 word1 [0..i-1] 到 word2 [0..j-1] 的最小步数。若字符相等，`dp[i][j] = dp[i-1][j-1]`；否则取 `min(插入、删除、替换) + 1`。
3. **LeetCode 115. Distinct Subsequences（不同的子序列）**
    - 动态规划：`dp[i][j]` 表示 s [0..i-1] 中 t [0..j-1] 的出现次数。若 s [i-1] == t [j-1]，`dp[i][j] = dp[i-1][j-1] + dp[i-1][j]`；否则 `dp[i][j] = dp[i-1][j]`。
4. **LeetCode 91. Decode Ways（解码方法）**
    - 动态规划：`dp[i]` 表示前 i 个字符的解码方式数。若 s [i-1] 不为 '0'，`dp[i] += dp[i-1]`；若 s [i-2..i-1] 是 10-26 之间的数，`dp[i] += dp[i-2]`。

### 六、哈希表结合字符串

1. **LeetCode 242. Valid Anagram（有效的字母异位词）**
    - 哈希表 / 数组统计频次：两字符串长度必须相等，统计每个字符出现次数，比较是否完全一致。
2. **LeetCode 49. Group Anagrams（字母异位词分组）**
    - 哈希表分组：对每个单词排序（排序后相同的为异位词），以排序结果为 key，原单词为 value 存入哈希表，最后取 values 即为分组。
3. **LeetCode 438. Find All Anagrams in a String（找到所有字母异位词）**
    - 滑动窗口 + 哈希表：用数组记录目标子串的字符频次，窗口在主串中滑动，维护窗口内频次，与目标比对，一致则记录起始索引。
4. **LeetCode 128. Longest Consecutive Sequence（最长连续序列）**
    - 哈希表去重 + 查找：将数字存入哈希表，遍历每个数，若为序列起点（前一个数不存在），则向后扩展计算连续长度，记录最大值。

### 七、其他高频题

1. **LeetCode 20. Valid Parentheses（有效的括号）**
    - 栈匹配：左括号入栈，右括号与栈顶左括号匹配则出栈，不匹配或栈空则无效，最后栈必须为空。
2. **LeetCode 76. Minimum Window Substring（最小覆盖子串）**
    - 滑动窗口：用哈希表记录目标字符频次，窗口右扩至包含所有目标字符，再左缩至最小，记录最短窗口。
3. **LeetCode 3. Longest Substring Without Repeating Characters（无重复字符的最长子串）**
    - 滑动窗口 + 哈希表：窗口内无重复字符，右指针扩展，遇重复则左指针跳至重复字符下一位，记录最大窗口长度。
4. **LeetCode 443. String Compression（字符串压缩）**
    - 原地压缩：双指针遍历，count 记录连续字符次数，当前字符与下一个不同时，写入字符和次数（次数 > 1 才写），返回新长度。