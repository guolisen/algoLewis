[TOC]



### 一、树与二叉树层序遍历（BFS 基础场景）

#### 1. 二叉树的层序遍历 → **LeetCode 102. Binary Tree Level Order Traversal**
#### 2. 二叉树的层序遍历 II → **LeetCode 107. Binary Tree Level Order Traversal II**（自底向上）
#### 3. 二叉树的锯齿形层序遍历 → **LeetCode 103. Binary Tree Zigzag Level Order Traversal**
#### 4. 二叉树的右视图 → **LeetCode 199. Binary Tree Right Side View**（层序取最后一个节点）
#### 5. 填充每个节点的下一个右侧节点指针 → **LeetCode 116. Populating Next Right Pointers in Each Node**
#### 6. 找树左下角的值 → **LeetCode 513. Find Bottom Left Tree Value**（层序取最后一层第一个节点）
#### 7. 二叉树的最小深度 → **LeetCode 111. Minimum Depth of Binary Tree**（BFS 更高效，找到叶子即返回）

### 二、图与网格相关（最短路径 / 连通性）

#### 1. 岛屿数量 → **LeetCode 200. Number of Islands**（网格 BFS，经典入门）
#### 2. 岛屿的最大面积 → **LeetCode 695. Max Area of Island**
#### 3. 被围绕的区域 → **LeetCode 130. Surrounded Regions**（边界 BFS 标记未被围绕的区域）
#### 4. 太平洋大西洋水流问题 → **LeetCode 417. Pacific Atlantic Water Flow**（双向 BFS）
#### 5. 腐烂的橘子 → **LeetCode 994. Rotting Oranges**（多源 BFS，求最短腐烂时间）
#### 6. 01 矩阵 → **LeetCode 542. 01 Matrix**（多源 BFS，求每个 1 到最近 0 的最短距离）
#### 7. 墙与门 → **LeetCode 286. Walls and Gates**（多源 BFS，类似 01 矩阵）
#### 8. 课程表 → **LeetCode 207. Course Schedule**（拓扑排序 + BFS 入度统计）
#### 9. 课程表 II → **LeetCode 210. Course Schedule II**（BFS 拓扑排序输出路径）

### 三、最短路径问题（无权图 / 简单权重）

#### 1. 二叉树的最小深度 → **LeetCode 111. Minimum Depth of Binary Tree**（树的最短路径）
#### 2. 单词接龙 → **LeetCode 127. Word Ladder**（无权图最短路径，BFS 核心题）

```
class Solution:
    """
    @param start: a string
    @param end: a string
    @param dict: a set of string
    @return: An integer
    """
    def ladder_length(self, start: str, end: str, dict: Set[str]) -> int:
        dict.add(end)
        q = collections.deque([start])
        inc = "abcdefghijklmnopqrstuvwxyz"
        dist = collections.defaultdict(int)
        dist[start] = 1
        while len(q) > 0:
            cur = q.popleft()
            if cur == end:
                return dist[cur]
            for i in range(len(cur)):
                for c in inc:
                    l, r = cur[:i], cur[i+1:]
                    nw = l + str(c) + r
                    if nw not in dict or nw in dist:
                        continue
                    dist[nw] = dist[cur] + 1
                    q.append(nw)
        return -1 
```

方法2：1. 建立邻接表图  2. 从start和end同时开始双向bfs

#### 3. 单词接龙 II → **LeetCode 126. Word Ladder II**（最短路径 + 所有路径收集，BFS+DFS）

从 end 到 start 做一次 BFS，并且把距离 end 的距离都保存在 distance 中。
然后在从 start 到 end 做一次 DFS，每走一步必须确保离 end 的 distance 越来越近。

与另外一个代码中提前建立 index 不同，这里是在寻找下一个变换单词的时候，再去获得对应的单词列表。一个单词最多有 L 个字符，每个字符有 25 种不同的变化（26个字母除掉这个位置上的字母），然后 check 一下在不在 dict 里就知道是不是 next word 了。

```
class Solution:
    """
    @param start: a string
    @param end: a string
    @param dict: a set of string
    @return: a list of lists of string
             we will sort your return value in output
    """
    def getNextWord(self, word, dt):
        res = []
        s = "abcdefghijklmnopqrstuvwxyz"
        for i in range(len(word)):
            l, r = word[:i], word[i + 1:]
            for c in s:
                nw = l + c + r
                if nw not in dt or nw == word:
                    continue
                res.append(nw)
        return res
    def bfs(self, start, dt, dist):
        q = collections.deque([start])
        while len(q) > 0:
            cur = q.popleft()
            nextwords = self.getNextWord(cur, dt)
            for w in nextwords:
                if w not in dist:
                    dist[w] = dist[cur] + 1
                    q.append(w)
    def dfs(self, start, end, dt, dist, path, res):
        if start == end:
            res.append(list(path))
            return
        nextwords = self.getNextWord(start, dt)
        for w in nextwords:
            if dist[start] - 1 == dist[w]:
                path.append(str(w))
                self.dfs(w, end, dt, dist, path, res)
                path.pop()

    def find_ladders(self, start: str, end: str, dict: Set[str]) -> List[List[str]]:
        dict.add(start)
        dict.add(end)
        dist = collections.defaultdict(int)
        self.bfs(end, dict, dist)
        path = [str(start)]
        res = []
        self.dfs(start, end, dict, dist, path, res)
        return res
```

记录bfs路径

```
from collections import deque
from typing import List, Dict, Optional

def bfs_shortest_path(graph: Dict[int, List[int]], start: int, target: int) -> Optional[List[int]]:
    """
    BFS寻找最短路径并返回路径列表
    
    参数:
        graph: 邻接表表示的图
        start: 起点
        target: 目标节点
    
    返回:
        最短路径列表（从start到target），若不可达则返回None
    """
    if start not in graph or target not in graph:
        return None  # 节点不在图中
    
    visited = set()          # 记录已访问节点，避免重复
    queue = deque([start])   # BFS队列
    visited.add(start)
    prev = {}                # 存储前驱节点：key是当前节点，value是前驱
    
    # BFS遍历
    while queue:
        current = queue.popleft()
        
        if current == target:
            break  # 首次到达目标，退出循环
        
        # 遍历邻居节点
        for neighbor in graph[current]:
            if neighbor not in visited:
                visited.add(neighbor)
                prev[neighbor] = current  # 记录前驱
                queue.append(neighbor)
    
    # 若目标节点没有前驱，说明不可达
    if target not in prev and start != target:
        return None
    
    # 回溯重建路径
    path = []
    current = target
    while current != start:
        path.append(current)
        current = prev[current]  # 向前驱移动
    path.append(start)  # 加入起点
    path.reverse()      # 反转得到正确顺序
    
    return path


# 示例使用
if __name__ == "__main__":
    # 邻接表表示图
    graph = {
        0: [1, 2],
        1: [0, 3],
        2: [0, 3],
        3: [1, 2, 4],
        4: [3]
    }
    start = 0
    target = 4
    path = bfs_shortest_path(graph, start, target)
    print(f"从 {start} 到 {target} 的最短路径: {path}")  # 输出: [0, 1, 3, 4] 或 [0, 2, 3, 4]
```



#### 4. 打开转盘锁 → **LeetCode 752. Open the Lock**（多源 BFS，求最少转动次数）
#### 5. 完全平方数 → **LeetCode 279. Perfect Squares**（BFS 求最少平方数之和）
#### 6. 最小基因变化 → **LeetCode 433. Minimum Genetic Mutation**（类似单词接龙，BFS）

### 四、其他高频 BFS 题

#### 1. 二叉树的序列化与反序列化 → **LeetCode 297. Serialize and Deserialize Binary Tree**（BFS 层序序列化）
#### 2. 找所有可达节点 → **LeetCode 886. Possible Bipartition**（二分图判断 + BFS）
#### 3. 层数最深叶子节点的和 → **LeetCode 1302. Deepest Leaves Sum**（层序遍历求和）
#### 4. 二叉搜索树的最近公共祖先 → **LeetCode 235. Lowest Common Ancestor of a Binary Search Tree**（BFS 迭代实现）
#### 5. 二叉树的最近公共祖先 → **LeetCode 236. Lowest Common Ancestor of a Binary Tree**（BFS 记录父节点）