[TOC]



### 一、树与二叉树层序遍历（BFS 基础场景）

#### 1. 二叉树的层序遍历 → **LeetCode 102. Binary Tree Level Order Traversal**
#### 2. 二叉树的层序遍历 II → **LeetCode 107. Binary Tree Level Order Traversal II**（自底向上）
#### 3. 二叉树的锯齿形层序遍历 → **LeetCode 103. Binary Tree Zigzag Level Order Traversal**
#### 4. 二叉树的右视图 → **LeetCode 199. Binary Tree Right Side View**（层序取最后一个节点）
#### 5. 填充每个节点的下一个右侧节点指针 → **LeetCode 116. Populating Next Right Pointers in Each Node**
#### 6. 找树左下角的值 → **LeetCode 513. Find Bottom Left Tree Value**（层序取最后一层第一个节点）
#### 7. 二叉树的最小深度 → **LeetCode 111. Minimum Depth of Binary Tree**（BFS 更高效，找到叶子即返回）

### 二、图与网格相关（最短路径 / 连通性）

#### 1. 岛屿数量 → **LeetCode 200. Number of Islands**（网格 BFS，经典入门）
#### 2. 岛屿的最大面积 → **LeetCode 695. Max Area of Island**
#### 3. 被围绕的区域 → **LeetCode 130. Surrounded Regions**（边界 BFS 标记未被围绕的区域）
#### 4. 太平洋大西洋水流问题 → **LeetCode 417. Pacific Atlantic Water Flow**（双向 BFS）
#### 5. 腐烂的橘子 → **LeetCode 994. Rotting Oranges**（多源 BFS，求最短腐烂时间）
#### 6. 01 矩阵 → **LeetCode 542. 01 Matrix**（多源 BFS，求每个 1 到最近 0 的最短距离）
#### 7. 墙与门 → **LeetCode 286. Walls and Gates**（多源 BFS，类似 01 矩阵）
#### 8. 课程表 → **LeetCode 207. Course Schedule**（拓扑排序 + BFS 入度统计）
#### 9. 课程表 II → **LeetCode 210. Course Schedule II**（BFS 拓扑排序输出路径）

### 三、最短路径问题（无权图 / 简单权重）

#### 1. 二叉树的最小深度 → **LeetCode 111. Minimum Depth of Binary Tree**（树的最短路径）
#### 2. 单词接龙 → **LeetCode 127. Word Ladder**（无权图最短路径，BFS 核心题）

```
class Solution:
    """
    @param start: a string
    @param end: a string
    @param dict: a set of string
    @return: An integer
    """
    def ladder_length(self, start: str, end: str, dict: Set[str]) -> int:
        dict.add(end)
        q = collections.deque([start])
        inc = "abcdefghijklmnopqrstuvwxyz"
        dist = collections.defaultdict(int)
        dist[start] = 1
        while len(q) > 0:
            cur = q.popleft()
            if cur == end:
                return dist[cur]
            for i in range(len(cur)):
                for c in inc:
                    l, r = cur[:i], cur[i+1:]
                    nw = l + str(c) + r
                    if nw not in dict or nw in dist:
                        continue
                    dist[nw] = dist[cur] + 1
                    q.append(nw)
        return -1 
```

方法2：1. 建立邻接表图  2. 从start和end同时开始双向bfs

```
from collections import deque
from typing import List

class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        # 第一步：将单词列表转为集合，方便快速查询
        word_set = set(wordList)
        if endWord not in word_set:
            return 0  # 终点不在单词列表中，直接返回0
        
        # 双向BFS的两个队列和访问集合
        begin_queue = deque([beginWord])
        end_queue = deque([endWord])
        begin_visited = {beginWord: 1}  # 记录单词到起点的步数
        end_visited = {endWord: 1}      # 记录单词到终点的步数
        
        # 生成当前单词的所有候选词（替换单个字符为a-z）
        def get_neighbors(word):
            neighbors = []
            chars = list(word)
            for i in range(len(chars)):
                original_char = chars[i]
                # 替换当前位置为a-z的任意字符
                for c in 'abcdefghijklmnopqrstuvwxyz':
                    if c == original_char:
                        continue
                    chars[i] = c
                    neighbor = ''.join(chars)
                    if neighbor in word_set:
                        neighbors.append(neighbor)
                chars[i] = original_char  # 恢复原字符
            return neighbors
        
        # 双向BFS核心循环
        while begin_queue and end_queue:
            # 优先扩展规模更小的队列，减少搜索量
            if len(begin_queue) > len(end_queue):
                # 交换队列和访问集合，始终扩展begin_queue
                begin_queue, end_queue = end_queue, begin_queue
                begin_visited, end_visited = end_visited, begin_visited
            
            # 处理当前队列的一层
            current_size = len(begin_queue)
            for _ in range(current_size):
                current_word = begin_queue.popleft()
                current_step = begin_visited[current_word]
                
                # 生成所有候选邻居
                for neighbor in get_neighbors(current_word):
                    # 相遇：邻居在终点的访问集合中，返回总步数
                    if neighbor in end_visited:
                        return current_step + end_visited[neighbor]
                    # 未访问过，加入队列和访问集合
                    if neighbor not in begin_visited:
                        begin_visited[neighbor] = current_step + 1
                        begin_queue.append(neighbor)
        
        # 两个队列都空了仍未相遇，无路径
        return 0
```

```
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        def addWord(word: str):
            if word not in wordId:
                nonlocal nodeNum
                wordId[word] = nodeNum
                nodeNum += 1
        
        def addEdge(word: str):
            addWord(word)
            id1 = wordId[word]
            chars = list(word)
            for i in range(len(chars)):
                tmp = chars[i]
                chars[i] = "*"
                newWord = "".join(chars)
                addWord(newWord)
                id2 = wordId[newWord]
                edge[id1].append(id2)
                edge[id2].append(id1)
                chars[i] = tmp

        wordId = dict()
        edge = collections.defaultdict(list)
        nodeNum = 0

        for word in wordList:
            addEdge(word)
        
        addEdge(beginWord)
        if endWord not in wordId:
            return 0
        
        disBegin = [float("inf")] * nodeNum
        beginId = wordId[beginWord]
        disBegin[beginId] = 0
        queBegin = collections.deque([beginId])

        disEnd = [float("inf")] * nodeNum
        endId = wordId[endWord]
        disEnd[endId] = 0
        queEnd = collections.deque([endId])

        while queBegin or queEnd:
            queBeginSize = len(queBegin)
            for _ in range(queBeginSize):
                nodeBegin = queBegin.popleft()
                if disEnd[nodeBegin] != float("inf"):
                    return (disBegin[nodeBegin] + disEnd[nodeBegin]) // 2 + 1
                for it in edge[nodeBegin]:
                    if disBegin[it] == float("inf"):
                        disBegin[it] = disBegin[nodeBegin] + 1
                        queBegin.append(it)

            queEndSize = len(queEnd)
            for _ in range(queEndSize):
                nodeEnd = queEnd.popleft()
                if disBegin[nodeEnd] != float("inf"):
                    return (disBegin[nodeEnd] + disEnd[nodeEnd]) // 2 + 1
                for it in edge[nodeEnd]:
                    if disEnd[it] == float("inf"):
                        disEnd[it] = disEnd[nodeEnd] + 1
                        queEnd.append(it)
        
        return 0

```



#### 3. 单词接龙 II → **LeetCode 126. Word Ladder II**（最短路径 + 所有路径收集，BFS+DFS）

从 end 到 start 做一次 BFS，并且把距离 end 的距离都保存在 distance 中。
然后在从 start 到 end 做一次 DFS，每走一步必须确保离 end 的 distance 越来越近。

与另外一个代码中提前建立 index 不同，这里是在寻找下一个变换单词的时候，再去获得对应的单词列表。一个单词最多有 L 个字符，每个字符有 25 种不同的变化（26个字母除掉这个位置上的字母），然后 check 一下在不在 dict 里就知道是不是 next word 了。

getNextWord

```
class Solution:
    """
    @param start: a string
    @param end: a string
    @param dict: a set of string
    @return: a list of lists of string
             we will sort your return value in output
    """
    def getNextWord(self, word, dt):
        res = []
        s = "abcdefghijklmnopqrstuvwxyz"
        for i in range(len(word)):
            l, r = word[:i], word[i + 1:]
            for c in s:
                nw = l + c + r
                if nw not in dt or nw == word:
                    continue
                res.append(nw)
        return res
    def bfs(self, start, dt, dist):
        q = collections.deque([start])
        while len(q) > 0:
            cur = q.popleft()
            nextwords = self.getNextWord(cur, dt)
            for w in nextwords:
                if w not in dist:
                    dist[w] = dist[cur] + 1
                    q.append(w)
    def dfs(self, start, end, dt, dist, path, res):
        if start == end:
            res.append(list(path))
            return
        nextwords = self.getNextWord(start, dt)
        for w in nextwords:
            if dist[start] - 1 == dist[w]:
                path.append(str(w))
                self.dfs(w, end, dt, dist, path, res)
                path.pop()

    def find_ladders(self, start: str, end: str, dict: Set[str]) -> List[List[str]]:
        dict.add(start)
        dict.add(end)
        dist = collections.defaultdict(int)
        self.bfs(end, dict, dist)
        path = [str(start)]
        res = []
        self.dfs(start, end, dict, dist, path, res)
        return res
```

记录bfs路径

```
from collections import deque
from typing import List, Dict, Optional

def bfs_shortest_path(graph: Dict[int, List[int]], start: int, target: int) -> Optional[List[int]]:
    """
    BFS寻找最短路径并返回路径列表
    
    参数:
        graph: 邻接表表示的图
        start: 起点
        target: 目标节点
    
    返回:
        最短路径列表（从start到target），若不可达则返回None
    """
    if start not in graph or target not in graph:
        return None  # 节点不在图中
    
    visited = set()          # 记录已访问节点，避免重复
    queue = deque([start])   # BFS队列
    visited.add(start)
    prev = {}                # 存储前驱节点：key是当前节点，value是前驱
    
    # BFS遍历
    while queue:
        current = queue.popleft()
        
        if current == target:
            break  # 首次到达目标，退出循环
        
        # 遍历邻居节点
        for neighbor in graph[current]:
            if neighbor not in visited:
                visited.add(neighbor)
                prev[neighbor] = current  # 记录前驱
                queue.append(neighbor)
    
    # 若目标节点没有前驱，说明不可达
    if target not in prev and start != target:
        return None
    
    # 回溯重建路径
    path = []
    current = target
    while current != start:
        path.append(current)
        current = prev[current]  # 向前驱移动
    path.append(start)  # 加入起点
    path.reverse()      # 反转得到正确顺序
    
    return path


# 示例使用
if __name__ == "__main__":
    # 邻接表表示图
    graph = {
        0: [1, 2],
        1: [0, 3],
        2: [0, 3],
        3: [1, 2, 4],
        4: [3]
    }
    start = 0
    target = 4
    path = bfs_shortest_path(graph, start, target)
    print(f"从 {start} 到 {target} 的最短路径: {path}")  # 输出: [0, 1, 3, 4] 或 [0, 2, 3, 4]
```



#### 4. 打开转盘锁 → **LeetCode 752. Open the Lock**（多源 BFS，求最少转动次数）
#### 5. 完全平方数 → **LeetCode 279. Perfect Squares**（BFS 求最少平方数之和）
#### 6. 最小基因变化 → **LeetCode 433. Minimum Genetic Mutation**（类似单词接龙，BFS）

### 四、其他高频 BFS 题

#### 1. 二叉树的序列化与反序列化 → **LeetCode 297. Serialize and Deserialize Binary Tree**（BFS 层序序列化）
#### 2. 找所有可达节点 → **LeetCode 886. Possible Bipartition**（二分图判断 + BFS）
#### 3. 层数最深叶子节点的和 → **LeetCode 1302. Deepest Leaves Sum**（层序遍历求和）
#### 4. 二叉搜索树的最近公共祖先 → **LeetCode 235. Lowest Common Ancestor of a Binary Search Tree**（BFS 迭代实现）
#### 5. 二叉树的最近公共祖先 → **LeetCode 236. Lowest Common Ancestor of a Binary Tree**（BFS 记录父节点）