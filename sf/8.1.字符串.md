[toc]



### 一、基础操作类（遍历、转换、分割）

1. **字符串反转** 

#### **LeetCode 344. Reverse String**（反转字符串数组）

   ```
   std::reverse(s.begin(), s.end());
   ```

   ```
   s.reverse()
   ```

   ```
   // s[::-1] 会生成新的list，不会原地修改，上面都是原地修改
   // "".join(reversed(s[::])) 也不是原地修改
   ```

#### **LeetCode 541. Reverse String II**（每 k 个字符反转一次）

   ```
   class Solution:
       def reverseStr(self, s: str, k: int) -> str:
           if len(s) < k:
               return s[::-1]
           if len(s) < 2 * k:
               return s[:k][::-1] + s[k:]
           
           cur = s
           nstr = ""
           while cur != "":
               if len(cur) < k:
                   return nstr + cur[::-1]
               if len(cur) < 2 * k:
                   return nstr + cur[:k][::-1] + cur[k:]
               tmp = cur[:2 * k]
               cur = cur[2 * k:]
               nstr += tmp[:k][::-1] + tmp[k:]
           return nstr
   ```

   ```
   class Solution:
       def reverseStr(self, s: str, k: int) -> str:
           t = list(s)
           for i in range(0, len(t), 2 * k):
               t[i:i+k] = reversed(t[i:i+k])
           return ''.join(t)
   ```

   

2. **字符串大小写转换** 
#### **LeetCode 709. To Lower Case**（转为小写）

   ```
   return s.lower()
   ```

   ```
   class Solution {
   public:
       string toLowerCase(string s) {
           std::transform(s.begin(), s.end(), s.begin(), ::tolower);
           return s;
       }
   };
   ```

   

3. **字符串分割与拼接** 
####  **LeetCode 151. Reverse Words in a String**（反转字符串中的单词）
#### **LeetCode 557. Reverse Words in a String III**（反转每个单词的字符）

   ```
   class Solution:
       def reverseWords(self, s: str) -> str:
           res = s.split()
           res.reverse()
           return " ".join(res)
   ```

   ```
   class Solution:
       def reverseWords(self, s: str) -> str:
           res = s.split()
           n = list()
           for w in res:
               n.append(w[::-1])
           return " ".join(n)
   ```

   

4. **字符串比较与验证** 

#### **LeetCode 205. Isomorphic Strings**（同构字符串）

   ```
   class Solution:
       def isIsomorphic(self, s: str, t: str) -> bool:
           n = len(ls)
           hasha = {}
           hashb = {}
           for i in range(n):
               if hasha.get(s[i]) is not None:
                   if hasha[s[i]] != t[i]:
                       return False
               elif hashb.get(t[i]) is not None:
                   if hashb[t[i]] != s[i]:
                       return False
               else:
                   hasha[s[i]] = t[i]
                   hashb[t[i]] = s[i]
           return True
   ```

#### **LeetCode 290. Word Pattern**（单词规律）

   ```
   class Solution:
       def wordPattern(self, pattern: str, s: str) -> bool:
           tmp = s.split()
           if len(pattern) != len(tmp):
               return False
           ha = {}
           hb = {}
           for i in range(len(pattern)):
               if ha.get(pattern[i]) is not None:
                   if ha[pattern[i]] != tmp[i]:
                       return False
               elif hb.get(tmp[i]) is not None:
                   if hb[tmp[i]] != pattern[i]:
                       return False
               else:
                   ha[pattern[i]] = tmp[i]
                   hb[tmp[i]] = pattern[i]
           return True
   ```

   

5. **字符计数** 
#### **LeetCode 387. First Unique Character in a String**（字符串中的第一个唯一字符）

   ```
   class Solution:
       def firstUniqChar(self, s: str) -> int:
           h = collections.defaultdict(int)
           for c in s:
               h[c] += 1
           for i in range(len(s)):
               if h[s[i]] == 1:
                   return i
           return -1 
   ```

   

#### **LeetCode 451. Sort Characters By Frequency**（根据字符出现频率排序）

   ```
   class Solution {
   public:
       string frequencySort(string s) {
           unordered_map<char, int> hash;
           for (auto c : s)
           {
               hash[c]++;
           }
           struct cmp
           {
               bool operator()(const pair<int, char>& l, const pair<int, char>& r) const
               {
                   return l.first < r.first;
               }
           };
           priority_queue<pair<int, char>, vector<pair<int, char>>, cmp> sh;
           for (auto i : hash)
           {
               sh.push(make_pair(i.second, i.first));
           }
           string res = "";
           while (!sh.empty())
           {
               auto cur = sh.top(); sh.pop();
               for (int c = 0; c < cur.first; c++)
               {
                   res += cur.second;
               }
           }
           return res;
       }
   };
   ```

   

### 二、字符串匹配类（子串、前缀、后缀）

1. **子串查找（暴力 / 哈希 / 前缀函数）** 

#### **LeetCode 28. Find the Index of the First Occurrence in a String**（实现 strStr ()）、

   ```
   class Solution:
       def strStr(self, haystack: str, needle: str) -> int:
           for i in range(len(haystack) - len(needle) + 1):
               if haystack[i: i + len(needle)] == needle:
                   return i
           return -1
   ```

   ```
   class Solution {
   public:
       int strStr(string haystack, string needle) {
           int m = haystack.size();
           int n = needle.size();
           for (int i = 0; i < m - n + 1; i++)
           {
               int idx = i;
               int j = 0;
               for (; j < n; j++)
               {
                   if (haystack[idx] != needle[j])
                       break;
                   idx++;
               }
               if (j == n)
                   return i;
           }
           return -1;
       }
   };
   ```

   

#### **LeetCode 459. Repeated Substring Pattern**（重复的子字符串）

   ```
   class Solution:
       def repeatedSubstringPattern(self, s: str) -> bool:
           return (s + s).find(s, 1) != len(s)
   ```

   

2. **前缀 / 后缀匹配** 
####  **LeetCode 1392. Longest Happy Prefix**（最长快乐前缀）

字符串hash

```
class Solution:
    def longestPrefix(self, s: str) -> str:
        for l in range(len(s) - 1, 0, -1):
            if s[:l] == s[len(s) - l:]:
                return s[:l]
        return ""
```



3. **正则表达式匹配**
####  **LeetCode 10. Regular Expression Matching**（困难，包含 `.` 和 `*`） 
#### **LeetCode 44. Wildcard Matching**（困难，包含 `?` 和 `*`）

### 三、回文串相关

1. **判断回文串**  

#### **LeetCode 125. Valid Palindrome**（验证回文串，忽略非字母数字）

   ```
   class Solution:
       def isPalindrome(self, s: str) -> bool:
           l = s.lower()
           res = "".join(ch for ch in l if ch.isalnum())
           return res == res[::-1]
   ```

   

#### **LeetCode 680. Valid Palindrome II**（最多删除一个字符判断回文）

   ```
   class Solution {
   public:
       bool isPal(const string& s, int& l, int& r)
       {
           while (l >= 0 && r >= 0 && l < r && s[l] == s[r])
           {
               l++; r--;
           }
           if (l >= r)
               return true;
           return false;
       }
       bool validPalindrome(string &s) {
           int m = s.length();
           int l = 0;
           int r = m - 1;
           if (isPal(s, l, r))
           {
               return true;
           }
   
           int nl = l + 1;
           int nr = r - 1;
           if (isPal(s, nl, r) || isPal(s, l, nr))
               return true;
   
           return false;
       }
   };
   ```

   

2. **最长回文子串 / 子序列** 

#### **LeetCode 5. Longest Palindromic Substring**（最长回文子串，动态规划 / 中心扩展）

   ```
   class Solution {
   public:
       string longestPalindrome(string s) {
           int m = s.size();
           vector<vector<bool>> dp(m, vector<bool>(m, false));
           for (int i = 0; i < m; i++)
           {
               dp[i][i] = true;
           }
           int maxlen = 0;
           string res = "";
           for (int len = 1; len <= m; len++)
           {
               for (int i = 0; i < m - len + 1; i++)
               {
                   int j = i + len - 1;
                   if (s[i] == s[j])
                   {
                       if (i + 1 > j - 1 || dp[i+1][j-1])
                       {
                           dp[i][j] = true;
                           maxlen = len;
                           res = s.substr(i, len);
                       }
                   }
   
               }
           }
           return res;
       }
   };
   ```

   

#### **LeetCode 516. Longest Palindromic Subsequence**（最长回文子序列，动态规划）

   ```
   class Solution {
   public:
       int longestPalindromeSubseq(string s) {
           int m = s.size();
           vector<vector<int>> dp(m, vector<int>(m, 0));
           for (int i = 0; i < m; i++)
           {
               dp[i][i] = 1;
           }
   
           for (int len = 2; len <= m; len++)
           {
               for (int i = 0; i < m - len + 1; i++)
               {
                   int j = i + len - 1;
                   if (s[i] == s[j])
                   {
                       dp[i][j] = dp[i + 1][j - 1] + 2;
                   }
                   else
                   {
                       dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
                   }
               }
           }
           return dp[0][m - 1];
       }
   };
   ```

   

3. **回文串构造** 

#### **LeetCode 266. Palindrome Permutation**（回文排列）

   ```
   class Solution:
       def can_permute_palindrome(self, s: str) -> bool:
           if len(s) == 1:
               return True
           h = collections.defaultdict(int)
           for c in s:
               h[c] += 1
           flag = False
           for v in h.values():
               if not (v % 2):
                   continue
               else:
                   if flag == True:
                       return False
                   flag = True
           return True
   ```

   

#### **LeetCode 409. Longest Palindrome**（最长回文串，统计字符频次）

   ```
       def longest_palindrome(self, s: str) -> int:
           if len(s) == 1:
               return 1
           h = collections.defaultdict(int)
           for c in s:
               h[c] += 1
           res = 0
           flag = False
           for v in h.values():
               if not (v % 2):
                   res += v
               else:
                   res += (v - 1)
                   flag = True
           if flag:
               res += 1
           return res
   ```

   

### 四、字符串修改与拼接（删除、替换、插入）

1. **删除字符** 

#### **LeetCode 392. Is Subsequence**（判断子序列，可理解为删除其他字符后匹配）

   ```
   def isSubsequence(self, s: str, t: str) -> bool:
       pre = -1
       for i in range(len(s)):
           if s[i] not in t:
               return False
           cur = t.find(s[i], pre + 1)
           print (cur)
           if cur <= pre:
               return False
           pre = cur
       return True
   ```

   

####  **LeetCode 1910. Remove All Occurrences of a Substring**（删除子串的所有出现）

   ```
   class Solution:
       def removeOccurrences(self, s: str, part: str) -> str:
           m = len(part)
           res = s
           while part in res:
               idx = res.find(part)
               res = res[:idx] + res[idx + m:]
           return res
   ```

   

2. **替换字符** 

#### **LeetCode 8. String to Integer (atoi)**（字符串转整数，处理符号、空格、溢出）

   四步 空白，正负号，提取数字，数字范围

   ```
   class Solution:
       def myAtoi(self, s: str) -> int:
           # 步骤1：忽略前导空白
           s = s.lstrip()
           if not s:
               return 0  # 空字符串返回0
           
           # 步骤2：处理正负号
           sign = 1
           if s[0] == '+':
               s = s[1:]
           elif s[0] == '-':
               sign = -1
               s = s[1:]
           
           # 步骤3：提取数字字符
           num = 0
           for c in s:
               if not c.isdigit():
                   break  # 遇到非数字则停止
               num = num * 10 + int(c)
           
           # 步骤4：应用符号并限制范围（模拟32位整数）
           num *= sign
           INT_MIN, INT_MAX = -2**31, 2**31 - 1
           if num < INT_MIN:
               return INT_MIN
           if num > INT_MAX:
               return INT_MAX
           return num
   ```

   

####  **LeetCode 14. Longest Common Prefix**（最长公共前缀）

   ```
   class Solution:
       def longestCommonPrefix(self, strs: List[str]) -> str:
           if len(strs) == 1:
               return strs[0]
           pl = 1
           pre = ""
           maxlen = 0
           for s in strs:
               if len(s) > maxlen:
                   maxlen = len(s)
   
           while pl <= maxlen + 1:
               cur = strs[0][:pl - 1]
               for s in strs:
                   if cur != s[:pl - 1]:
                       return pre
               pl += 1
               pre = cur
           return pre
   ```

   

3. **字符串加法 / 乘法** 

#### **LeetCode 415. Add Strings**（字符串相加，大数加法）

   保证num1长度长于num2

   ```
   class Solution:
       def add(self, num1: str, num2: str):
           n1 = list(num1)
           n2 = list(num2)
           n1.reverse()
           n2.reverse()
   
           t = 0
           res = list()
           for i in range(len(n1)):
               t += int(n1[i])
               if i < len(n2):
                   t += int(n2[i])
               res.append(str(t % 10))
               t //= 10
           if t:
               res.append(str(t))
           rres = reversed(res)
           return "".join(rres)
       
       def addStrings(self, num1: str, num2: str) -> str:
           if len(num2) > len(num1):
               return self.add(num2, num1)
           else:
               return self.add(num1, num2)
   ```

   

#### **LeetCode 43. Multiply Strings**（字符串相乘，大数乘法）

### 五、动态规划相关字符串题

1. **最长公共子序列** 
#### **LeetCode 1143. Longest Common Subsequence**（LCS 经典题）

   f [ i \]\[ j ] 为第一个序列前i个字符中，和第二个序列前j个字符中的公共序列。所有在第一个序列的前i个字母中出现的，且在第二个序列中的前j个字母中出现的子序列

   转移方程是看最后一个字符是否选取，a[i],b[j], 都选‘f[i - 1\][j - 1] + 1’, 都不选 f[i - 1\][j - 1]

   ```
   class Solution:
       def longestCommonSubsequence(self, text1: str, text2: str) -> int:
           l1 = len(text1)
           l2 = len(text2)
           # 初始化 (l2+1) 行、(l1+1) 列的全 0 二维数组（避免索引越界）
           f = [[0] * (l1 + 1) for _ in range(l2 + 1)]
           
           # 循环范围修正：i 对应 text2（行），j 对应 text1（列），从 1 开始到长度
           for i in range(1, l2 + 1):
               for j in range(1, l1 + 1):
                   # 取上方或左方的最大值
                   f[i][j] = max(f[i - 1][j], f[i][j - 1])
                   # 若当前字符相同，取左上角 +1
                   if text2[i - 1] == text1[j - 1]:  # 注意字符串索引需减 1（因为 i/j 从 1 开始）
                       f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1)
           
           return f[l2][l1]  # 返回最终右下角的结果
   ```

   

2. **编辑距离** 
#### **LeetCode 72. Edit Distance**（困难，插入 / 删除 / 替换的最小步数）

   `f[i][j]`为word1前i个字符到word2的前j个字符的转化的最小步。

   > - 在word1中插入一个字符，相当于`dp[i][j - 1] + 1`，消消乐
   > - 在word1中删除一个字符，相当于`dp[i - 1][j] + 1`，消消乐
   > - 在word1和word2修改最后一个字符，相当于`dp[i - 1][j - 1] + 1`，消消乐
   > - word1最后一个字符和word2最后 一个字符相等的话 `dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])`

   ```
       def min_distance(self, word1: str, word2: str) -> int:
           m = len(word1)
           n = len(word2)
           if m == 0:
               return n
           if n == 0:
               return m
           nword1 = " " + word1
           nword2 = " " + word2
   
           dp = [[0] * (n + 1) for _ in range(m + 1)]
           for i in range(m + 1):
               dp[i][0] = i
           for j in range(n + 1):
               dp[0][j] = j
   
           for i in range(1, m + 1):
               for j in range(1, n + 1):
                   dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1
                   if nword1[i] == nword2[j]:
                       dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
                   else:
                       dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + 1)
           return dp[m][n]
   ```

   

3. **不同的子序列** 
#### **LeetCode 115. Distinct Subsequences**（困难，统计子序列出现次数）

4. **解码方法** 
#### **LeetCode 91. Decode Ways**（中等，字符串解码为数字的方式数）

   类似爬楼梯，算到当前s[i]的方式，相加

   ```
   class Solution:
       def numDecodings(self, s: str) -> int:
           if s[0] == '0':
               return 0
           m = len(s)
           f = [0 for _ in range(m)]
           f[0] = 1
           for i in range(1, m):
               if s[i] != '0':
                   f[i] += f[i - 1]
               if s[i - 1] != '0' and (int(s[i - 1]) * 10 + int(s[i])) <= 26:
                   if i > 1:
                       f[i] += f[i - 2]
                   else:
                       f[i] += 1
           return f[m - 1]
   ```

   

### 六、哈希表结合字符串

1. **字母异位词** 

#### **LeetCode 242. Valid Anagram**（有效的字母异位词）

   ```
   bool anagram(string &s, string &t) {
       sort(s.begin(), s.end());
       sort(t.begin(), t.end());
       return s == t;
   }
   ```

   

#### **LeetCode 49. Group Anagrams**（字母异位词分组）

   ```
   def group_anagrams(self, strs: List[str]) -> List[List[str]]:
       h = collections.defaultdict(list)
       for s in strs:
           tmp = sorted(s)
           h["".join(tmp)].append(s)
       res = list()
       for v in h.values():
           res.append(v)
       return res
   ```

   

2. **字符串中的异位词子串** 
#### **LeetCode 438. Find All Anagrams in a String**（找到字符串中所有字母异位词）

   滑动窗口

   ```
   class Solution:
       def findAnagrams(self, s: str, p: str) -> List[int]:
           m = len(s)
           n = len(p)
           if n > m:
               return []
           hs = [0] * 26
           hp = [0] * 26
           for i in range(n):
               hs[ord(s[i]) - 97] += 1
               hp[ord(p[i]) - 97] += 1
           res = []
           if hp == hs:
               res.append(0)
           
           for i in range(m - n):
               hs[ord(s[i]) - 97] -= 1
               hs[ord(s[i + n]) - 97] += 1
               if hs == hp:
                   res.append(i + 1)
           return res
   ```

   

3. **最长连续序列**
#### **LeetCode 128. Longest Consecutive Sequence**（可结合字符串处理数字序列）

   利用hash

   ```
   class Solution:
       def longestConsecutive(self, nums: List[int]) -> int:
           if len(nums) == 0:
               return 0
           m = len(nums)
           ns = set(nums)
   
           maxlen = 1
           for c in ns:
               if c - 1 not in ns:
                   curlen = 1
                   curchr = c
                   while curchr + 1 in ns:
                       curlen += 1
                       maxlen = max(maxlen, curlen)
                       curchr += 1
   
           return maxlen
   ```

   

### 七、其他高频题

1. **括号匹配** 
####  **LeetCode 20. Valid Parentheses**（有效的括号，栈 + 字符串）

   ```
   class Solution:
       def isValid(self, s: str) -> bool:
           stack = []
   
           for c in s:
               if c == ')':
                   if len(stack) != 0 and stack[-1] == '(':
                       stack.pop()
                       continue
               elif c == ']':
                   if len(stack) != 0 and stack[-1] == '[':
                       stack.pop()
                       continue
               elif c == '}':
                   if len(stack) != 0 and stack[-1] == '{':
                       stack.pop()
                       continue
               stack.append(c)
           return len(stack) == 0
   ```

   

2. **最小覆盖子串** 
#### **LeetCode 76. Minimum Window Substring**（困难，滑动窗口经典题）

   滑动窗口

   ```
   class Solution:
       def minWindow(self, s: str, t: str) -> str:
           sh = collections.defaultdict(int)
           th = collections.defaultdict(int)
           for c in t:
               th[c] += 1
           
           l = 0
           curlen = 0
           res = ""
           for r in range(len(s)):
               sh[s[r]] += 1
               if th[s[r]] and sh[s[r]] <= th[s[r]]:
                   curlen += 1
               while l < len(s) and sh[s[l]] > th[s[l]]:
                   sh[s[l]] -= 1
                   l += 1
               if curlen == len(t):
                   if res == "" or len(res) > (r - l + 1):
                       res = s[l:r + 1]
           return res
   ```

   

3. **无重复字符的最长子串** 
#### **LeetCode 3. Longest Substring Without Repeating Characters**（滑动窗口经典题）

   从i开始往后找，直到有重复的。算当前字串长度，更新res。

   把s[i]的hash减一，向右移动i

   ```
   class Solution:
       def lengthOfLongestSubstring(self, s: str) -> int:
           m = len(s)
           h = collections.defaultdict(int)
           j = 0
           res = ""
           for i in range(m):
               while j < m and h[s[j]] == 0:
                   h[s[j]] += 1
                   j += 1
               if (j - i + 1) > len(res):
                   res = s[i: j]
               h[s[i]] -= 1
           return len(res)
   ```

   

4. **字符串压缩** 
#### **LeetCode 443. String Compression**（原地压缩字符串）

   ```
       def compress(self, s: str) -> str:
           if s == "":
               return ""
           # write your code here
           cur = s[0]
           count = 1
           res = ""
           for i in range(1, len(s)):
               if cur == s[i]:
                   count += 1
               else:
                   res += cur + str(count)
                   cur = s[i]
                   count = 1
           res += cur + str(count)
           if len(res) < len(s):
               return res
           return s
   ```

   