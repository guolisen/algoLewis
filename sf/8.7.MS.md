微软北京研发中心的算法面试题通常注重基础数据结构（链表、树、数组、哈希表）、经典算法（动态规划、贪心、DFS/BFS）及实际场景问题。以下是高频题目总结，包含 LeetCode 题号、英文名称、描述、解题思路及 Python 实现：

### 1. 两数之和（LeetCode 1. Two Sum）

**题目描述**：给定整数数组 `nums` 和目标值 `target`，返回两个数的索引，使它们的和为 `target`。假设只有一个解，且同一元素不重复使用。

- 输入：`nums = [2,7,11,15], target = 9`
- 输出：`[0,1]`

**解题思路**：用哈希表存储已遍历元素的值与索引，遍历数组时计算 `target - 当前值`，若差值在哈希表中，直接返回索引对。

**Python 实现**：

```python
def twoSum(nums, target):
    num_map = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in num_map:
            return [num_map[complement], i]
        num_map[num] = i
    return []
```

### 2. 反转链表（LeetCode 206. Reverse Linked List）

**题目描述**：反转单链表，返回反转后的头节点。

- 输入：`1->2->3->4->5->NULL`
- 输出：`5->4->3->2->1->NULL`

**解题思路**：用迭代法，维护 `prev`（前驱节点）和 `curr`（当前节点），每次将 `curr.next` 指向 `prev`，逐步移动指针完成反转。

**Python 实现**：

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseList(head):
    prev, curr = None, head
    while curr:
        next_node = curr.next  # 暂存下一个节点
        curr.next = prev       # 反转指针
        prev, curr = curr, next_node  # 移动指针
    return prev
```

### 3. 二叉树的层序遍历（LeetCode 102. Binary Tree Level Order Traversal）

**题目描述**：按层遍历二叉树，返回每层节点值的列表（从左到右，逐层收集）。

- 输入：`[3,9,20,null,null,15,7]`
- 输出：`[[3],[9,20],[15,7]]`

**解题思路**：用队列实现 BFS，每层遍历前记录队列长度（当前层节点数），依次弹出节点并收集值，同时将子节点入队。

**Python 实现**：

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def levelOrder(root):
    if not root:
        return []
    from collections import deque
    q = deque([root])
    res = []
    while q:
        level_size = len(q)
        level = []
        for _ in range(level_size):
            node = q.popleft()
            level.append(node.val)
            if node.left:
                q.append(node.left)
            if node.right:
                q.append(node.right)
        res.append(level)
    return res
```

### 4. 最长回文子串（LeetCode 5. Longest Palindromic Substring）

**题目描述**：给定字符串 `s`，返回最长的回文子串（回文是正向和反向读都相同的字符串）。

- 输入：`s = "babad"`
- 输出：`"bab"` 或 `"aba"`

**解题思路**：中心扩展法：遍历每个字符（及相邻字符对）作为回文中心，向两侧扩展寻找最长回文子串，记录最大值。

**Python 实现**：

```python
def longestPalindrome(s):
    def expand(left, right):
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return s[left+1:right]  # 返回扩展后的回文子串
    
    if not s:
        return ""
    res = ""
    for i in range(len(s)):
        # 奇数长度回文（中心为单个字符）
        s1 = expand(i, i)
        # 偶数长度回文（中心为两个字符）
        s2 = expand(i, i+1)
        res = max(res, s1, s2, key=len)
    return res
```

### 5. 最小路径和（LeetCode 64. Minimum Path Sum）

**题目描述**：给定 `m x n` 网格，从左上角到右下角的路径（只能右移或下移）中，求路径上所有数字的最小和。

- 输入：`grid = [[1,3,1],[1,5,1],[4,2,1]]`
- 输出：`7`（路径：1→3→1→1→1）

**解题思路**：动态规划：`dp[i][j]` 表示到达 `(i,j)` 的最小路径和，状态转移为 `dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])`，边界处理第一行和第一列。

**Python 实现**：

```python
def minPathSum(grid):
    m, n = len(grid), len(grid[0])
    # 初始化dp数组（可直接修改原grid节省空间）
    for i in range(m):
        for j in range(n):
            if i == 0 and j == 0:
                continue  # 起点不变
            elif i == 0:
                grid[i][j] += grid[i][j-1]  # 第一行只能左移到达
            elif j == 0:
                grid[i][j] += grid[i-1][j]  # 第一列只能上移到达
            else:
                grid[i][j] += min(grid[i-1][j], grid[i][j-1])
    return grid[-1][-1]
```

### 6. LRU 缓存（LeetCode 146. LRU Cache）

**题目描述**：实现 LRU（最近最少使用）缓存机制，支持 `get(key)`（获取值，若不存在返回 - 1）和 `put(key, value)`（插入 / 更新，满时删除最少使用项）。

- 输入：`["LRUCache","put","put","get","put","get","put","get","get","get"]`，`[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]`
- 输出：`[null,null,null,1,null,-1,null,-1,3,4]`

**解题思路**：哈希表 + 双向链表：哈希表映射键到链表节点（O (1) 访问），双向链表维护使用顺序（头部为最近使用，尾部为最少使用），操作时调整节点位置。

**Python 实现**：

```python
class LRUCache {
public:
    /*
    * @param capacity: An integer
    */
    LRUCache(int capacity): capacity_(capacity) {
        // do intialization if necessary
    }

    /*
     * @param key: An integer
     * @return: An integer
     */
    int get(int key) {
        if (table_.find(key) != table_.end())
        {
            lru_.splice(lru_.begin(), lru_, table_[key]);
            return table_[key]->second;
        }
        return -1;
    }

    /*
     * @param key: An integer
     * @param value: An integer
     * @return: nothing
     */
    void set(int key, int value) {
        if (table_.find(key) != table_.end())
        {
            lru_.splice(lru_.begin(), lru_, table_[key]);
            table_[key]->second = value;
            return;
        }

        lru_.push_front({key, value});
        table_[key] = lru_.begin();
        if (lru_.size() > capacity_)
        {
            table_.erase(lru_.back().first);
            lru_.pop_back();
        }
    }

    int capacity_;
    list<pair<int, int>> lru_;
    unordered_map<int, list<pair<int, int>>::iterator> table_;
};
```

### 7. 岛屿数量（LeetCode 200. Number of Islands）

**题目描述**：给定二维网格，`'1'` 表示陆地，`'0'` 表示水，求岛屿数量（岛屿是相邻陆地连接成的区域，只考虑上下左右相邻）。

- 输入：`grid = [["1","1","0","0","0"],["1","1","0","0","0"],["0","0","1","0","0"],["0","0","0","1","1"]]`
- 输出：`3`

**解题思路**：DFS/BFS：遍历网格，遇到 `'1'` 时启动 DFS/BFS，将所有相连的 `'1'` 标记为 `'0'`（避免重复计数），计数岛屿数量。

**Python 实现**：

```python
def numIslands(grid):
    if not grid:
        return 0
    m, n = len(grid), len(grid[0])
    count = 0

    def dfs(i, j):
        if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != '1':
            return
        grid[i][j] = '0'  # 标记为已访问
        dfs(i+1, j)
        dfs(i-1, j)
        dfs(i, j+1)
        dfs(i, j-1)

    for i in range(m):
        for j in range(n):
            if grid[i][j] == '1':
                count += 1
                dfs(i, j)
    return count
```

### 总结

微软面试注重代码简洁性、边界处理及算法效率。以上题目覆盖了高频考点，建议熟练掌握并理解思路迁移（如动态规划、BFS/DFS 的通用模板）。面试时可先沟通思路，再动手实现，确保代码可读性和正确性。





# 《编程之美 —— 微软技术面试心得》核心内容总结

本书由微软亚洲研究院工程师编写，聚焦微软技术面试高频考点，涵盖算法、数据结构、数学思维等核心模块，每个章节均围绕面试实际场景设计题目，强调问题分析、思路推导与优化能力，是备战微软及大厂技术面试的核心参考资料。以下是各章节关键内容梳理（含面试核心要素）：

## 第 1 章 游戏之乐 —— 游戏中碰到的题目

### 核心主题

通过游戏场景抽象算法问题，考察**问题转化、贪心策略、递归回溯、多线程协同**等能力。

### 关键内容（面试高频考点）

1. **让 CPU 占用率曲线听你指挥**：
    - 核心问题：控制 Windows CPU 使用率（固定值 / 正弦曲线）。
    - 解法：利用忙循环（空循环）与 Sleep () 调节忙闲比例，结合 GetTickCount ()、PerformanceCounter 动态适配 CPU 性能，多 CPU 场景需用 SetThreadAffinityMask 绑定核心。
    - 面试要素：操作系统线程调度、API 使用（Sleep/GetTickCount）、性能优化思维。
2. **中国象棋将帅问题**：
    - 核心问题：仅用一个变量存储将帅位置，输出所有合法布局（不照面）。
    - 解法：位运算拆分变量（4bit 存将位置，4bit 存帅位置），通过位掩码（LMASK/RMASK）读写数据。
    - 面试要素：位运算优化、空间压缩技巧。
3. **一摞烙饼的排序**：
    - 核心问题：通过翻转最上方若干块饼，求最少翻转次数使饼有序。
    - 解法：递归回溯 + 剪枝（上下界约束：最少翻转次数下界 = 相邻无序对数，上界 = 2 (n-1)），贪心策略优先翻转最大饼到目标位置。
    - 面试要素：回溯算法优化、剪枝思想、问题抽象能力。
4. **买书**

​	10本以内用dfs，多余十本，余数用dfs，十本用5+5 = 10 * 25%最大收益

1. **快速找出故障机器**：
    - 核心问题：海量机器 ID 中找出仅出现一次的 ID（单台 / 两台故障）。
    - 解法：异或运算（O (1) 空间，O (n) 时间）、求和 / 求积（应对两台故障，避免溢出）。
    - 面试要素：位运算应用、海量数据处理（低空间复杂度）。
2. **NIM 游戏系列（1-3）**：
    - 核心问题：多堆石头取物博弈，求必胜策略。
    - 解法：利用异或运算（NIM 和为 0 则必输）、斐波那契数列（特殊规则 NIM）、不安全局面推导（两堆石头游戏）。
    - 面试要素：博弈论、数学归纳法、规律抽象能力。
3. **双线程高效下载**：
    - 核心问题：多线程协同（下载线程 + 写盘线程），避免数据竞争。
    - 解法：循环队列 + 信号量（Semaphore）同步，控制缓存区满 / 空状态，避免忙等。
    - 面试要素：多线程同步（信号量 / 互斥锁）、生产者 - 消费者模型。
4. **连连看 / 俄罗斯方块 / 挖雷游戏设计**：
    - 核心问题：游戏核心逻辑（路径查找、积木摆放优化、概率计算）。
    - 解法：BFS 找最短路径（连连看转弯数≤2）、贪心 + 计分制（俄罗斯方块最优摆放）、概率统计（挖雷剩余方块地雷概率）。
    - 面试要素：场景建模、搜索算法（BFS）、启发式优化。

## 第 2 章 数字之魅 —— 数字中的技巧

### 核心主题

聚焦数组、数字运算、序列处理，考察**边界处理、动态规划、分治、数学推导**能力。

### 关键内容（面试高频考点）

1. **求二进制数中 1 的个数**：
    - 解法：除 2 取余、位运算（n&(n-1) 消去最低位 1）、查表法（空间换时间，O (1) 时间）。
    - 面试要素：位运算优化、时间 / 空间权衡。
    
2. **不要被阶乘吓倒**：
    - 核心问题：N! 末尾 0 的个数（质因数 5 的个数）、N! 二进制最低位 1 的位置（质因数 2 的个数 + 1）。
    
    - 解法：公式推导（末尾 0 个数 =ΣN/5^k，k≥1；最低位 1 位置 =ΣN/2^k）。
    
    - 面试要素：数学规律推导、质因数分解。
    
    - n的阶乘可以分解为素数乘积 2x * 3y * 5z，其中2的个数远大于5（不用计算2）, 再由于每个2 * 5都会产生一个10（既尾部多一个0）因此统计n里面有多少个5即可
    
        ```
        ret = 0
        for (int i = 1; i <= N; i++)
        {
        	j = i;
        	while(j % 5 == 0)
        	{
        		ret++;
        		j /= 5
        	}
        }
        ```
    
        ```
        ```
    
        
    
3. **寻找发帖 “水王”**：
    - 核心问题：找出发帖数超过总数一半的 ID。
    - 解法：摩尔投票法（O (n) 时间，O (1) 空间），成对抵消不同 ID，剩余即为水王。
    - 扩展：找 3 个发帖数超过 1/4 的 ID（扩展投票法）。
    - 面试要素：海量数据统计、空间优化。
    
4. **1 的数目**：
    - 核心问题：计算 1~N 中所有数字包含 “1” 的总个数。
    - 解法：按位拆分（个位 / 十位 / 百位...），统计每一位出现 1 的次数（受高位、当前位、低位影响）。
    - 面试要素：数位 DP 思想、分情况讨论。
    
5. **寻找最大的 K 个数**：
    - 解法：快排分治（平均 O (n)）、最小堆（O (n log k)，适合海量数据）、计数排序（适合数值范围小的场景）。
    - 面试要素：海量数据处理、算法时间 / 空间复杂度权衡。
    
6. **子数组之和的最大值**：
    - 核心问题：一维 / 二维数组中，连续子数组的最大和。
    - 解法：一维（动态规划 O (n)，空间优化至 O (1)）、二维（转化为一维，枚举上下边界，O (n²m)）。
    - 扩展：环形数组最大子数组和（拆分两种情况：不跨边界 / 跨边界）。
    - 面试要素：动态规划、问题转化、空间优化。
    
7. **最长递增子序列**：
    - 解法：动态规划 O (n²)、二分优化 O (n log n)（维护递增子序列最小尾元素）。
    - 面试要素：动态规划优化、二分查找应用。

## 第 3 章 结构之法 —— 字符串及链表的探索

### 核心主题

聚焦字符串、链表、树、队列等基础数据结构，考察**操作优化、边界处理、递归遍历**能力。

### 关键内容（面试高频考点）

1. **字符串移位包含问题**：
    - 核心问题：判断 s2 是否为 s1 循环移位后的子串。
    - 解法：s1+s1 包含所有循环移位结果，调用 strstr 判断（O (n) 时间）。
    - 面试要素：字符串操作优化、问题转化。
2. **从无头单链表中删除节点**：
    - 核心问题：无表头指针，删除中间节点。
    - 解法：“狸猫换太子”，将后继节点数据复制到当前节点，删除后继节点。
    - 面试要素：链表操作边界处理、空间限制下的技巧。
3. **编程判断两个链表是否相交**：
    - 核心问题：无环单链表是否相交（相交则最后一个节点相同）。
    - 解法：遍历两链表记录尾节点对比；或拼接链表判断是否有环。
    - 扩展：找相交第一个节点、有环链表相交判断。
    - 面试要素：链表遍历、边界处理（空链表）。
4. **重建二叉树**：
    - 核心问题：根据前序 + 中序遍历结果重建二叉树。
    - 解法：前序首元素为根，中序拆分左右子树，递归重建。
    - 面试要素：二叉树遍历特性、递归思想、边界检查（空树 / 单节点）。
5. **分层遍历二叉树**：
    - 解法：队列 BFS（记录每层节点数），非递归实现（避免栈溢出）。
    - 扩展：逆序分层遍历、按深度从下到上遍历。
    - 面试要素：树的遍历、队列应用。
6. **求二叉树中节点的最大距离**：
    - 核心问题：二叉树中相距最远的两个节点距离（边数）。
    - 解法：深度优先搜索，记录每个节点左右子树最大深度，更新全局最大距离。
    - 面试要素：树的递归遍历、全局变量维护。
7. **队列中取最大值操作问题**：
    - 核心问题：设计支持 O (1) 取最大值的队列。
    - 解法：双栈实现队列（栈 A 存元素，栈 B 维护最大值），或最大堆 + 链表（入队 O (log n)，取最大值 O (1)）。
    - 面试要素：数据结构扩展、空间换时间。

## 第 4 章 数学之趣 —— 数学游戏的乐趣

### 核心主题

通过数学问题考察**逻辑推理、概率计算、组合数学**能力，题目多无固定编程模板，侧重思维推导。

### 关键内容（面试高频考点）

1. **金刚坐飞机问题**：
    - 核心问题：金刚插队后，乘客随机入座，求第 i 个乘客坐到自己座位的概率。
    - 解法：分情况讨论（金刚坐自己座位 / 他人座位），全概率公式推导。
    - 结论：乘客理性入座时概率为 (N-i+1)/(N-i+2)，随机入座时概率为 1/N。
    - 面试要素：概率推导、分治思想。
2. **瓷砖覆盖地板**：
    - 核心问题：1×2 瓷砖能否覆盖 N×M 地板，2×M 地板覆盖方式数。
    - 结论：N×M 需至少一个偶数；2×M 覆盖数符合斐波那契数列（F (M)=F (M-1)+F (M-2)）。
    - 面试要素：组合计数、递归关系推导。
3. **买票找零**：
    - 核心问题：2n 人排队购票（n 人持 50 元，n 人持 100 元），求不找零困难的排队方式数。
    - 解法：卡特兰数（C (n) = (1/(n+1))×C (2n,n)），对应合法括号排列。
    - 面试要素：组合数学、动态规划计数。
4. **三角形测试用例**：
    - 核心问题：设计测试用例覆盖三角形所有场景（等边 / 等腰 / 直角 / 钝角 / 非三角形）。
    - 解法：等价类划分（边长合法 / 非法、角度类型）、边界值测试（临界边长）。
    - 面试要素：测试思维、逻辑完备性。
5. **数独知多少**：
    - 核心问题：计算合法数独的数量，构造合法数独。
    - 解法：深度优先搜索 + 剪枝（利用数独规则减少无效尝试），构造时先填固定位置再扩展。
    - 面试要素：回溯算法、逻辑剪枝。

## 面试核心要素总结

1. **能力考察重点**：
    - 问题抽象：将实际场景（游戏 / 业务）转化为算法模型。
    - 优化意识：从暴力解法逐步优化（时间 / 空间复杂度权衡）。
    - 边界处理：空输入、极端值、多线程竞争等场景。
    - 数学思维：规律推导、概率 / 组合计数、位运算应用。
2. **高频算法 / 数据结构**：
    - 算法：动态规划、递归回溯、分治、贪心、BFS/DFS、位运算。
    - 数据结构：链表、二叉树、队列 / 栈、堆、哈希表。
3. **微软面试特色**：
    - 不考偏题怪题，侧重基础能力的灵活应用。
    - 重视思考过程，而非仅关注代码正确性。
    - 鼓励主动沟通，明确问题边界（如 “是否允许使用额外空间”）。

本书题目难度标注清晰（1-3 星），部分题目附带扩展问题（如多线程下载优化、环形数组最大和），建议结合 LeetCode 同类题目（如子数组最大和、二叉树重建）强化练习，重点掌握 “思路推导 + 代码优化” 的完整流程。



以下筛选《编程之美》中**微软面试高频题**，涵盖数字运算、数组、数据结构、场景算法四大类，每道题含题目描述、Python 解（简洁高效）、C/C++ 解（贴合面试编码规范），兼顾思路清晰性与工程实现细节。

## 一、数字与位运算类

### 1. 求二进制数中 1 的个数

#### 题目描述

给定一个整数（或字节），计算其二进制表示中 “1” 的个数，要求时间复杂度最优。

#### Python 解

```python
def count_one_bits(n: int) -> int:
    """利用 n & (n-1) 消去最低位1，循环次数=1的个数"""
    count = 0
    while n:
        n &= n - 1  # 消去最低位的1
        count += 1
    return count

# 测试
print(count_one_bits(0b10100010))  # 输入二进制10100010，输出3
print(count_one_bits(0))  # 边界测试，输出0
```

#### C++ 解

```cpp
#include <iostream>
using namespace std;

int countOneBits(int n) {
    int count = 0;
    // 注意：n为负数时，C++中右移是算术右移（补符号位），需用无符号数避免死循环
    unsigned int num = static_cast<unsigned int>(n);
    while (num) {
        num &= num - 1;
        count++;
    }
    return count;
}

int main() {
    cout << countOneBits(0b10100010) << endl;  // 输出3
    cout << countOneBits(0) << endl;           // 输出0
    return 0;
}
```

### 2. N! 末尾 0 的个数

#### 题目描述

给定非负整数 N，计算 N!（N 的阶乘）末尾连续 “0” 的个数（核心：末尾 0 由质因数 2×5 产生，5 的个数少于 2，故统计 5 的个数）。

#### Python 解

```python
def count_trailing_zeros(n: int) -> int:
    count = 0
    while n > 0:
        n //= 5  # 每次除以5，统计包含5^k的因子个数
        count += n
    return count

# 测试
print(count_trailing_zeros(10))  # 10! = 3628800，输出2
print(count_trailing_zeros(25))  # 25! 含6个5（25=5²），输出6
```

#### C++ 解

```cpp
#include <iostream>
using namespace std;

int countTrailingZeros(int n) {
    int count = 0;
    while (n > 0) {
        n /= 5;
        count += n;
    }
    return count;
}

int main() {
    cout << countTrailingZeros(10) << endl;  // 输出2
    cout << countTrailingZeros(25) << endl;  // 输出6
    return 0;
}
```

### 3. 寻找发帖 “水王”

#### 题目描述

论坛中 “水王” 的发帖数超过总帖子数的一半，给定帖子 ID 列表，快速找出水王的 ID（要求 O (n) 时间、O (1) 空间）。

#### Python 解

```python
def find_water_king(ids: list) -> int | None:
    """摩尔投票法：成对抵消不同ID，剩余候选为水王"""
    candidate = None
    count = 0
    for id in ids:
        if count == 0:
            candidate = id
            count = 1
        else:
            count += 1 if id == candidate else -1
    # 验证（题目假设存在水王，可选）
    if candidate is not None and ids.count(candidate) > len(ids) // 2:
        return candidate
    return None

# 测试
print(find_water_king([1, 2, 1, 1, 3, 1, 4]))  # 输出1
```

#### C++ 解

```cpp
#include <iostream>
#include <vector>
#include <algorithm>  // 用于count
using namespace std;

int findWaterKing(vector<int>& ids) {
    int candidate = -1;
    int count = 0;
    for (int id : ids) {
        if (count == 0) {
            candidate = id;
            count = 1;
        } else {
            count += (id == candidate) ? 1 : -1;
        }
    }
    // 验证
    if (count > 0 && count(ids.begin(), ids.end(), candidate) > ids.size() / 2) {
        return candidate;
    }
    return -1;  // 无结果（题目假设存在，可忽略）
}

int main() {
    vector<int> ids = {1, 2, 1, 1, 3, 1, 4};
    cout << findWaterKing(ids) << endl;  // 输出1
    return 0;
}
```

## 二、数组与子数组类

### 1. 子数组之和的最大值

#### 题目描述

给定整数数组（可含负整数），找出连续子数组的最大和（如输入 `[1,-2,3,5,-3,2]`，输出 8，对应子数组 `[3,5]`）。

#### Python 解

```python
def max_subarray_sum(arr: list) -> int:
    """动态规划：空间优化至O(1)"""
    if not arr:
        return 0
    current_max = global_max = arr[0]
    for num in arr[1:]:
        # 要么以当前元素为起点，要么拼接前序子数组
        current_max = max(num, current_max + num)
        global_max = max(global_max, current_max)
    return global_max

# 测试
print(max_subarray_sum([1, -2, 3, 5, -3, 2]))  # 输出8
print(max_subarray_sum([-9, -2, -3]))  # 输出-2（单个最小负数）
```

#### C++ 解

```cpp
#include <iostream>
#include <vector>
#include <algorithm>  // 用于max
using namespace std;

int maxSubarraySum(vector<int>& arr) {
    if (arr.empty()) {
        return 0;
    }
    int currentMax = arr[0];
    int globalMax = arr[0];
    for (int i = 1; i < arr.size(); ++i) {
        currentMax = max(arr[i], currentMax + arr[i]);
        globalMax = max(globalMax, currentMax);
    }
    return globalMax;
}

int main() {
    vector<int> arr1 = {1, -2, 3, 5, -3, 2};
    vector<int> arr2 = {-9, -2, -3};
    cout << maxSubarraySum(arr1) << endl;  // 输出8
    cout << maxSubarraySum(arr2) << endl;  // 输出-2
    return 0;
}
```

### 2. 寻找最大的 K 个数

#### 题目描述

给定海量整数（如 1 亿个），找出其中最大的 K 个数（要求效率优先，空间占用低）。

#### Python 解

```python
import heapq

def find_top_k(nums: list, k: int) -> list:
    """最小堆实现：O(n log k) 时间，适合海量数据"""
    if k <= 0 or not nums:
        return []
    # 用前k个元素建最小堆
    heap = nums[:k]
    heapq.heapify(heap)
    # 遍历剩余元素，比堆顶大则替换
    for num in nums[k:]:
        if num > heap[0]:
            heapq.heappop(heap)
            heapq.heappush(heap, num)
    return sorted(heap, reverse=True)  # 可选：按从大到小排序

# 测试
print(find_top_k([3, 1, 4, 1, 5, 9, 2, 6], 3))  # 输出[9,6,5]
```

#### C++ 解

```cpp
#include <iostream>
#include <vector>
#include <queue>  // 用于priority_queue（默认大根堆，需改为小根堆）
#include <algorithm>
using namespace std;

vector<int> findTopK(vector<int>& nums, int k) {
    vector<int> result;
    if (k <= 0 || nums.empty()) {
        return result;
    }
    // 小根堆（priority_queue默认大根堆，需用greater<int>）
    priority_queue<int, vector<int>, greater<int>> minHeap;
    // 前k个元素入堆
    for (int i = 0; i < k; ++i) {
        minHeap.push(nums[i]);
    }
    // 遍历剩余元素
    for (int i = k; i < nums.size(); ++i) {
        if (nums[i] > minHeap.top()) {
            minHeap.pop();
            minHeap.push(nums[i]);
        }
    }
    // 堆中元素存入结果并逆序（使从大到小）
    while (!minHeap.empty()) {
        result.push_back(minHeap.top());
        minHeap.pop();
    }
    reverse(result.begin(), result.end());
    return result;
}

int main() {
    vector<int> nums = {3, 1, 4, 1, 5, 9, 2, 6};
    vector<int> topK = findTopK(nums, 3);
    for (int num : topK) {
        cout << num << " ";  // 输出9 6 5
    }
    cout << endl;
    return 0;
}
```

## 三、数据结构类

### 1. 从无头单链表中删除节点

#### 题目描述

给定单链表中一个**非尾节点**（无表头指针），删除该节点（要求 O (1) 时间）。

Python 解

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def delete_node(node: ListNode) -> None:
    """狸猫换太子：复制后继节点数据，删除后继节点"""
    if not node or not node.next:
        raise ValueError("节点不能为尾节点或空")
    # 复制后继节点数据
    node.val = node.next.val
    # 删除后继节点
    node.next = node.next.next

# 测试：链表 1->2->3->4，删除节点2
head = ListNode(1)
node_to_delete = ListNode(2)
head.next = node_to_delete
head.next.next = ListNode(3)
head.next.next.next = ListNode(4)

delete_node(node_to_delete)
# 遍历验证
current = head
while current:
    print(current.val, end="->")  # 输出1->3->4->
    current = current.next
```

#### C++ 解

```cpp
#include <iostream>
using namespace std;

struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

void deleteNode(ListNode* node) {
    if (node == nullptr || node->next == nullptr) {
        throw invalid_argument("Node cannot be tail or null");
    }
    // 复制后继节点数据
    ListNode* nextNode = node->next;
    node->val = nextNode->val;
    // 删除后继节点
    node->next = nextNode->next;
    delete nextNode;  // 释放内存（C++需手动管理）
}

// 遍历链表辅助函数
void printList(ListNode* head) {
    ListNode* current = head;
    while (current) {
        cout << current->val << "->";
        current = current->next;
    }
    cout << endl;
}

int main() {
    ListNode* head = new ListNode(1);
    ListNode* nodeToDelete = new ListNode(2);
    head->next = nodeToDelete;
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);

    deleteNode(nodeToDelete);
    printList(head);  // 输出1->3->4->

    // 释放剩余内存（面试可简化）
    ListNode* temp;
    while (head) {
        temp = head;
        head = head->next;
        delete temp;
    }
    return 0;
}
```

### 2. 重建二叉树

#### 题目描述

根据二叉树的**前序遍历**和**中序遍历**结果（节点值唯一），重建二叉树。

#### Python 解

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def build_tree(preorder: list, inorder: list) -> TreeNode | None:
    """前序首元素为根，中序拆分左右子树，递归重建"""
    if not preorder or not inorder:
        return None
    # 根节点：前序第一个元素
    root_val = preorder[0]
    root = TreeNode(root_val)
    # 中序中找到根节点索引，拆分左右子树
    root_idx = inorder.index(root_val)
    # 递归构建左右子树
    root.left = build_tree(preorder[1:1+root_idx], inorder[:root_idx])
    root.right = build_tree(preorder[1+root_idx:], inorder[root_idx+1:])
    return root

# 测试：前序[3,9,20,15,7]，中序[9,3,15,20,7]
def preorder_traversal(node: TreeNode) -> None:
    """前序遍历验证"""
    if node:
        print(node.val, end=" ")
        preorder_traversal(node.left)
        preorder_traversal(node.right)

root = build_tree([3,9,20,15,7], [9,3,15,20,7])
preorder_traversal(root)  # 输出3 9 20 15 7
```

#### C++ 解

```cpp
#include <iostream>
#include <vector>
#include <unordered_map>  // 优化中序索引查找（O(1)）
using namespace std;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        // 用哈希表存储中序值到索引的映射，优化查找
        unordered_map<int, int> inorderMap;
        for (int i = 0; i < inorder.size(); ++i) {
            inorderMap[inorder[i]] = i;
        }
        return build(preorder, 0, preorder.size()-1, inorderMap, 0, inorder.size()-1);
    }

private:
    TreeNode* build(vector<int>& preorder, int preL, int preR,
                   unordered_map<int, int>& inMap, int inL, int inR) {
        if (preL > preR || inL > inR) {
            return nullptr;
        }
        // 根节点：前序左边界
        int rootVal = preorder[preL];
        TreeNode* root = new TreeNode(rootVal);
        // 中序根节点索引
        int rootIdx = inMap[rootVal];
        // 左子树节点数
        int leftSize = rootIdx - inL;
        // 递归构建左右子树
        root->left = build(preorder, preL+1, preL+leftSize, inMap, inL, rootIdx-1);
        root->right = build(preorder, preL+leftSize+1, preR, inMap, rootIdx+1, inR);
        return root;
    }
};

// 前序遍历验证
void preorderTraversal(TreeNode* node) {
    if (node) {
        cout << node->val << " ";
        preorderTraversal(node->left);
        preorderTraversal(node->right);
    }
}

int main() {
    vector<int> preorder = {3,9,20,15,7};
    vector<int> inorder = {9,3,15,20,7};
    Solution sol;
    TreeNode* root = sol.buildTree(preorder, inorder);
    preorderTraversal(root);  // 输出3 9 20 15 7
    return 0;
}
```

## 四、场景算法类

### 1. 一摞烙饼的排序

#### 题目描述

n 块大小不一的烙饼摞成一摞，每次可翻转最上方 k 块饼（k≥2），求最少翻转次数使饼从小到大排序（小在上，大在下）。

#### Python 解

```python
def reverse_pancakes(pancakes: list, k: int) -> list:
    """辅助函数：翻转前k块饼"""
    return pancakes[:k][::-1] + pancakes[k:]

def min_pancake_flips(pancakes: list) -> int:
    """递归回溯+剪枝：优先翻转最大饼到目标位置"""
    target = sorted(pancakes)
    min_flips = float('inf')

    def backtrack(current: list, flips: int) -> None:
        nonlocal min_flips
        # 剪枝：当前翻转次数≥已知最小值
        if flips >= min_flips:
            return
        # 找到目标，更新最小值
        if current == target:
            min_flips = flips
            return
        # 遍历所有可能的翻转长度（2~len(current)）
        n = len(current)
        for k in range(2, n+1):
            new_current = reverse_pancakes(current, k)
            backtrack(new_current, flips + 1)

    backtrack(pancakes, 0)
    return min_flips if min_flips != float('inf') else 0

# 测试
print(min_pancake_flips([3,2,1]))  # 输出2（翻转3块→[1,2,3]）
print(min_pancake_flips([4,3,2,1]))  # 输出2（翻转4块→[1,2,3,4]）
```

#### C++ 解

```cpp
#include <iostream>
#include <vector>
#include <climits>  // 用于INT_MAX
#include <algorithm>  // 用于sort
using namespace std;

vector<int> reversePancakes(vector<int>& pancakes, int k) {
    vector<int> res = pancakes;
    reverse(res.begin(), res.begin() + k);
    return res;
}

void backtrack(vector<int>& current, vector<int>& target, int flips, int& minFlips) {
    if (flips >= minFlips) {
        return;
    }
    if (current == target) {
        minFlips = flips;
        return;
    }
    int n = current.size();
    for (int k = 2; k <= n; ++k) {
        vector<int> newCurrent = reversePancakes(current, k);
        backtrack(newCurrent, target, flips + 1, minFlips);
    }
}

int minPancakeFlips(vector<int>& pancakes) {
    vector<int> target = pancakes;
    sort(target.begin(), target.end());
    int minFlips = INT_MAX;
    backtrack(pancakes, target, 0, minFlips);
    return minFlips == INT_MAX ? 0 : minFlips;
}

int main() {
    vector<int> p1 = {3,2,1};
    vector<int> p2 = {4,3,2,1};
    cout << minPancakeFlips(p1) << endl;  // 输出2
    cout << minPancakeFlips(p2) << endl;  // 输出2
    return 0;
}
```

## 核心说明

1. **面试适配性**：所有题目均为微软面试高频考点，解法优先选择 “时间最优 + 空间最优”，贴合面试编码习惯；
2. **语言差异**：
    - Python 解注重简洁性，利用内置函数（如 `heapq`、`reverse`）提升效率；
    - C++ 解注重内存管理（如手动释放链表 / 二叉树节点）、边界处理（如无符号数避免死循环）、性能优化（如哈希表映射中序索引）；
3. **扩展提示**：面试中需主动沟通思路（如摩尔投票法的原理、堆的选择理由），部分题目可进一步优化（如烙饼排序加入上下界剪枝）。









































### 一、字符串与数组（面试最高频模块）

#### 1. 字符串移位包含问题（P46：字符串移位）

- **题目**：给定两个字符串 `s1` 和 `s2`，判断 `s2` 是否是 `s1` 经过若干次左移或右移得到的子串（例如 `s1="ABCDE"`，左移 2 位为 `"CDEAB"`，若 `s2="CDE"` 则返回 `true`）。
- **核心考点**：字符串拼接的技巧（避免复杂移位逻辑）。
- **解题关键**：`s1` 移位后的所有可能结果，都包含在 `s1 + s1` 中（如 `ABCDE+ABCDE="ABCDEABCDE"`，包含所有左移 / 右移结果），因此只需判断 `s2` 是否是 `s1+s1` 的子串。
- **面试变种**：判断 `s2` 是否是 `s1` 的旋转子串（LeetCode 796. 旋转字符串原题）。

#### 2. 替换空格（P51：替换空格）

- **题目**：将字符串中的空格替换为 `%20`（例如输入 `"We are happy."`，输出 `"We%20are%20happy."`）。
- **核心考点**：字符串遍历、内存扩容（若原地修改）、双指针技巧。
- **解题关键**：
    - 先统计空格数量，计算最终字符串长度（原长度 + 空格数 ×2）；
    - 从后往前遍历替换（避免多次移动字符，时间复杂度 O (n)）。
- **面试变种**：替换字符串中特定字符（如将 `#` 替换为 `##`），考察原地修改的效率。

#### 3. 数组中出现次数超过一半的数字（P179：求数组中出现次数超过一半的数字）

- **题目**：找出数组中出现次数超过数组长度一半的数字（假设数组非空，且一定存在这样的数字）。
- **核心考点**：摩尔投票法（O (n) 时间 + O (1) 空间）、哈希表统计（备选方案）。
- **解题关键**：摩尔投票法 —— 遍历数组，用 `count` 计数，相同数字 `count++`，不同则 `count--`，`count` 为 0 时更换候选数字，最终候选数字即为结果。
- **面试变种**：找出数组中出现次数最多的数字（无 “超过一半” 限制）、验证数组中是否存在出现次数超过一半的数字。

#### 4. 最小的 k 个数（P192：寻找最小的 k 个数）

- **题目**：输入 n 个整数，找出其中最小的 k 个数（例如输入 `[4,5,1,6,2,7,3,8]`，k=4，输出 `[1,2,3,4]`）。
- **核心考点**：堆排序（大根堆，O (n log k)）、快速选择（O (n) 平均时间）、边界条件处理（k=0、k=n、数组为空）。
- **解题关键**：
    - 大根堆：维护一个大小为 k 的大根堆，遍历数组时，比堆顶小的元素入堆，最终堆内元素即为最小 k 个（适合海量数据，无需全部加载）；
    - 快速选择：基于快速排序的分区思想，找到第 k 小的元素，左侧即为结果（适合数据量较小、允许修改原数组）。
- **面试变种**：最大的 k 个数、第 k 大 / 小的元素（LeetCode 215. 数组中的第 K 个最大元素）。

### 二、树与递归（中层难度，考察逻辑严谨性）

#### 1. 二叉树的镜像（P157：二叉树的镜像）

- **题目**：输入一棵二叉树，输出它的镜像（交换每个节点的左右子树）。
- **核心考点**：二叉树递归遍历、迭代遍历（栈 / 队列）。
- **解题关键**：递归终止条件（节点为空），递归逻辑（交换当前节点左右子树，再递归处理左右子树）。
- **面试变种**：判断两棵树是否互为镜像、二叉树的对称判断（LeetCode 101. 对称二叉树）。

#### 2. 重建二叉树（P153：重建二叉树）

- **题目**：根据二叉树的前序遍历和中序遍历结果，重建该二叉树（假设树中无重复元素）。
- **核心考点**：二叉树遍历特性、递归分治、哈希表优化（快速查找中序遍历的根节点位置）。
- **解题关键**：
    - 前序遍历第一个元素为根节点；
    - 在中序遍历中找到根节点位置，左侧为左子树，右侧为右子树；
    - 递归重建左、右子树（需计算左子树长度，确定前序遍历的左右子树范围）。
- **面试变种**：根据中序 + 后序遍历重建二叉树、处理有重复元素的情况。

#### 3. 二叉树的深度（P161：二叉树的深度）

- **题目**：输入一棵二叉树，求该树的深度（从根节点到叶子节点的最长路径上的节点数）。
- **核心考点**：二叉树递归遍历、层次遍历（BFS）。
- **解题关键**：
    - 递归：树的深度 = max (左子树深度，右子树深度) + 1；
    - 层次遍历：用队列记录每一层的节点数，遍历完一层深度 + 1。
- **面试变种**：求二叉树的最小深度（LeetCode 111. 二叉树的最小深度）、判断是否为平衡二叉树（P163：平衡二叉树，左右子树深度差不超过 1）。

### 三、动态规划与贪心（高频中等难度）

#### 1. 跳台阶（P113：跳台阶）

- **题目**：一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级，求该青蛙跳上 n 级台阶的总共有多少种跳法。
- **核心考点**：动态规划（递推关系）、斐波那契数列、边界条件（n=0→1，n=1→1，n=2→2）。
- **解题关键**：dp [n] = dp [n-1] + dp [n-2]（第 n 级台阶可从第 n-1 级跳 1 步，或第 n-2 级跳 2 步）。
- **面试变种**：青蛙一次可跳 1~k 级台阶（dp [n] = 2^n-1）、跳台阶带障碍（LeetCode 62. 不同路径 II）。

#### 2. 最大子数组和（P218：最大子数组和）

- **题目**：输入一个整型数组，数组中有正数也有负数，求数组中连续子数组的最大和（例如输入 `[-2,1,-3,4,-1,2,1,-5,4]`，输出 `6`，对应子数组 `[4,-1,2,1]`）。
- **核心考点**：动态规划（O (n) 时间）、贪心算法、边界条件（数组全为负数）。
- **解题关键**：dp [i] = max (nums [i], dp [i-1] + nums [i])（以第 i 个元素结尾的最大子数组和，要么是自身，要么是前一个子数组和 + 自身）。
- **面试变种**：最大子数组乘积（LeetCode 152. 乘积最大子数组）、最长递增子数组。

#### 3. 硬币找零（P224：硬币找零）

- **题目**：给定不同面额的硬币和一个总金额，计算可以凑成总金额的最少硬币数（假设每种硬币数量无限，例如硬币 `[1,2,5]`，总金额 `11`，输出 `3`（5+5+1））。
- **核心考点**：动态规划（完全背包问题）、边界条件（总金额为 0→0，无法凑成→-1）。
- **解题关键**：dp [amount] = min (dp [amount - coin] + 1)（遍历所有硬币，取能凑成 amount-coin 的最小硬币数 + 1）。
- **面试变种**：计算凑成总金额的所有组合数（LeetCode 518. 零钱兑换 II）、硬币数量有限的情况。

### 四、数学与逻辑（考察思维灵活性）

#### 1. 二进制中 1 的个数（P109：二进制中 1 的个数）

- **题目**：输入一个整数，输出该数二进制表示中 1 的个数（例如输入 `9`（二进制 `1001`），输出 `2`）。
- **核心考点**：位运算（`n & (n-1)` 技巧）、边界处理（负数的二进制表示，无符号右移）。
- **解题关键**：`n & (n-1)` 会消除 n 二进制中最后一个 1，循环执行该操作直到 n=0，循环次数即为 1 的个数（O (k) 时间，k 为 1 的个数）。
- **面试变种**：判断一个数是否是 2 的幂（二进制只有一个 1）、计算两个数的二进制异或后 1 的个数（汉明距离）。

#### 2. 不用加减乘除做加法（P49：不用加减乘除做加法）

- **题目**：写一个函数，求两个整数之和，要求在函数体内不得使用 `+`、`-`、`*`、`/` 四则运算符号。
- **核心考点**：位运算（异或求无进位和，与运算求进位）。
- **解题关键**：
    - 无进位和：`a ^ b`（相同位为 0，不同位为 1）；
    - 进位：`(a & b) << 1`（相同位为 1 时产生进位，左移 1 位）；
    - 循环计算：直到进位为 0，此时无进位和即为结果。
- **面试变种**：不用乘除做乘法（位运算移位）、不用取模做除法。

#### 3. 约瑟夫环问题（P300：约瑟夫环问题）

- **题目**：n 个人围成一圈，每次数到 k 的人出列，求最后剩下的人的位置（例如 n=5，k=3，输出 `3`）。
- **核心考点**：递推公式（O (n) 时间）、数学思维（避免模拟的 O (nk) 复杂度）。
- **解题关键**：递推公式 `f(n,k) = (f(n-1,k) + k) % n`（f (n,k) 表示 n 个人时最后剩下的位置，f (1,k)=0）。
- **面试变种**：k=2 时的简化公式、约瑟夫环的变种（每次出列第 k 个人的前一个）。

### 五、面试准备建议（结合你的背景）

作为拥有 15 年经验的云原生 / 存储领域高级工程师，面试中考察《编程之美》题目时，更侧重 **“思路 + 工程实现 + 边界处理”**，而非单纯的代码记忆：

1. **优先掌握高频题**：字符串替换、最小 k 个数、最大子数组和、二进制中 1 的个数（基础且高频，适合快速得分）；
2. **突出工程思维**：例如实现 “最小的 k 个数” 时，可主动提及 “海量数据场景下优先用大根堆（节省内存）”，贴合你的存储系统开发经验；
3. **注重边界条件**：面试中面试官常追问 “数组为空怎么办？”“k 大于数组长度怎么办？”“负数如何处理？”，需提前考虑；
4. **结合语言特性**：用 Python/Go 实现时，可利用语言自带的数据结构（如 Python 的 `heapq`、Go 的 `container/heap`），展示对语言的熟悉度；
5. **关联项目经验**：例如讲解 “动态规划” 时，可简要提及 “在存储系统性能优化中，曾用动态规划模型预测缓存命中率”，强化技术深度。

如果需要针对某道题的 Python/Go 实现（结合面试场景的优化版本），或想模拟面试中的追问环节，可以随时告知！











# skiplist跳表是一个什么数据结构

### 跳表（SkipList）：核心定义与核心特性

跳表是一种**基于有序链表扩展的概率型数据结构**，由 William Pugh 在 1990 年提出，核心目标是为有序链表提供**对数级（O (log n)）的查找、插入、删除效率**，同时保持链表 “插入 / 删除无需移动大量元素” 的灵活性，可看作 “有序链表 + 多级索引” 的组合，常作为平衡树（如红黑树、AVL 树）的轻量级替代（Redis 的有序集合 `zset` 底层就用了跳表）。

------

## 一、跳表的核心结构：“链表 + 多级索引”

有序链表的痛点是：查找需要遍历所有元素（O (n)），而跳表通过**为链表建立多层稀疏索引**解决这个问题 —— 每一层索引都是下一层的 “快捷方式”，越上层的索引越稀疏，最终形成 “金字塔” 结构。

### 1. 结构示例（有序链表：1→3→5→7→9→11）

| 索引层级 | 元素（索引节点）       | 作用                     |
| -------- | ---------------------- | ------------------------ |
| 第 3 层  | 1 → 9                  | 最顶层索引，跨度最大     |
| 第 2 层  | 1 → 5 → 9              | 中间层索引，跨度中等     |
| 第 1 层  | 1 → 3 → 5 → 7 → 9 → 11 | 第一层索引（稀疏版链表） |
| 第 0 层  | 1 → 3 → 5 → 7 → 9 → 11 | 原始有序链表（全量元素） |

### 2. 核心概念

- **层（Level）**：跳表的索引分为多层，底层（Level 0）是完整的有序链表，上层是下层的索引；每个节点有多个 “指针”，分别指向对应层级的下一个节点。
- **晋升概率**：新节点插入时，通过随机算法决定其 “晋升” 到上层索引的概率（通常为 50%），保证索引的稀疏性（如 Redis 中晋升概率为 1/4）。
- **哨兵节点**：跳表首尾通常有 “头哨兵”（最小虚拟节点）和 “尾哨兵”（最大虚拟节点），简化边界处理。

------

## 二、核心操作原理（以查找 7 为例）

### 1. 查找流程（从顶层索引开始，逐层向下）

1. 从第 3 层头节点出发，当前节点是 1，下一个节点是 9（9 > 7），无法继续，**向下一层**（第 2 层）；
2. 第 2 层当前节点是 1，下一个节点是 5（5 <7），移动到 5；5 的下一个节点是 9（9> 7），**向下一层**（第 1 层）；
3. 第 1 层当前节点是 5，下一个节点是 7（7 = 目标值），**向下一层**（第 0 层）；
4. 第 0 层验证节点 7，查找完成。

### 2. 插入流程

1. 先通过查找找到插入位置（如插入 8，找到 7 和 9 之间）；
2. 随机生成新节点的 “层数”（如随机到 2 层）；
3. 在 Level 0 插入 8，同时将 8 晋升到 Level 1、Level 2 的索引中，调整对应层级的指针；
4. 若新节点的层数超过跳表当前最大层数，扩展跳表的最大层数。

### 3. 删除流程

1. 查找目标节点，记录其在各层索引中的位置；
2. 从最上层开始，删除该节点在对应层级的索引指针；
3. 若删除后某层索引无元素，删除该层；
4. 最后删除 Level 0 的原始节点。

------

## 三、跳表的核心特性

### 1. 时间复杂度

| 操作 | 平均时间复杂度 | 最坏时间复杂度 | 说明                                       |
| ---- | -------------- | -------------- | ------------------------------------------ |
| 查找 | O(log n)       | O(n)           | 最坏情况：索引失效（如所有节点都在同一层） |
| 插入 | O(log n)       | O(n)           | 主要耗时在查找插入位置                     |
| 删除 | O(log n)       | O(n)           | 主要耗时在查找删除位置                     |

### 2. 空间复杂度

- 平均：O (n)（索引的总节点数约为 n，因为每层索引的节点数是下一层的 1/2，总和为 n + n/2 + n/4 + ... ≈ 2n）；
- 最坏：O (n log n)（极端情况所有节点都晋升到最高层）。

### 3. 对比平衡树（红黑树）

| 特性       | 跳表                        | 红黑树                    |
| ---------- | --------------------------- | ------------------------- |
| 实现难度   | 低（链表 + 索引，逻辑简单） | 高（旋转 / 变色规则复杂） |
| 范围查询   | 高效（链表天然支持遍历）    | 较复杂（需中序遍历）      |
| 并发性能   | 好（局部修改，锁粒度小）    | 差（整棵树需加锁）        |
| 时间复杂度 | 平均 O (log n)              | 最坏 O (log n)            |
| 空间开销   | 略高（索引占用额外空间）    | 低（无额外索引）          |

------

## 四、跳表的典型应用

1. **Redis 有序集合（zset）**：当有序集合元素较多时，Redis 放弃红黑树，改用 “跳表 + 哈希表” 实现 —— 跳表保证有序性和范围查询，哈希表保证 O (1) 查找元素分值。
2. **LevelDB/RocksDB**：底层的 MemTable 采用跳表存储，利用其高效的插入 / 查找特性。
3. **分布式系统**：如 HBase 的 Region 索引，利用跳表的轻量级特性减少内存开销。

------

## 五、核心设计要点

1. **随机层数生成**：必须保证层数的概率分布（如几何分布），否则会退化为普通链表；例如 Redis 中通过 “每次随机 0~3，仅当为 0 时晋升” 控制层数。
2. **节点结构设计**：每个节点需存储 “值 + 各层指针 + 层数”，指针数量等于节点的层数。
3. **边界处理**：通过哨兵节点避免越界，简化空跳表、单节点跳表的逻辑。

------

## 总结

跳表的本质是**用 “概率性稀疏索引” 替代平衡树的 “确定性平衡”**，以 “少量空间开销” 换取 “简单实现 + 高效操作”：

- 优势：实现简单、范围查询高效、并发修改友好；
- 劣势：空间开销略高、最坏时间复杂度不如平衡树稳定；
- 适用场景：需要有序存储、高效增删查，且希望避免平衡树复杂实现的场景（如 Redis zset、内存数据库）。















#### 1. 存储数据结构核心题（RocksDB/LevelDB 底层 + 哈希表）

这类题直接匹配 JD 中 “internal storage data structures、distributed hash table” 的核心要求，是面试重中之重。

| 题型方向               | LeetCode 题号 | 题目名称                      | 匹配 JD 的核心原因                                           |
| ---------------------- | ------------- | ----------------------------- | ------------------------------------------------------------ |
| 哈希表优化 / 冲突解决  | 146           | LRU Cache                     | ① RocksDB 缓存层核心逻辑；② 分布式系统中缓存淘汰策略是性能优化关键；③ 考察 C++ 高性能实现（如用双向链表 + 哈希表） |
|                        | 155           | Min Stack                     | 存储系统中高频的栈式缓存 / 日志栈场景，考察空间换时间的优化思路 |
|                        | 706           | Design HashMap                | 分布式哈希表（ObjectStore 核心）的基础实现，考察哈希冲突解决（链地址 / 开放寻址）、扩容逻辑 |
| 跳表（LevelDB 核心）   | 1206          | Design Skiplist               | LevelDB/RocksDB 的核心索引结构，分布式存储中替代红黑树的高性能索引，高频设计题 |
| 链表操作（存储底层）   | 25            | Reverse Nodes in k-Group      | 存储系统中链表式数据块管理，考察链表指针操作（C++ 高频）、边界处理 |
|                        | 148           | Sort List                     | 存储数据分片排序，考察 O (n logn) 排序算法（归并）在链表上的实现，高性能场景必考点 |
| 树 / 红黑树（RocksDB） | 98            | Validate Binary Search Tree   | RocksDB 底层 MemTable 的红黑树实现基础，考察 BST 核心特性    |
|                        | 230           | Kth Smallest Element in a BST | 存储索引的高频查询场景，考察树的遍历优化                     |

#### 2. 分布式系统相关算法（ObjectStore 核心场景）

这类题匹配 “distributed environments、scalability、data consistency”，侧重考察分布式系统的核心算法思想，部分无直接 LeetCode 题，但会以编程 / 设计题形式出现。

| 题型方向          | LeetCode 题号 | 题目 / 考点名称                 | 匹配 JD 的核心原因                                           |
| ----------------- | ------------- | ------------------------------- | ------------------------------------------------------------ |
| 一致性哈希        | 无（设计题）  | Consistent Hashing              | 分布式哈希表（ObjectStore）的核心分片策略，考察哈希环、虚拟节点设计，必问设计题 |
| 分布式锁          | 无（编程题）  | Distributed Lock Implementation | 分布式存储的并发控制核心，考察基于 CAS / 红锁的 C++ 实现     |
| 数据分片 / 一致性 | 151           | Reverse Words in a String       | （间接）分布式数据分片的字符串处理，延伸考察 Paxos/Raft 协议的核心逻辑（设计题） |
| 限流 / 性能控制   | 480           | Sliding Window Median           | 分布式存储的流量控制场景，考察滑动窗口算法，延伸到漏桶 / 令牌桶实现 |
| 海量数据处理      | 23            | Merge k Sorted Lists            | 分布式存储的多节点数据合并场景，考察归并算法、优先级队列优化 |
|                   | 347           | Top K Frequent Elements         | 分布式日志 / 遥测数据（telemetry）的 TopK 统计，考察堆 / 哈希表的高性能实现 |

#### 3. 高性能 C++ 编程题（匹配 “high performance C++ code”）

这类题不直接对应 LeetCode，但会以代码手写形式考察，核心是 C++ 性能优化、内存管理、并发编程：

- 手写双向链表（带内存池优化）：存储底层数据结构，考察内存池减少 malloc 开销；
- 实现一个线程安全的哈希表：分布式系统并发场景，考察 C++11 + 的 mutex/atomic、分段锁（Striped Lock）；
- RocksDB 读写流程优化：考察对 LSM 树的理解，如 Compaction 策略、WAL 日志写入优化；
- 内存对齐 / 缓存行优化：考察对 CPU 缓存的理解，如何减少缓存失效（如结构体对齐、避免伪共享）。

#### 4. 基础算法（通用考察）

这类题是面试基础，用于筛选算法基本功，JD 要求 “core algorithms problems”，以下是高频题：

| 题型方向             | LeetCode 题号 | 题目名称                       | 匹配 JD 的核心原因                                    |
| -------------------- | ------------- | ------------------------------ | ----------------------------------------------------- |
| 数组 / 字符串        | 283           | Move Zeroes                    | 考察原地操作、性能优化（避免额外空间）                |
|                      | 49            | Group Anagrams                 | 哈希表高频应用，分布式数据分组场景                    |
| 动态规划（性能优化） | 53            | Maximum Subarray               | 基础 DP，延伸考察存储系统的资源分配优化               |
| 二分查找（存储索引） | 33            | Search in Rotated Sorted Array | 存储索引的高频查询场景，考察二分变种                  |
| 并发编程基础         | 无（编程题）  | 生产者消费者模型               | 考察 C++ 条件变量、队列实现，分布式存储的任务调度核心 |

### 三、面试题特点总结

1. **侧重 “工程落地”**：算法题不仅考思路，更考 C++ 高性能实现（如时间 / 空间复杂度优化、内存管理），比如 LRU Cache 要求用双向链表 + unordered_map，且要考虑并发安全；
2. **结合存储场景**：所有算法题都会围绕 “存储、分布式、性能” 展开，比如链表题会关联 “存储数据块管理”，哈希表题关联 “分布式哈希表”；
3. **设计题＞纯算法题**：分布式系统相关的设计题（一致性哈希、分布式锁、Raft 协议）占比更高，匹配 JD 中 “architectural design、design documents” 的要求；
4. **RocksDB/LevelDB 相关**：大概率会问跳表、LSM 树、Compaction 等底层实现，甚至手写跳表核心逻辑。

### 四、备考优先级建议

1. 优先掌握：LRU Cache（146）、Design HashMap（706）、Reverse Nodes in k-Group（25）、Merge k Sorted Lists（23）、Design Skiplist（1206）；
2. 重点准备设计题：一致性哈希、分布式锁、跳表实现、RocksDB LSM 树流程；
3. 补充 C++ 高性能编程：内存池、分段锁、缓存行优化、并发容器实现。











[TOC]







# 50 · 数组剔除元素后的乘积 Product of Array Exclude Itself   Easy

前缀积，从后向前算积，然后从前向后算积，除去i的位置。

```
    def product_exclude_itself(self, nums: List[int]) -> List[int]:
        m = len(nums)
        f = [0 for _ in range(m + 1)]
        f[m] = 1
        for i in range(m - 1, 0, -1):
            f[i] = f[i + 1] * nums[i]
        
        tmp = 1
        res = []
        for i in range(m):
            res.append(tmp * f[i + 1])
            tmp *= nums[i]
        return res
```



# 53 · 翻转字符串 Easy

```
    def reverse_words(self, s: str) -> str:
        ws = s.split()
        m = len(ws)
        l = 0
        r = m - 1
        while l < r:
            ws[l],ws[r] = ws[r],ws[l]
            l += 1
            r -= 1
        return ' '.join(ws)
```



# 56 · 两数之和 Easy

other = target - numbers[i]

```
    def two_sum(self, numbers: List[int], target: int) -> List[int]:
        m = len(numbers)
        s = collections.defaultdict(int)
        for i in range(m):
            other = target - numbers[i]
            if other in s.keys():
                return [s[other], i]
            s[numbers[i]] = i
        return [-1, -1]
```



# 165 · 合并两个排序链表 Easy

```
    def merge_two_lists(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy = ListNode(-1)
        cur = dummy
        while l1 and l2:
            if l1.val < l2.val:
                cur.next = l1
                l1 = l1.next
            else:
                cur.next = l2
                l2 = l2.next
            cur = cur.next
        if l1:
            cur.next = l1
        if l2:
            cur.next = l2
        return dummy.next
```
![e](./assets/2025-12-05_20-43-04.png)
```
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if (l1 == nullptr) {
            return l2;
        } else if (l2 == nullptr) {
            return l1;
        } else if (l1->val < l2->val) {
            l1->next = mergeTwoLists(l1->next, l2);
            return l1;
        } else {
            l2->next = mergeTwoLists(l1, l2->next);
            return l2;
        }
    }
```





# 213 · 字符串压缩 Easy

```
Input: str = "aabcccccaaa"
Output: "a2b1c5a3"
```

```
    def compress(self, original_string: str) -> str:
        if len(original_string) == 0:
            return ""
        pre = original_string[0]
        res = []
        count = 0
        for c in original_string:
            if c == pre:
                count += 1
            else:
                res += pre + str(count)
                count = 1
            pre = c
        res += pre + str(count)
        
        if len(res) >= len(original_string):
            return original_string
        return "".join(res)
```

原地: 用三个指针，1. 原字符串扫描 2. 重复次数 3. write的位置

``` 
class Solution:
    def compress(self, chars: List[str]) -> int:
        n = len(chars)
        i = 0
        write = 0
        while i < n:
            j = i
            while j < n and chars[j] == chars[i]:
                j += 1
            chars[write] = chars[i]
            write += 1
            if j - i > 1:
                for c in str(j-i):
                    chars[write] = c
                    write += 1
            i = j
        return write
```





# 433 · 岛屿的个数 Easy

```
class Solution:
    def isInBound(self, x, y, m, n):
        if x < 0 or y < 0 or x >= m or y >= n:
            return False
        return True

    def dfs(self, grid, x, y):
        m, n = len(grid), len(grid[0])
        dx = [0,0,1,-1]
        dy = [1,-1,0,0]
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            if not self.isInBound(nx, ny, m, n) or grid[nx][ny] == 0:
                continue
            grid[nx][ny] = 0
            self.dfs(grid, nx, ny)
    
    def num_islands(self, grid: List[List[bool]]) -> int:
        if len(grid) == 0:
            return 0
        m, n = len(grid), len(grid[0])
        res = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    res += 1
                    self.dfs(grid, i, j)
        return res
```

```
class Solution {
public:
    int find(unordered_map<int, int>& p, int x)
    {
        if (p[x] != x) p[x] = find(p, p[x]);
        return p[x];
    }
    int idx(int x, int y, int m)
    {
        return x * m + y;
    }
    bool isInBound(int x, int y, int m, int n)
    {
        if (x >= m || y >= n || x < 0 || y < 0)
            return false;
        return true;
    }
    int numIslands(vector<vector<bool>> &grid) {
        if (grid.size() == 0)
            return 0;
        
        int m = grid.size();
        int n = grid[0].size();

        unordered_map<int, int> p;
        for(int i = 0; i < m; i++)
            for(int j = 0; j < n; j++)
                p[idx(i, j, m)] = idx(i, j, m);

        int dx[4] = {0,0,-1,1};
        int dy[4] = {-1,1,0,0};
        for(int i = 0; i < m; i++)
        {
            for(int j = 0; j < n; j++)
            {
                if (grid[i][j] != 1)
                    continue;
                for (int d = 0; d < 4; d++)
                {
                    int nx = i + dx[d];
                    int ny = j + dy[d];
                    if (!isInBound(nx, ny, m, n) || grid[nx][ny] != 1 ||
                        p[find(p, idx(i, j, m))] == find(p, idx(nx, ny, m)))
                        continue;

                    p[find(p, idx(i, j, m))] = find(p, idx(nx, ny, m));
                }
            }
        }
        
        unordered_set<int> s;
        for(int i = 0; i < m; i++)
        {
            for(int j = 0; j < n; j++)
            {
                if (grid[i][j] == 1)
                {
                    s.insert(find(p, idx(i, j, m)));
                }
            }
        }
        return s.size();
    }
};
```

```
class Solution:
    """
    @param grid: a boolean 2D matrix
    @return: an integer
    """
    def isInBound(self, x, y, m, n):
        if x < 0 or x >= m or y < 0 or y >= n:
            return False
        return True 
    def bfs(self, grid, x, y, visit):
        m = len(grid)
        n = len(grid[0])
        dx = (0, 0, 1, -1)
        dy = (1, -1, 0, 0)
        q = deque([(x, y)])
        visit.add((x, y))

        while len(q) > 0:
            cur = q.popleft()
            #print (cur)
            for i in range(4):
                nx = cur[0] + dx[i]
                ny = cur[1] + dy[i]
                if not self.isInBound(nx, ny, m, n) or ((nx, ny) in visit):
                    continue
                if grid[nx][ny] != 1:
                    continue

                visit.add((nx, ny))
                q.append((nx, ny))

        
    def num_islands(self, grid: List[List[bool]]) -> int:
        if len(grid) == 0:
            return 0
        if len(grid[0]) == 0:
            return 0
        m = len(grid)
        n = len(grid[0])
        visit = set()
        res = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1 and ((i, j) not in visit):
                    res += 1
                    self.bfs(grid, i, j, visit)
        return res
```



# 464 · 整数排序 II Easy

```
    void quick_sort(vector<int> &a, int l, int r)
    {
        if (l >= r)
            return;
        int i = l - 1;
        int j = r + 1;
        int x = a[(i + j) / 2];
        while (i < j)
        {
            do { i++; } while(a[i] < x);
            do { j--; } while(a[j] > x);
            if (i < j)
                swap(a[i], a[j]);
        }
        quick_sort(a, l, j);
        quick_sort(a, j + 1, r);
    }
    void sortIntegers2(vector<int> &a) {
        quick_sort(a, 0, a.size() - 1);
    }
```

```
def bubble_sort(arr):
    """
    最基本的冒泡排序实现
    时间复杂度：O(n²)，空间复杂度：O(1)
    """
    n = len(arr)
    
    # 进行 n-1 轮排序
    for i in range(n - 1):
        # 每轮比较相邻元素
        for j in range(0, n - 1 - i):
            if arr[j] > arr[j + 1]:
                # 交换位置
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    
    return arr

# 测试
nums = [64, 34, 25, 12, 22, 11, 90]
print("原始数组:", nums)
print("排序结果:", bubble_sort(nums.copy()))
```

```
    void merge_sort(vector<int>& a, int l, int r)
    {
        if (l >= r)
            return;
        int mid = (l + r) / 2;
        merge_sort(a, l, mid);
        merge_sort(a, mid + 1, r);

        vector<int> tmp(a.size(), 0);
        int k = 0, i = l, j = mid + 1;
        while(i <= mid && j <= r)
        {
            if (a[i] < a[j])
            {
                tmp[k++] = a[i++];
            }
            else
            {
                tmp[k++] = a[j++];
            }
        }
        while(i <= mid)
        {
            tmp[k++] = a[i++];
        }
        while(j <= r)
        {
            tmp[k++] = a[j++];
        }
        i = l, j = 0;
        while (i <= r)
            a[i++] = tmp[j++];
    }
    void sortIntegers2(vector<int> &a) {
        merge_sort(a, 0, a.size() - 1);
    }
```



# 539 · 移动零 Easy

```
    def move_zeroes(self, nums: List[int]):
        m = len(nums)
        l, r = 0, 0
        while r < m:
            if nums[r] != 0:
                nums[r], nums[l] = nums[l], nums[r]
                l += 1
                r += 1
            elif nums[r] == 0:
                r += 1
```



# 1181 · 二叉树的直径 Diameter of Binary Tree

- **题目描述**：给定二叉树的根节点，返回该树的直径（任意两节点之间的最长路径长度，路径可不经过根节点，长度为路径上的边数）。

- **示例**：输入 `1->2->3->4->5`，返回 `3`（路径 4-2-1-3 或 5-2-1-3，边数 3）。

- 思路：递归法，计算每个节点的 “左深度 + 右深度”，取最大值即为直径。

    直径：左子树的最深长度，加上右子树最深长度，加1

    ```
            if (root == nullptr)
                return 0;
            int l = postorder(root->left, res);
            int r = postorder(root->right, res);
    
            if (res < (l + r + 1))
            {
                res = l + r + 1;
            }
    
            return max(l + 1, r + 1);
            
    ```

    ```
        def dfs(self, root):
            if root == None:
                return 0
            l = self.dfs(root.left)
            r = self.dfs(root.right)
            if self.res < l + r + 1:
                self.res = l + r + 1
            return max(l + 1, r + 1)
    
        def diameter_of_binary_tree(self, root: TreeNode) -> int:
            self.res = 0 
            self.dfs(root)
            return self.res - 1
    ```

    

# > 1517 · 最大子数组  Largest subarray

给定一个由N个整数构成的数组A和一个整数K，
从所有长度为K的A的连续子数组中返回最大的连续子数组。
如果两个数组中的第一个不相等元素在A中的值大于B中的值，则我们定义子数组A大于子数组B。
例如,A=[1,2,4,3]，B=[1,2,3,5].
A大于B，因为A [2]> B [2]。

```
输入:
[1,4,3,2,5]
4
输出:
[4,3,2,5]
解释:
该数组有两个长度为4的连续子数组，分别为:
[1,4,3,2] 以及 [4,3,2,5].
所以最大的子数组为 [4,3,2,5].
```

```
    def largest_subarray(self, a: List[int], k: int) -> List[int]:
        m = len(a)
        start = 0
        for i in range(m - k + 1):
            for j in range(k):
                if a[start + j] > a[i + j]:
                    break
                elif a[start + j] < a[i + j]:
                    start = i
                    break
        return a[start:start+k]
```



# 5 · 第k大元素  Kth Largest Element

```
    int kthLargestElement(int k, vector<int> &nums) {
        int m = nums.size();
        priority_queue<int, vector<int>, greater<int>> q;
        for (auto c : nums)
        {
            q.push(c);
            if (q.size() > k)
            {
                q.pop();
            }
        }

        return q.top();
    }
```



```
    void quick_sort(vector<int>& nums, int l, int r)
    {
        if (l >= r)
            return;
        int i = l - 1;
        int j = r + 1;
        int x = nums[(i + j) / 2];
        while(i < j)
        {
            do { i++; } while(nums[i] > x);
            do { j--; } while(nums[j] < x);
            if (i < j)
                swap(nums[i], nums[j]);
        }
        quick_sort(nums, l, j);
        quick_sort(nums, j + 1, r);
    }
    int findKthLargest(vector<int>& nums, int k) {
        quick_sort(nums, 0, nums.size() - 1);
        return nums[k - 1];
    }
```

```
    int findKthLargest(vector<int>& nums, int k) {
        // 题目中 nums[i] 的范围是 [-10^4, 10^4]，共 20001 个可能值
        const int OFFSET = 10000; // 偏移量，将负数转为非负索引
        vector<int> count(20001, 0);
        
        // 统计每个数值出现的次数
        for (int num : nums) {
            count[num + OFFSET]++;
        }
        
        // 从大到小遍历计数数组，累计次数
        int remaining = k;
        for (int i = 20000; i >= 0; --i) {
            remaining -= count[i];
            if (remaining <= 0) {
                return i - OFFSET; // 转回原数值
            }
        }
        
        return -1; // 理论上不会执行到这里
    }
```

```
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        M = max(nums)
        m = min(nums)
        l = m
        r = M
        while l < r:
            count = 0
            mid = (l + r + 1) // 2
            for n in nums:
                if n >= mid:
                    count += 1
            if count >= k:
                l = mid
            else:
                r = mid - 1
        return l

        
```

前面用的if n >= mid:，所以后面if count >= k:也要这么判断， 因为if count <= k:不可能存在，因为count包含mid   （n >= mid）



# 52 · 下一个排列 Medium （DFS 可解，更优为贪心，但 DFS 是通用思路）

下一个排列 → **LeetCode 31. Next Permutation**

a. 从后向前找到第一个升序nums[i] < nums[i  + 1], 存下i, 如果i不存在则说明是最后一个排列

b. 从后向前找第一个大于nums[i] 的j，存下j,

c. 交换nums[i], nums[j]

d. 将i + 1 到 len(nums) - 1的序列，逆序



降序是每个子序列的最大排列，那么就可以从后向前找这个降序的最大长度，这个长度之前的那个数就是要更换的数，在这个数的右边找第一个比他大的就可以，类似数值进位，然后把剩下的数从小到大排列，从小到大排列是一个子序列的最小排列

```
class Solution:
    def next_permutation(self, nums: List[int]) -> List[int]:
        m = len(nums)
        i = m - 2
        while i >= 0 and nums[i] >= nums[i + 1]:
            i -= 1
        if i >= 0:
            j = m - 1
            while j >= i and nums[i] >= nums[j]:
                j -= 1
            nums[i], nums[j] = nums[j], nums[i]
        l = i + 1
        r = m - 1
        while l < r:
            nums[l], nums[r] = nums[r], nums[l]
            l += 1
            r -= 1
        return nums
```



注意到下一个排列总是比当前排列要大，除非该排列已经是最大的排列。我们希望找到一种方法，能够找到一个大于当前序列的新序列，且变大的幅度尽可能小。具体地：

我们需要将一个左边的「较小数」与一个右边的「较大数」交换，以能够让当前排列变大，从而得到下一个排列。

同时我们要让这个「较小数」尽量靠右，而「较大数」尽可能小。当交换完成后，「较大数」右边的数需要按照升序重新排列。这样可以在保证新排列大于原来排列的情况下，使变大的幅度尽可能小。

**以排列 [4,5,2,6,3,1] 为例：**

我们能找到的符合条件的一对「较小数」与「较大数」的组合为 2 与 3，满足「较小数」尽量靠右，而「较大数」尽可能小。

当我们完成交换后排列变为 [4,5,3,6,2,1]，此时我们可以重排「较小数」右边的序列，序列变为 [4,5,3,1,2,6]。

具体地，我们这样描述该算法，对于长度为 n 的排列 a：

首先从后向前查找第一个顺序对 (i,i+1)，满足 a[i]<a[i+1]。这样「较小数」即为 a[i]。此时 [i+1,n) 必然是下降序列。

如果找到了顺序对，那么在区间 [i+1,n) 中从后向前查找第一个元素 j 满足 a[i]<a[j]。这样「较大数」即为 a[j]。

交换 a[i] 与 a[j]，此时可以证明区间 [i+1,n) 必为降序。我们可以直接使用双指针反转区间 [i+1,n) 使其变为升序，而无需对该区间进行排序。





# 62 · 搜索旋转排序数组  Search in Rotated Sorted Array

```
class Solution:
    def check(self, a, l, r, mid, target):
        if a[l] <= a[mid]:
            if a[l] <= target and target <= a[mid]:
                return True
            else:
                return False
        else:
            if a[mid] < target and target < a[r]:
                return False
            else:
                return True

    def search(self, a: List[int], target: int) -> int:
        if len(a) == 0:
            return -1
        m = len(a)
        l = 0
        r = m - 1
        while l < r:
            mid = (l + r) // 2
            if self.check(a, l, r, mid, target):
                r = mid
            else:
                l = mid + 1
        if a[l] == target:
            return l
        return -1
```

**Search in Rotated Sorted Array II**

```
    def search(self, nums: List[int], target: int) -> bool:
        if not nums:
            return False
        
        l, r = 0, len(nums) - 1
        
        while l < r:  # 保持原循环条件
            mid = (l + r) // 2
            
            if nums[mid] == target:
                return True  # 找到目标直接返回
            
            # 处理重复元素：无法判断有序段时，缩小左边界（避免死循环）
            if nums[l] == nums[mid] == nums[r]:
                l += 1
            elif nums[l] <= nums[mid]:  # 左段有序
                # target 在左段有序区间内，收缩右边界
                if nums[l] <= target < nums[mid]:
                    r = mid
                else:
                    l = mid + 1
            else:  # 右段有序
                # target 在右段有序区间内，收缩左边界
                if nums[mid] < target <= nums[r]:
                    l = mid + 1
                else:
                    r = mid
        
        # 循环结束后 l == r，检查最后一个元素
        return nums[l] == target if nums else False

```





# 71 · 二叉树的锯齿形层次遍历  Binary Tree Zigzag Level Order Traversal

```
    def zigzag_level_order(self, root: TreeNode) -> List[List[int]]:
        if root == None:
            return []
        q = collections.deque([root])
        res = []
        count = 1
        while len(q) > 0:
            row = []
            level = len(q)
            for i in range(level):
                cur = q.popleft()
                row.append(cur.val)
                if cur.left:
                    q.append(cur.left)
                if cur.right:
                    q.append(cur.right)

            if not count % 2:
                row.reverse()

            res.append(list(row))
            count += 1
        return res
```



```
class Solution:
    def preorder(self, root: TreeNode, h, level):
        if root == None:
            return
        if not (level % 2):
            h[level].append(root.val)
        else:
            h[level].insert(0, root.val)

        self.preorder(root.left, h, level + 1)
        self.preorder(root.right, h, level + 1)
        
        
    def zigzag_level_order(self, root: TreeNode) -> List[List[int]]:
        h = collections.defaultdict(list)
        self.preorder(root, h, 0)
        res = []
        for v in h.values():
            res.append(v)
        return res

```



# 107 · 单词拆分（一） Word Break          

trie 树

```
class Trie:
    def __init__(self):
        self.children = [None] * 26
        self.isEnd = False
        self.word = ""
    def insert(self, word):
        cur = self 
        for ch in word:
            asc = ord(ch) - ord('a')
            if not cur.children[asc]:
                cur.children[asc] = Trie()
            cur = cur.children[asc]
        cur.isEnd = True
        cur.word = word
    def search(self, word):
        cur = self 
        for ch in word:
            asc = ord(ch) - ord('a')
            if not cur.children[asc]:
                return False
            cur = cur.children[asc]
        return cur.isEnd

class Solution:

    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        m = len(s)
        tree = Trie()
        for w in wordDict:
            tree.insert(w)

        q = collections.deque([0])
        visit = [False for _ in range(m + 1)]
        while len(q) > 0:
            cur = q.popleft()
            for i in range(cur, m):
                if visit[i]:
                    continue
                tmp = s[cur: i + 1]
                if tree.search(tmp):
                    if i == m - 1:
                        return True 
                    q.append(i + 1)
                    visit[i] = True 
        return False
```

![](./assets/2025-12-06_19-54-28.png)

```
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        m = len(s)
        dp = [False for _ in range(m + 1)]
        dp[0] = True
        for i in range(m):
            for j in range(i + 1, m + 1):
                if dp[i] and s[i: j] in wordDict:
                    dp[j] = True
        return dp[m]
```

**582 · Word Break II**

1是判断能不能分，2是分成什么样

给一字串s和单词的字典dict,在字串中增加空格来构建一个句子，并且所有单词都来自字典。
返回所有有可能的句子。

```
输入："lintcode"，["de","ding","co","code","lint"]
输出：["lint code", "lint co de"]
解释：
插入一个空格是"lint code"，插入两个空格是 "lint co de"
```

```
    unordered_map<string, vector<string>> mem;
    vector<string> dfs(string& s, unordered_set<string> &wordDict)
    {
        int m = s.size();
        if (mem.count(s))
            return mem[s];

        vector<string> res;
        if (wordDict.count(s))
            res.push_back(s);

        for (int i = 1; i <= m; i++)
        {
            string t = s.substr(0, i);
            if (wordDict.count(t))
            {
                string tmp = s.substr(i, m - i + 1);
                //cout << tmp << endl;
                auto ret = dfs(tmp, wordDict);
                for (auto rt : ret)
                {
                    res.push_back(t + " " + rt);
                }
            }
        }
        mem[s] = res;
        return res;
    }
    vector<string> wordBreak(string &s, unordered_set<string> &wordDict) {
        return dfs(s, wordDict);
    }
```

```
class Solution:
    """
    @param s: A string
    @param word_dict: A set of words.
    @return: All possible sentences.
             we will sort your return value in output
    """
    def dfs(self, s, word_dict, mem):
        if len(s) == 0:
            return ""
        if s in mem:
            return mem[s]
        res = []
        if s in word_dict:
            res.append(s)

        for i in range(1, len(s)):
            t = s[:i]
            if t in word_dict:
                ret = self.dfs(s[i:], word_dict, mem)
                for r in ret:
                    res.append(t + " " + r)
        mem[s] = res
        return res

    def word_break(self, s: str, word_dict: Set[str]) -> List[str]:
        mem = collections.defaultdict(str)
        return self.dfs(s, word_dict, mem)
```





# 136 · 分割回文串  Palindrome Partitioning   

```
class Solution:
    def isPal(self, s):
        l = 0
        r = len(s) - 1
        while l < r:
            if s[l] != s[r]:
                return False
            l += 1
            r -= 1
        return True
    def dfs(self, s, cur, curlist, res):
        if cur == len(s):
            res.append(list(curlist))
        for i in range(cur, len(s)):
            tmp = s[cur:i + 1]
            if not self.isPal(tmp):
                continue
            curlist.append(tmp)
            self.dfs(s, i+1, curlist, res)
            curlist.pop()
    def partition(self, s):
        res = []
        self.dfs(s, 0, [], res)
        return res
```



```
class Solution:
    def is_cri(self, s):
        return s == s[::-1]

    def partition(self, s: str) -> List[List[str]]:
        if len(s) == 0: return [[]]
        res = []
        for i in range(1, len(s)+1):
            c = s[:i]
            if self.is_cri(c):
                r = [[]] if i >= len(s) else self.partition(s[i:])
                for rr in r:
                    res.append([c] + rr)
        return res
```





# 153 · 数字组合 II  Combination Sum II

```
class Solution:
    def dfs(self, can, target, idx, curlist, sum, res):
        if sum > target:
            return
        if target == sum:
            res.append(list(curlist))
        
        for i in range(idx, len(can)):
            if i > idx and can[i] == can[i - 1]:
                continue
            curlist.append(can[i])
            self.dfs(can, target, i + 1, curlist, sum + can[i], res)
            curlist.pop()

    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        candidates.sort()
        self.dfs(candidates, target, 0, [], 0, res)
        return res
```





# 159 · 寻找旋转排序数组中的最小值  159 · Find Minimum in Rotated Sorted Array

旋转数组找最小值，都要考虑右端点

```
    def find_min(self, nums: List[int]) -> int:
        l = 0
        r = len(nums) - 1
        while l < r:
            mid = (l + r) // 2
            if nums[len(nums) - 1] >= nums[mid]:
                r = mid
            else:
                l = mid + 1
        return nums[l]
```



```
    def find_min(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return nums[0]
        if nums[0] < nums[len(nums) - 1]:
            return nums[0]

        l = 0
        r = len(nums) - 1
        while l < r:
            mid = (l + r) // 2
            if nums[0] > nums[mid]:
                r = mid
            else:
                l = mid + 1
        return nums[l]
```





# 160 · 寻找旋转排序数组中的最小值 II Medium 159 · Find Minimum in Rotated Sorted Array

和上面一样，考虑右边端点，如果相等将r -= 1

```
    def findMin(self, nums: List[int]) -> int:
        l = 0
        r = len(nums) - 1
        while l < r:
            mid = (l + r) // 2
            if nums[mid] < nums[r]:
                r = mid
            elif nums[mid] > nums[r]:
                l = mid + 1
            else:
                r -= 1
        return nums[l]
```



# 191 · 乘积最大子数组 Medium

与 “最大子数组和” 不同，**乘积的最大子数组** 存在关键特性：

- 负数 × 负数 = 正数，可能让原本的最小值（负）乘以当前负数后，变成最大值（正）；
- 正数 × 负数 = 负数，会让原本的最大值（正）变成最小值（负）。

例如：数组 `[2, -3, -4]`，若只跟踪最大值，会得到 `2 → max(2×-3, -3)=-3 → max(-3×-4, -4)=12`（结果正确）；但如果数组是 `[-2, 3, -4]`，仅跟踪最大值会得到 `-2 → max(-2×3, 3)=3 → max(3×-4, -4)=-4`，但实际最大乘积是 `-2×3×-4=24` —— 这说明**仅跟踪最大值是不够的，必须同时跟踪最小值**。

### 案例验证：以 `nums = [-2, 3, -4]` 为例

| 索引 `i` | `nums[i]` | `imax[i]` 计算    | `imin[i]` 计算    | `res` 更新   |
| -------- | --------- | ----------------- | ----------------- | ------------ |
| 0        | -2        | -2                | -2                | -2           |
| 1        | 3（正）   | max(-2×3, 3)=3    | min(-2×3, 3)=-6   | max(-2,3)=3  |
| 2        | -4（负）  | max(-6×-4, -4)=24 | min(3×-4, -4)=-12 | max(3,24)=24 |

```
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        vector<int> imax(n), imin(n);  // 定义DP数组，imax[i]存以i结尾的最大乘积，imin[i]存最小
        int i, res;

        res = imax[0] = imin[0] = nums[0];  // 初始化：第一个元素的最大/最小都是自己，结果初始为第一个元素
        for(i = 1; i < n; i++){  // 从第二个元素开始遍历
            if(nums[i] > 0){  // 当前元素为正
                // 最大乘积：前一个最大×当前正，或当前正（重新开始子数组）
                imax[i] = max(imax[i - 1] * nums[i], nums[i]);
                // 最小乘积：前一个最小×当前正，或当前正（重新开始子数组）
                imin[i] = min(imin[i - 1] * nums[i], nums[i]);
            }
            else{  // 当前元素为负（包括0）
                // 最大乘积：前一个最小×当前负（负负得正可能更大），或当前负（重新开始子数组）
                imax[i] = max(imin[i - 1] * nums[i], nums[i]);
                // 最小乘积：前一个最大×当前负（正负得负可能更小），或当前负（重新开始子数组）
                imin[i] = min(imax[i - 1] * nums[i], nums[i]);
            }
            res = max(res, imax[i]);  // 更新全局最大乘积
        }

        return res;  // 返回最终结果
    }
};
```

优化解：

你贴的这个解法，本质上是**前一种分正负写法的 “简化版 / 统一版”** —— 它不再显式判断 `nums[i]` 是正还是负，而是直接把所有可能的情况（前一个最大值 × 当前值、前一个最小值 × 当前值、当前值本身）纳入计算，通过 `max`/`min` 函数自动筛选出正确的 `dpmax[i]` 和 `dpmin[i]`。

```cpp
dpmax[i] = max(nums[i], max(dpmax[i-1]*nums[i], dpmin[i-1]*nums[i]));
dpmin[i] = min(nums[i], min(dpmax[i-1]*nums[i], dpmin[i-1]*nums[i]));
```

```
int maxProduct(vector<int> &nums) {
    int len = nums.size();
    int dpmax[20010] = {0};  // 存储以i结尾的最大乘积，数组大小20010是预留足够空间（题目nums长度≤20000）
    int dpmin[20010] = {0};  // 存储以i结尾的最小乘积

    dpmax[0] = nums[0];      // 初始化：第一个元素的最大乘积是自己
    dpmin[0] = nums[0];      // 初始化：第一个元素的最小乘积是自己
    int res = nums[0];       // 全局最大结果初始化为第一个元素
    for (int i = 1; i < len; ++i)
    { 
        // 计算dpmax[i]：三种可能选最大（前最大×当前、前最小×当前、当前值本身）
        dpmax[i] = max (nums[i], max(dpmax[i - 1] * nums[i], dpmin[i - 1] * nums[i]));
        // 计算dpmin[i]：三种可能选最小（前最大×当前、前最小×当前、当前值本身）
        dpmin[i] = min (nums[i], min(dpmax[i - 1] * nums[i], dpmin[i - 1] * nums[i]));
        // 更新全局最大结果
        res = max (res, dpmax[i]); 
    }

    return res;
}
```



根据最大子序和，要算dmax[i]， dmin[i], 求下面三个的max和min即可

nums[i - 1], dmax[i - 1] * nums[i - 1], dmin[i - 1] * nums[i - 1]

```
    def max_product(self, nums: List[int]) -> int:
        m = len(nums)
        dmax = [0 for _ in range(m + 1)]
        dmin = [0 for _ in range(m + 1)]
        dmax[0] = 1
        dmin[0] = 1
        res = -math.inf
        for i in range(1, m + 1):
            dmax[i] = max(nums[i - 1], max(dmax[i - 1] * nums[i - 1], dmin[i - 1] * nums[i - 1]))
            dmin[i] = min(nums[i - 1], min(dmax[i - 1] * nums[i - 1], dmin[i - 1] * nums[i - 1]))
            res = max(res, dmax[i])
        return res
```





**最大子序和**

dp[i] 以i为结尾的数的最大和

```
    def maxSubArray(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return nums[0]
        m = len(nums)
        dp = collections.defaultdict(int)
        dp[0] = nums[0]
        res = dp[0]
        for i in range(1, m):
            dp[i] = max(dp[i - 1] + nums[i], nums[i])
            res = max(res, dp[i])
        return res
```







# 425 · 电话号码的字母组合 Medium



```
    def dfs(self, digits, h, idx, curlist, res):
        if len(curlist) == len(digits):
            res.append("".join(curlist))
            return
        for c in h[digits[idx]]:
            curlist.append(c)
            self.dfs(digits, h, idx + 1, curlist, res)
            curlist.pop()
        
    def letter_combinations(self, digits: str) -> List[str]:
        if len(digits) == 0:
            return []
        h = {"2":"abc", "3":"def", "4":"ghi", "5":"jkl", "6":"mno", "7":"pqrs", "8":"tuv", "9":"wxyz"}
        res = []
        self.dfs(digits, h, 0, [], res)
        return res
```





# 860 · 不同岛屿的个数 Medium

pattern 算当前点和原点的距离

```
class Solution:
    def isInBound(self, x, y, m, n):
        if x < 0 or y < 0 or x >= m or y >= n:
            return False
        return True

    def bfs(self, grid, x, y, ox, oy):
        m, n = len(grid), len(grid[0])
        dx = [0,0,1,-1]
        dy = [1,-1,0,0]
        q = collections.deque([(x, y)])
        pattern = ""
        while len(q) > 0:
            cur = q.popleft()
            pattern += str(cur[0] - ox) + str(cur[1] - oy)
            for i in range(4):
                nx = cur[0] + dx[i]
                ny = cur[1] + dy[i]
                if not self.isInBound(nx, ny, m, n) or grid[nx][ny] != 1:
                    continue
                q.append((nx, ny))
                grid[nx][ny] = 0
        return pattern

    def numberof_distinct_islands(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        res = set()
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    pattern = self.bfs(grid, i, j, i, j)
                    res.add(pattern)
        return len(res)
```



# 919 · 会议室 II Medium

**会议室 I**

```
    def can_attend_meetings(self, intervals: List[Interval]) -> bool:
        new_intervals = sorted(intervals, key = lambda x: x.start)
        end_time = -1
        for i in new_intervals:
            if i.start < end_time:
                return False
            end_time = i.end
        return True
```

**会议室 II**

扫描线，对所有点排序，从左到右扫描每个点，是起点就加一，是终点就减一，判断这个过程中的最大值

```
import heapq
class Solution:
    def min_meeting_rooms(self, intervals: List[Interval]) -> int:
        h = []
        for i in intervals:
            heapq.heappush(h, (i.start, 1))
            heapq.heappush(h, (i.end, -1))
        res = 0
        count = 0
        while len(h) > 0:
            cur = heapq.heappop(h)
            count += cur[1]
            res = max(res, count)
        return res
```







# 54 · 转换字符串到整数 Hard

四步：1. 清空格 2. 获得符号 3. 算数 4. 查范围是否越界

```
    def atoi(self, s: str) -> int:
        s = s.strip()
        if len(s) == 0:
            return 0

        flag = 1
        if s[0] == '-':
            flag = -1
            s = s[1:]
        elif s[0] == '+':
            s = s[1:]
        
        res = 0
        scale = 1
        for i in s:
            if not i.isdigit():
                break
            res = res * 10 + int(i)
        
        res *= flag
        INT_MIN, INT_MAX = -2**31, 2**31 - 1
        if res > INT_MAX:
            return INT_MAX
        elif res < INT_MIN:
            return INT_MIN
        return res
```





# 134 · LRU缓存策略 Hard

利用std::list::splice()方法

lru_.splice(lru_.begin(), lru_, table_[key]);     

将lru位于table_[key]的位置的元素，移动到lru_.begin()的地方, table_[key]为iterator

```
#include <list>
class LRUCache {
public:
    LRUCache(int capacity) : _capacity(capacity) {

    }

    int get(int key) {
        auto it = _table.find(key);
        if (it != _table.end()) {
            _lru.splice(_lru.begin(), _lru, it->second);
            return it->second->second;
        }
        return -1;
    }

    void set(int key, int value) {
        auto it = _table.find(key);
        if (it != _table.end()) {
            _lru.splice(_lru.begin(), _lru, it->second);
            it->second->second = value;
            return;
        }

        _lru.emplace_front(key, value);
        _table[key] = _lru.begin();

        if (_table.size() > _capacity) {
            _table.erase(_lru.back().first);
            _lru.pop_back();
        }
    }
private:
    unordered_map<int, std::list<std::pair<int, int>>::iterator> _table;
    std::list<std::pair<int, int>> _lru;
    int _capacity;
};
```



# 判断二叉树是否对称 → **LeetCode 101. Symmetric Tree**

   递归判断左右，每层的最左边，和最右边是否对称，还有每层的中间

   ```
class Solution {
public:
    bool issym(TreeNode* left, TreeNode* right)
    {
        if ((!left && right) || (left && !right))
            return false;
        if (!left && !right)
            return true;
        if (left->val != right->val)
            return false;
        return issym(left->left, right->right) && issym(left->right, right->left);
    }

    bool isSymmetric(TreeNode *root) {
        if (root == nullptr)
            return true;
        return issym(root->left, root->right);
    }
};
   ```

   

# 633 · Find the Duplicate Number

题目要求：1. 是连续数列里面有重复，找出这个重复  2. 数组只读不能排序，解法空间O(1)

```
index: 1 2 3 4 5
value: 1 2 3 3 4
```

用二分法，在某个index的位置算小于等于这个index的数字的个数， 例如index==3，count==3,  但是 index==4, count==5。因此可以看出，当count<=index的时候mid是在重复数字的左边，当count > index的时候mid在重复数字的右边。

```
class Solution:
    def count(self, nums, mid):
        cnt = 0
        for i in nums:
            if i <= mid:
                cnt += 1
        return cnt

    def find_duplicate(self, nums: List[int]) -> int:
        m = len(nums)
        l = 0
        r = m - 1

        while l < r:
            mid = (l + r + 1) // 2
            if self.count(nums, mid) <= mid:
                l = mid
            else:
                r = mid - 1
        return l + 1
```





# 156 · Merge Intervals

```
    def merge(self, intervals: List[Interval]) -> List[Interval]:
        intervals.sort(key=lambda x: x.start)
        res = []
        for e in intervals:
            if len(res) == 0 or e.start > res[-1].end:
                res.append(e)
            else:
                res[-1].end = e.end if res[-1].end < e.end else res[-1].end
        return res
            
```



# 7 · Serialize and Deserialize Binary Tree

```
class Solution:
    """
    @param root: An object of TreeNode, denote the root of the binary tree.
    This method will be invoked first, you should design your own algorithm 
    to serialize a binary tree which denote by a root node to a string which
    can be easily deserialized by your own "deserialize" method later.
    """
    def serialize(self, root):
        if root == None:
            return None
        q = collections.deque([root])
        res = []
        while len(q) > 0:
            cur = q.popleft()
            if cur.val != -1:
                res.append(str(cur.val))
            else:
                res.append("#")
                continue
            l = cur.left if cur.left != None else TreeNode(-1)
            q.append(l)
            r = cur.right if cur.right != None else TreeNode(-1)
            q.append(r)
        return " ".join(res)

    """
    @param data: A string serialized by your serialize method.
    This method will be invoked second, the argument data is what exactly
    you serialized at method "serialize", that means the data is not given by
    system, it's given by your own serialize method. So the format of data is
    designed by yourself, and deserialize it here as you serialize it in 
    "serialize" method.
    """
    def deserialize(self, data):
        if data == None:
            return None
        lnodes = [TreeNode(int(n)) if n != "#" else None for n in data.split()]
        root = lnodes[0]
        nodes = [root]
        slow = 0
        fast = 1
        while slow < len(nodes):
            cur = nodes[slow]
            cur.left = lnodes[fast]
            cur.right = lnodes[fast + 1]

            if cur.left:
                nodes.append(cur.left)
            if cur.right:
                nodes.append(cur.right)
            slow += 1
            fast += 2
        return root

```

1. 先TreeNode() 2. while slow < len(nodes)

```
class Solution:
    """
    @param root: An object of TreeNode, denote the root of the binary tree.
    This method will be invoked first, you should design your own algorithm 
    to serialize a binary tree which denote by a root node to a string which
    can be easily deserialized by your own "deserialize" method later.
    """

    def bfs(self, root):
        if root == None:
            return ""
        res = []
        q = collections.deque([root])
        while len(q) > 0:
            cur = q.popleft()
            res.append(str(cur.val) if cur != None else "#")
            if cur != None:
                q.append(cur.left)
                q.append(cur.right)
        return " ".join(res)

    def serialize(self, root):
        if root == None:
            return None
        return self.bfs(root)

        

    """
    @param data: A string serialized by your serialize method.
    This method will be invoked second, the argument data is what exactly
    you serialized at method "serialize", that means the data is not given by
    system, it's given by your own serialize method. So the format of data is
    designed by yourself, and deserialize it here as you serialize it in 
    "serialize" method.
    """
    def deserialize(self, data):
        if not data:
            return None

        lnode = [TreeNode(int(sn)) if sn != "#" else None for sn in data.split()]
        
        slow = 0
        fast = 1
        root = lnode[0]
        nodes = [root]
        while slow < len(nodes):
            cur = nodes[slow]
            slow += 1

            l = lnode[fast]
            r = lnode[fast + 1]
            fast += 2

            cur.left  = l if l != None else None
            cur.right = r if r != None else None
            if l:
                nodes.append(l)
            if r:
                nodes.append(r)
        return root
```



# 450 · Reverse Nodes in k-Group

1. 先找到第一段的end  2. 断开后面的链接 3. 将当前列表反转 4.链接到pre.next和next_group 5. 复位pre end

```
    def reverse(self, head):  # 修正1：参数名更清晰，返回反转后的头节点
        cur = head
        pre = None
        while cur is not None:
            tmp = cur.next
            cur.next = pre
            pre = cur
            cur = tmp
        return pre  # 修正2：返回反转后的头节点（pre）
    
    def reverse_k_group(self, head: ListNode, k: int) -> ListNode:
        dummy = ListNode(-1, head)
        pre = dummy
        end = dummy
        
        while end.next is not None:
            # 修正3：正确的分组判断逻辑
            for _ in range(k):
                end = end.next
                if end is None:  # 走k步过程中end为空，不足k个，直接返回
                    return dummy.next
            
            # 保存下一组的头节点 + 切断当前组
            next_group = end.next
            end.next = None
            start = pre.next
            
            # 修正4：接收反转后的头节点
            reversed_head = self.reverse(start)
            
            # 修正5：正确的拼接逻辑（先拼头，再拼尾）
            pre.next = reversed_head  # 反转后的头节点拼到pre后面
            start.next = next_group   # 反转后的尾节点（原start）拼接下一组
            
            # 重置pre和end，准备下一组
            pre, end = start, start
        
        return dummy.next

```



```
class Solution:
    # 翻转一个子链表，并且返回新的头与尾
    def reverse(self, head: ListNode, tail: ListNode):
        prev = tail.next
        p = head
        while prev != tail:
            nex = p.next
            p.next = prev
            prev = p
            p = nex
        return tail, head

    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:
        hair = ListNode(0)
        hair.next = head
        pre = hair

        while head:
            tail = pre
            # 查看剩余部分长度是否大于等于 k
            for i in range(k):
                tail = tail.next
                if not tail:
                    return hair.next
            nex = tail.next
            head, tail = self.reverse(head, tail)
            # 把子链表重新接回原链表
            pre.next = head
            tail.next = nex
            pre = tail
            head = tail.next
        
        return hair.next
```





# 706. Design HashMap

```
class MyHashMap {
public:
    MyHashMap(): data(768) {
        
    }
    
    int hash(int key)
    {
        return key % 768;
    }

    void put(int key, int value) {
        int hkey = hash(key);
        for (auto it = data[hkey].begin(); it != data[hkey].end(); it++)
        {
            if (it->first == key)
            {
                it->second = value;
                return;
            }
        }
        data[hkey].emplace_back(key, value);
    }
    
    int get(int key) {
        int hkey = hash(key);
        for (auto it = data[hkey].begin(); it != data[hkey].end(); it++)
        {
            if (it->first == key)
            {
                return it->second;
            }
        }
        return -1;
    }
    
    void remove(int key) {
        int hkey = hash(key);
        for (auto it = data[hkey].begin(); it != data[hkey].end(); it++)
        {
            if (it->first == key)
            {
                data[hkey].erase(it);
                return;
            }
        }
    }
private:
    vector<list<pair<int, int>>> data;

};

```



```
class MyHashMap:

    def __init__(self):
        self.data = collections.defaultdict(dict)
    
    def hashfunc(self, key):
        return key % 768 

    def put(self, key: int, value: int) -> None:
        hkey = self.hashfunc(key)
        self.data[hkey][key] = value

    def get(self, key: int) -> int:
        hkey = self.hashfunc(key)
        if key in self.data[hkey]:
            return self.data[hkey][key]
        return -1

    def remove(self, key: int) -> None:
        hkey = self.hashfunc(key)
        if key in self.data[hkey]:
            del self.data[hkey][key]

```





# 155. Min Stack

![](./assets/155_fig1.gif)

```
class MinStack {
public:
    MinStack() {
        min_st_.push(INT_MAX);
    }
    
    void push(int val) {
        st_.push(val);
        min_st_.push(min(val, min_st_.top()));
    }
    
    void pop() {
        st_.pop();
        min_st_.pop();
    }
    
    int top() {
        return st_.top();
    }
    
    int getMin() {
        return min_st_.top();
    }
private:
    stack<int> st_;
    stack<int> min_st_;
};
```



# 合并 K 个有序链表 → **LeetCode 23. Merge k Sorted Lists**

   ```
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if (lists.empty())
            return nullptr;
        priority_queue<ListNode*, vector<ListNode*>, std::function<bool(ListNode*, ListNode*)>> q([](ListNode* l, ListNode* r) -> bool {
            return l->val > r->val;
        });
        for (auto l : lists)
        {
            if (!l)
                continue;
            q.push(l);
        }
        ListNode* dummy = new ListNode(-1);
        ListNode* h = dummy;
        while (!q.empty())
        {
            auto cur = q.top(); q.pop();
            h->next = cur;
            if (cur && cur->next)
                q.push(cur->next);
            h = h->next;
        }
        return dummy->next;
    }
};
   ```

   ```
class Solution {
public:
    struct cmd
    {
        bool operator()(const ListNode* a, const ListNode* b)
        {
            return a->val > b->val;
        }
    };
    ListNode *mergeKLists(vector<ListNode *> &lists) {
        priority_queue<ListNode*, vector<ListNode*>, cmd> q;
        int m = lists.size();
        for (int i = 0; i < m; i++)
        {
            if (lists[i])
            {
                q.push(lists[i]);
            }
        }

        auto dummy = ListNode(-1);
        auto p = &dummy;
        while(!q.empty())
        {
            auto cur = q.top(); q.pop();
            p->next = cur;
            p = p->next;
            if (cur->next)
            {
                q.push(cur->next);
            }
        }

        return dummy.next;
    }
};


   ```



# 137 · Clone Graph

```
from lintcode import (
    UndirectedGraphNode,
)

"""
Definition for a UndirectedGraphNode:
class UndirectedGraphNode:
    def __init__(self, label):
        self.label = label
        self.neighbors = []
"""

class Solution:
    """
    @param node: A undirected graph node
    @return: A undirected graph node
    """
    def getnode(self, node):
        nodelist = [node]
        d = collections.deque([node])
        while len(d) > 0:
            cur = d.popleft()
            for n in cur.neighbors:
                if n not in nodelist:
                    nodelist.append(n)
                    d.append(n)
        return nodelist

    def clone_graph(self, node: UndirectedGraphNode) -> UndirectedGraphNode:
        if node == None:
            return None
        nl = self.getnode(node)

        nmap = {}
        for n in nl:
            nmap[n] = UndirectedGraphNode(n.label)
        for n in nl:
            for ne in n.neighbors:
                nmap[n].neighbors.append(nmap[ne])
        return nmap[node]
```
BFS
```
class Solution {
public:
    /**
     * @param node: A undirected graph node
     * @return: A undirected graph node
     */
    UndirectedGraphNode* cloneGraph(UndirectedGraphNode *node) {
        if(!node)
            return nullptr;
        unordered_map<UndirectedGraphNode *, UndirectedGraphNode *> mclone;

        UndirectedGraphNode* croot = new UndirectedGraphNode(node->label);
        mclone[node] = croot;
        queue<UndirectedGraphNode *> q;
        q.push(node);

        while (!q.empty())
        {
            auto cur = q.front(); q.pop();
            for (auto n : cur->neighbors)
            {
                auto it = mclone.find(n);
                if (it != mclone.end())
                {
                    mclone[cur]->neighbors.push_back(it->second);
                }
                else
                {
                    auto newNode = new UndirectedGraphNode(n->label);
                    mclone[cur]->neighbors.push_back(newNode);
                    mclone[n] = newNode;
                    q.push(n);
                }
            }
        }
        return croot;

    }
};
```

DFS

```
class Solution {
public:
    UndirectedGraphNode* dfs(UndirectedGraphNode* node, unordered_map<int, UndirectedGraphNode*>& visit)
    {
        if (!node)
            return nullptr;
        
        auto it = visit.find(node->label);
        if (it == visit.end())
        {
            UndirectedGraphNode* current = new UndirectedGraphNode(node->label);
            visit.insert(make_pair(current->label, current));
            for (auto c : node->neighbors)
            {
                UndirectedGraphNode* child = dfs(c, visit);
                current->neighbors.push_back(child);
            }
        }

        return visit[node->label];
    }

    UndirectedGraphNode* cloneGraph(UndirectedGraphNode* node) {
        if (!node)
        {
            return nullptr;
        }

        unordered_map<int, UndirectedGraphNode*> visit;
        return dfs(node, visit);
    }
};
```



# **LeetCode 105. Construct Binary Tree from Preorder and Inorder Traversal（从前序与中序遍历序列构造二叉树）**

- **题目描述**：给定二叉树的前序遍历数组 `preorder` 和中序遍历数组 `inorder`，构造并返回该二叉树。

- **示例**：`preorder = [3,9,20,15,7]`，`inorder = [9,3,15,20,7]`，返回根节点为 3，左子树 9，右子树 20（20 的左右子树 15、7）。

- 思路：前序的第一个元素是根，在中序中找到根的位置，划分左右子树区间，递归构造左右子树。

    ```
            if len(preorder) == 0 or len(inorder) == 0:
                return None
            if len(preorder) == 1:
                return TreeNode(preorder[0])
    
            curRoot = TreeNode(preorder[0])
            idx = inorder.index(preorder[0])
            curRoot.left = self.dfs(preorder[1:idx + 1], inorder[:idx])
            curRoot.right = self.dfs(preorder[idx + 1:], inorder[idx + 1:])
            return curRoot
    ```

    ```
    class Solution {
    public:
        TreeNode* preorder_search(const vector<int>& preorder, int pBegin, int pEnd, const vector<int>& inorder, int iBegin, int iEnd)
        {
            if(pBegin > pEnd || iBegin > iEnd)
                return nullptr;
    
            auto current = new TreeNode(preorder[pBegin]);
            int leftsize = 0;
            for (int i = iBegin; i < iEnd; i++)
            {
                if (inorder[i] == preorder[pBegin])
                    break;
                leftsize++;
            }
    
            current->left = preorder_search(preorder, pBegin + 1, pBegin + leftsize, inorder, iBegin, iBegin + leftsize - 1);
            current->right = preorder_search(preorder, pBegin + leftsize + 1, pEnd, inorder, iBegin + leftsize + 1, iEnd);
            return current;
        }
        TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
            return preorder_search(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1);
        }
    };
    ```

    ```
    class Solution {
    public:
        TreeNode* preorder_search(const vector<int>& preorder, vector<int>& inorder)
        {
            if(preorder.empty() || inorder.empty())
                return nullptr;
    
            auto current = new TreeNode(preorder[0]);
    
            auto rootIt = find(inorder.begin(), inorder.end(), preorder[0]);
            int leftSize = rootIt - inorder.begin();
    
            vector<int> leftPreorder(preorder.begin() + 1, preorder.begin() + 1 + leftSize);
            vector<int> leftInorder(inorder.begin(), rootIt);
            
            vector<int> rightPreorder(preorder.begin() + 1 + leftSize, preorder.end());
            vector<int> rightInorder(rootIt + 1, inorder.end());
    
            current->left = preorder_search(leftPreorder, leftInorder);
            current->right = preorder_search(rightPreorder, rightInorder);
    
            return current;
        }
        TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
            return preorder_search(preorder, inorder);
        }
    };
    ```

    

# **LeetCode 106. Construct Binary Tree from Inorder and Postorder Traversal（从中序与后序遍历序列构造二叉树）**

- **题目描述**：给定二叉树的中序遍历数组 `inorder` 和后序遍历数组 `postorder`，构造并返回该二叉树。

- **示例**：`inorder = [9,3,15,20,7]`，`postorder = [9,15,7,20,3]`，返回同上的二叉树。

- 思路：后序的最后一个元素是根，在中序中找到根的位置，划分左右子树区间，递归构造左右子树。

- 第一次调用：

    text

    ```
    根节点值: 3 (postorder[4])
    在inorder中的位置: idx = 1
    左子树大小: leftsize = 1
    ```

    

    **正确的切片**：

    - 左子树后序遍历: `[9]` (postorder[0:1])
    - 右子树后序遍历: `[15, 7, 20]` (postorder[1:4])

    

    ```
    class Solution:
        def preorder(self, inorder, postorder):
            if len(inorder) == 0 or len(postorder) == 0:
                return None
            current = TreeNode(postorder[-1])
            idx = inorder.index(postorder[-1])
            current.left = self.preorder(inorder[:idx], postorder[:idx])
            current.right = self.preorder(inorder[idx + 1:], postorder[idx:-1])
            return current
    
        def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
            return self.preorder(inorder, postorder)
    ```

    ```
        TreeNode* preorder_search(vector<int>& inorder, vector<int>& postorder)
        {
            if (inorder.empty() || postorder.empty())
                return nullptr;
                
            int root_val = postorder.back();
            auto current = new TreeNode(root_val);
            auto it = std::find(inorder.begin(), inorder.end(), root_val);
            int leftsize = it - inorder.begin();
    
            vector<int> leftInorder(inorder.begin(), it);
            vector<int> leftPostorder(postorder.begin(), postorder.begin() + leftsize);
            vector<int> rightInorder(it + 1, inorder.end());
            vector<int> rightPostorder(postorder.begin() + leftsize, postorder.end() - 1);
    
            current->left = preorder_search(leftInorder, leftPostorder);
            current->right = preorder_search(rightInorder, rightPostorder);
            return current;
        }
    ```

    

# 464 · Sort Integers II 

归并排序 

```
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int mid = l + r >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);

    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];

    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];

    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}

```

```
    void merge_sort(vector<int>& a, int l, int r)
    {
        if (l >= r)
            return;
        int mid = (l + r) / 2;
        merge_sort(a, l, mid);
        merge_sort(a, mid + 1, r);

        vector<int> tmp(a.size(), 0);
        int k = 0, i = l, j = mid + 1;
        while (i <= mid && j <= r)
        {
            if (a[i] <= a[j])
                tmp[k++] = a[i++];
            else
                tmp[k++] = a[j++];
        }
        while (i <= mid)
        {
            tmp[k++] = a[i++];
        }
        while (j <= r)
        {
            tmp[k++] = a[j++];
        }
        i = l;k = 0;
        while (i <= r)
        {
            a[i++] = tmp[k++];
        }
    }
    void sortIntegers2(vector<int> &a) {
        merge_sort(a, 0, a.size() - 1);
    }
```

快速排序

```
    void quick_sort(vector<int>& a, int l, int r)
    {
        if (l >= r)
            return;
        int i = l - 1;
        int j = r + 1;
        int x = a[(l + r) / 2];
        while (i < j)
        {
            do { i++; } while(a[i] < x);
            do { j--; } while(a[j] > x);
            if (i < j)
                swap(a[i], a[j]);
        }
        quick_sort(a, l, j);
        quick_sort(a, j + 1, r);
    }
    void sortIntegers2(vector<int> &a) {
        quick_sort(a, 0, a.size() - 1);
    }
```

# 4. Median of Two Sorted Arrays

三路归并

```
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        i, j = 0, 0
        m,n = len(nums1), len(nums2)
        tmp = []
        while i < m and j < n:
            if nums1[i] < nums2[j]:
                tmp.append(nums1[i])
                i += 1
            else:
                tmp.append(nums2[j])
                j += 1
        while i < m:
            tmp.append(nums1[i])
            i += 1
        while j < n:
            tmp.append(nums2[j])
            j += 1
        l = len(tmp)
        if l % 2:
            return float(tmp[l // 2])
        return (tmp[l//2 - 1] + tmp[l//2]) / 2.0
```

















### **LeetCode 对应题目**

| 题目                                                         | 难度   | 说明                       |
| ------------------------------------------------------------ | ------ | -------------------------- |
| [23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/) | Hard   | 经典 k路归并，用小根堆     |
| [632. 最小区间](https://leetcode.cn/problems/smallest-range-covering-elements-from-k-lists/) | Hard   | k路归并 + 滑动窗口         |
| [295. 数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/) | Hard   | 动态 k路归并思想（两个堆） |
| [378. 有序矩阵的第k小元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/) | Medium | k路归并或二分              |
| [373. 查找和最小的 K 对数字](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/) | Medium | k路归并变种                |

> **最直接对应 k路归并的是 LeetCode 23**









































## n次方 快速幂

### 428 · Pow(x, n)   50. Pow(x, n)

```
// 如果x^(n/2)，即x的一半，是偶数，x^n = y * y
// 如果x^(n/2)，即x的一半，是奇数，x^n = y * y * x
class Solution {
public:
    double quickMul(double x, long long N) {
        if (N == 0) {
            return 1.0;
        }
        double y = quickMul(x, N / 2);
        return N % 2 == 0 ? y * y : y * y * x;
    }

    double myPow(double x, int n) {
        long long N = n;
        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
    }
};
```

```
class Solution {
public:
    double myPow(double x, int n) {
        unsigned int N = abs(n);
        double res = 1;
        double cur = x;
        while (N > 0)
        {
            if (N & 1)
            {
                res *= cur;
            }
            cur *= cur;
            N >>= 1;
        }
        return n < 0 ? 1.0 / res: res;
    }
};
```

## 质数

### 1324 · Count Primes

```
class Solution {
public:
    vector<int> primes;
    int cnt = 0;   
    bool st[2000000];     
    int res = 0;
    Solution(): primes(2000000, 0) {}

    void get_primes(int n)
    {
        for (int i = 2; i <= n; i ++ )
        {
            if (!st[i]) 
            {
                primes[cnt ++ ] = i;
            }
            for (int j = 0; primes[j] <= n / i; j ++ )
            {
                st[primes[j] * i] = true;
                if (i % primes[j] == 0) break;
            }
        }
    }

    int countPrimes(int n) {
        get_primes(n);

        for (auto c : primes)
            if (c != 0 && c != n)
                res++;
        return res;
    }
};
```

## 高精度

```
// C = A + B, A >= 0, B >= 0
vector<int> add(vector<int> &A, vector<int> &B)
{
    if (A.size() < B.size()) return add(B, A);

    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i ++ )
    {
        t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }

    if (t) C.push_back(t);
    return C;
}
```

### 2. Add Two Numbers





## GCD

845 · Greatest Common Divisor

辗转相除

以计算 gcd⁡(48,18)gcd(48,18) 为例：

1. 48÷18=248÷18=2 余 1212 → gcd⁡(48,18)=gcd⁡(18,12)gcd(48,18)=gcd(18,12)
2. 18÷12=118÷12=1 余 66 → gcd⁡(18,12)=gcd⁡(12,6)gcd(18,12)=gcd(12,6)
3. 12÷6=212÷6=2 余 00 → 余数为 0，最大公约数是 **6**。

```
int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}

def gcd(self, a: int, b: int) -> int:
    return self.gcd(b, a % b) if b else a;
```

