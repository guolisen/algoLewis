微软北京研发中心的算法面试题通常注重基础数据结构（链表、树、数组、哈希表）、经典算法（动态规划、贪心、DFS/BFS）及实际场景问题。以下是高频题目总结，包含 LeetCode 题号、英文名称、描述、解题思路及 Python 实现：

### 1. 两数之和（LeetCode 1. Two Sum）

**题目描述**：给定整数数组 `nums` 和目标值 `target`，返回两个数的索引，使它们的和为 `target`。假设只有一个解，且同一元素不重复使用。

- 输入：`nums = [2,7,11,15], target = 9`
- 输出：`[0,1]`

**解题思路**：用哈希表存储已遍历元素的值与索引，遍历数组时计算 `target - 当前值`，若差值在哈希表中，直接返回索引对。

**Python 实现**：

```python
def twoSum(nums, target):
    num_map = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in num_map:
            return [num_map[complement], i]
        num_map[num] = i
    return []
```

### 2. 反转链表（LeetCode 206. Reverse Linked List）

**题目描述**：反转单链表，返回反转后的头节点。

- 输入：`1->2->3->4->5->NULL`
- 输出：`5->4->3->2->1->NULL`

**解题思路**：用迭代法，维护 `prev`（前驱节点）和 `curr`（当前节点），每次将 `curr.next` 指向 `prev`，逐步移动指针完成反转。

**Python 实现**：

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseList(head):
    prev, curr = None, head
    while curr:
        next_node = curr.next  # 暂存下一个节点
        curr.next = prev       # 反转指针
        prev, curr = curr, next_node  # 移动指针
    return prev
```

### 3. 二叉树的层序遍历（LeetCode 102. Binary Tree Level Order Traversal）

**题目描述**：按层遍历二叉树，返回每层节点值的列表（从左到右，逐层收集）。

- 输入：`[3,9,20,null,null,15,7]`
- 输出：`[[3],[9,20],[15,7]]`

**解题思路**：用队列实现 BFS，每层遍历前记录队列长度（当前层节点数），依次弹出节点并收集值，同时将子节点入队。

**Python 实现**：

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def levelOrder(root):
    if not root:
        return []
    from collections import deque
    q = deque([root])
    res = []
    while q:
        level_size = len(q)
        level = []
        for _ in range(level_size):
            node = q.popleft()
            level.append(node.val)
            if node.left:
                q.append(node.left)
            if node.right:
                q.append(node.right)
        res.append(level)
    return res
```

### 4. 最长回文子串（LeetCode 5. Longest Palindromic Substring）

**题目描述**：给定字符串 `s`，返回最长的回文子串（回文是正向和反向读都相同的字符串）。

- 输入：`s = "babad"`
- 输出：`"bab"` 或 `"aba"`

**解题思路**：中心扩展法：遍历每个字符（及相邻字符对）作为回文中心，向两侧扩展寻找最长回文子串，记录最大值。

**Python 实现**：

```python
def longestPalindrome(s):
    def expand(left, right):
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return s[left+1:right]  # 返回扩展后的回文子串
    
    if not s:
        return ""
    res = ""
    for i in range(len(s)):
        # 奇数长度回文（中心为单个字符）
        s1 = expand(i, i)
        # 偶数长度回文（中心为两个字符）
        s2 = expand(i, i+1)
        res = max(res, s1, s2, key=len)
    return res
```

### 5. 最小路径和（LeetCode 64. Minimum Path Sum）

**题目描述**：给定 `m x n` 网格，从左上角到右下角的路径（只能右移或下移）中，求路径上所有数字的最小和。

- 输入：`grid = [[1,3,1],[1,5,1],[4,2,1]]`
- 输出：`7`（路径：1→3→1→1→1）

**解题思路**：动态规划：`dp[i][j]` 表示到达 `(i,j)` 的最小路径和，状态转移为 `dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])`，边界处理第一行和第一列。

**Python 实现**：

```python
def minPathSum(grid):
    m, n = len(grid), len(grid[0])
    # 初始化dp数组（可直接修改原grid节省空间）
    for i in range(m):
        for j in range(n):
            if i == 0 and j == 0:
                continue  # 起点不变
            elif i == 0:
                grid[i][j] += grid[i][j-1]  # 第一行只能左移到达
            elif j == 0:
                grid[i][j] += grid[i-1][j]  # 第一列只能上移到达
            else:
                grid[i][j] += min(grid[i-1][j], grid[i][j-1])
    return grid[-1][-1]
```

### 6. LRU 缓存（LeetCode 146. LRU Cache）

**题目描述**：实现 LRU（最近最少使用）缓存机制，支持 `get(key)`（获取值，若不存在返回 - 1）和 `put(key, value)`（插入 / 更新，满时删除最少使用项）。

- 输入：`["LRUCache","put","put","get","put","get","put","get","get","get"]`，`[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]`
- 输出：`[null,null,null,1,null,-1,null,-1,3,4]`

**解题思路**：哈希表 + 双向链表：哈希表映射键到链表节点（O (1) 访问），双向链表维护使用顺序（头部为最近使用，尾部为最少使用），操作时调整节点位置。

**Python 实现**：

```python
class Node:
    def __init__(self, key=0, value=0):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None

class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = {}
        self.head, self.tail = Node(), Node()
        self.head.next = self.tail
        self.tail.prev = self.head

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        node = self.cache[key]
        self._move_to_head(node)
        return node.value

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            node = self.cache[key]
            node.value = value
            self._move_to_head(node)
        else:
            node = Node(key, value)
            self.cache[key] = node
            self._add_to_head(node)
            if len(self.cache) > self.capacity:
                removed = self._remove_tail()
                del self.cache[removed.key]

    def _move_to_head(self, node):
        self._remove_node(node)
        self._add_to_head(node)

    def _remove_node(self, node):
        node.prev.next = node.next
        node.next.prev = node.prev

    def _add_to_head(self, node):
        node.prev = self.head
        node.next = self.head.next
        self.head.next.prev = node
        self.head.next = node

    def _remove_tail(self):
        node = self.tail.prev
        self._remove_node(node)
        return node
```

### 7. 岛屿数量（LeetCode 200. Number of Islands）

**题目描述**：给定二维网格，`'1'` 表示陆地，`'0'` 表示水，求岛屿数量（岛屿是相邻陆地连接成的区域，只考虑上下左右相邻）。

- 输入：`grid = [["1","1","0","0","0"],["1","1","0","0","0"],["0","0","1","0","0"],["0","0","0","1","1"]]`
- 输出：`3`

**解题思路**：DFS/BFS：遍历网格，遇到 `'1'` 时启动 DFS/BFS，将所有相连的 `'1'` 标记为 `'0'`（避免重复计数），计数岛屿数量。

**Python 实现**：

```python
def numIslands(grid):
    if not grid:
        return 0
    m, n = len(grid), len(grid[0])
    count = 0

    def dfs(i, j):
        if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != '1':
            return
        grid[i][j] = '0'  # 标记为已访问
        dfs(i+1, j)
        dfs(i-1, j)
        dfs(i, j+1)
        dfs(i, j-1)

    for i in range(m):
        for j in range(n):
            if grid[i][j] == '1':
                count += 1
                dfs(i, j)
    return count
```

### 总结

微软面试注重代码简洁性、边界处理及算法效率。以上题目覆盖了高频考点，建议熟练掌握并理解思路迁移（如动态规划、BFS/DFS 的通用模板）。面试时可先沟通思路，再动手实现，确保代码可读性和正确性。





# 《编程之美 —— 微软技术面试心得》核心内容总结

本书由微软亚洲研究院工程师编写，聚焦微软技术面试高频考点，涵盖算法、数据结构、数学思维等核心模块，每个章节均围绕面试实际场景设计题目，强调问题分析、思路推导与优化能力，是备战微软及大厂技术面试的核心参考资料。以下是各章节关键内容梳理（含面试核心要素）：

## 第 1 章 游戏之乐 —— 游戏中碰到的题目

### 核心主题

通过游戏场景抽象算法问题，考察**问题转化、贪心策略、递归回溯、多线程协同**等能力。

### 关键内容（面试高频考点）

1. **让 CPU 占用率曲线听你指挥**：
    - 核心问题：控制 Windows CPU 使用率（固定值 / 正弦曲线）。
    - 解法：利用忙循环（空循环）与 Sleep () 调节忙闲比例，结合 GetTickCount ()、PerformanceCounter 动态适配 CPU 性能，多 CPU 场景需用 SetThreadAffinityMask 绑定核心。
    - 面试要素：操作系统线程调度、API 使用（Sleep/GetTickCount）、性能优化思维。
2. **中国象棋将帅问题**：
    - 核心问题：仅用一个变量存储将帅位置，输出所有合法布局（不照面）。
    - 解法：位运算拆分变量（4bit 存将位置，4bit 存帅位置），通过位掩码（LMASK/RMASK）读写数据。
    - 面试要素：位运算优化、空间压缩技巧。
3. **一摞烙饼的排序**：
    - 核心问题：通过翻转最上方若干块饼，求最少翻转次数使饼有序。
    - 解法：递归回溯 + 剪枝（上下界约束：最少翻转次数下界 = 相邻无序对数，上界 = 2 (n-1)），贪心策略优先翻转最大饼到目标位置。
    - 面试要素：回溯算法优化、剪枝思想、问题抽象能力。
4. **买书**

​	10本以内用dfs，多余十本，余数用dfs，十本用5+5 = 10 * 25%最大收益

1. **快速找出故障机器**：
    - 核心问题：海量机器 ID 中找出仅出现一次的 ID（单台 / 两台故障）。
    - 解法：异或运算（O (1) 空间，O (n) 时间）、求和 / 求积（应对两台故障，避免溢出）。
    - 面试要素：位运算应用、海量数据处理（低空间复杂度）。
2. **NIM 游戏系列（1-3）**：
    - 核心问题：多堆石头取物博弈，求必胜策略。
    - 解法：利用异或运算（NIM 和为 0 则必输）、斐波那契数列（特殊规则 NIM）、不安全局面推导（两堆石头游戏）。
    - 面试要素：博弈论、数学归纳法、规律抽象能力。
3. **双线程高效下载**：
    - 核心问题：多线程协同（下载线程 + 写盘线程），避免数据竞争。
    - 解法：循环队列 + 信号量（Semaphore）同步，控制缓存区满 / 空状态，避免忙等。
    - 面试要素：多线程同步（信号量 / 互斥锁）、生产者 - 消费者模型。
4. **连连看 / 俄罗斯方块 / 挖雷游戏设计**：
    - 核心问题：游戏核心逻辑（路径查找、积木摆放优化、概率计算）。
    - 解法：BFS 找最短路径（连连看转弯数≤2）、贪心 + 计分制（俄罗斯方块最优摆放）、概率统计（挖雷剩余方块地雷概率）。
    - 面试要素：场景建模、搜索算法（BFS）、启发式优化。

## 第 2 章 数字之魅 —— 数字中的技巧

### 核心主题

聚焦数组、数字运算、序列处理，考察**边界处理、动态规划、分治、数学推导**能力。

### 关键内容（面试高频考点）

1. **求二进制数中 1 的个数**：
    - 解法：除 2 取余、位运算（n&(n-1) 消去最低位 1）、查表法（空间换时间，O (1) 时间）。
    - 面试要素：位运算优化、时间 / 空间权衡。
    
2. **不要被阶乘吓倒**：
    - 核心问题：N! 末尾 0 的个数（质因数 5 的个数）、N! 二进制最低位 1 的位置（质因数 2 的个数 + 1）。
    
    - 解法：公式推导（末尾 0 个数 =ΣN/5^k，k≥1；最低位 1 位置 =ΣN/2^k）。
    
    - 面试要素：数学规律推导、质因数分解。
    
    - n的阶乘可以分解为素数乘积 2x * 3y * 5z，其中2的个数远大于5（不用计算2）, 再由于每个2 * 5都会产生一个10（既尾部多一个0）因此统计n里面有多少个5即可
    
        ```
        ret = 0
        for (int i = 1; i <= N; i++)
        {
        	j = i;
        	while(j % 5 == 0)
        	{
        		ret++;
        		j /= 5
        	}
        }
        ```
    
        ```
        ```
    
        
    
3. **寻找发帖 “水王”**：
    - 核心问题：找出发帖数超过总数一半的 ID。
    - 解法：摩尔投票法（O (n) 时间，O (1) 空间），成对抵消不同 ID，剩余即为水王。
    - 扩展：找 3 个发帖数超过 1/4 的 ID（扩展投票法）。
    - 面试要素：海量数据统计、空间优化。
    
4. **1 的数目**：
    - 核心问题：计算 1~N 中所有数字包含 “1” 的总个数。
    - 解法：按位拆分（个位 / 十位 / 百位...），统计每一位出现 1 的次数（受高位、当前位、低位影响）。
    - 面试要素：数位 DP 思想、分情况讨论。
    
5. **寻找最大的 K 个数**：
    - 解法：快排分治（平均 O (n)）、最小堆（O (n log k)，适合海量数据）、计数排序（适合数值范围小的场景）。
    - 面试要素：海量数据处理、算法时间 / 空间复杂度权衡。
    
6. **子数组之和的最大值**：
    - 核心问题：一维 / 二维数组中，连续子数组的最大和。
    - 解法：一维（动态规划 O (n)，空间优化至 O (1)）、二维（转化为一维，枚举上下边界，O (n²m)）。
    - 扩展：环形数组最大子数组和（拆分两种情况：不跨边界 / 跨边界）。
    - 面试要素：动态规划、问题转化、空间优化。
    
7. **最长递增子序列**：
    - 解法：动态规划 O (n²)、二分优化 O (n log n)（维护递增子序列最小尾元素）。
    - 面试要素：动态规划优化、二分查找应用。

## 第 3 章 结构之法 —— 字符串及链表的探索

### 核心主题

聚焦字符串、链表、树、队列等基础数据结构，考察**操作优化、边界处理、递归遍历**能力。

### 关键内容（面试高频考点）

1. **字符串移位包含问题**：
    - 核心问题：判断 s2 是否为 s1 循环移位后的子串。
    - 解法：s1+s1 包含所有循环移位结果，调用 strstr 判断（O (n) 时间）。
    - 面试要素：字符串操作优化、问题转化。
2. **从无头单链表中删除节点**：
    - 核心问题：无表头指针，删除中间节点。
    - 解法：“狸猫换太子”，将后继节点数据复制到当前节点，删除后继节点。
    - 面试要素：链表操作边界处理、空间限制下的技巧。
3. **编程判断两个链表是否相交**：
    - 核心问题：无环单链表是否相交（相交则最后一个节点相同）。
    - 解法：遍历两链表记录尾节点对比；或拼接链表判断是否有环。
    - 扩展：找相交第一个节点、有环链表相交判断。
    - 面试要素：链表遍历、边界处理（空链表）。
4. **重建二叉树**：
    - 核心问题：根据前序 + 中序遍历结果重建二叉树。
    - 解法：前序首元素为根，中序拆分左右子树，递归重建。
    - 面试要素：二叉树遍历特性、递归思想、边界检查（空树 / 单节点）。
5. **分层遍历二叉树**：
    - 解法：队列 BFS（记录每层节点数），非递归实现（避免栈溢出）。
    - 扩展：逆序分层遍历、按深度从下到上遍历。
    - 面试要素：树的遍历、队列应用。
6. **求二叉树中节点的最大距离**：
    - 核心问题：二叉树中相距最远的两个节点距离（边数）。
    - 解法：深度优先搜索，记录每个节点左右子树最大深度，更新全局最大距离。
    - 面试要素：树的递归遍历、全局变量维护。
7. **队列中取最大值操作问题**：
    - 核心问题：设计支持 O (1) 取最大值的队列。
    - 解法：双栈实现队列（栈 A 存元素，栈 B 维护最大值），或最大堆 + 链表（入队 O (log n)，取最大值 O (1)）。
    - 面试要素：数据结构扩展、空间换时间。

## 第 4 章 数学之趣 —— 数学游戏的乐趣

### 核心主题

通过数学问题考察**逻辑推理、概率计算、组合数学**能力，题目多无固定编程模板，侧重思维推导。

### 关键内容（面试高频考点）

1. **金刚坐飞机问题**：
    - 核心问题：金刚插队后，乘客随机入座，求第 i 个乘客坐到自己座位的概率。
    - 解法：分情况讨论（金刚坐自己座位 / 他人座位），全概率公式推导。
    - 结论：乘客理性入座时概率为 (N-i+1)/(N-i+2)，随机入座时概率为 1/N。
    - 面试要素：概率推导、分治思想。
2. **瓷砖覆盖地板**：
    - 核心问题：1×2 瓷砖能否覆盖 N×M 地板，2×M 地板覆盖方式数。
    - 结论：N×M 需至少一个偶数；2×M 覆盖数符合斐波那契数列（F (M)=F (M-1)+F (M-2)）。
    - 面试要素：组合计数、递归关系推导。
3. **买票找零**：
    - 核心问题：2n 人排队购票（n 人持 50 元，n 人持 100 元），求不找零困难的排队方式数。
    - 解法：卡特兰数（C (n) = (1/(n+1))×C (2n,n)），对应合法括号排列。
    - 面试要素：组合数学、动态规划计数。
4. **三角形测试用例**：
    - 核心问题：设计测试用例覆盖三角形所有场景（等边 / 等腰 / 直角 / 钝角 / 非三角形）。
    - 解法：等价类划分（边长合法 / 非法、角度类型）、边界值测试（临界边长）。
    - 面试要素：测试思维、逻辑完备性。
5. **数独知多少**：
    - 核心问题：计算合法数独的数量，构造合法数独。
    - 解法：深度优先搜索 + 剪枝（利用数独规则减少无效尝试），构造时先填固定位置再扩展。
    - 面试要素：回溯算法、逻辑剪枝。

## 面试核心要素总结

1. **能力考察重点**：
    - 问题抽象：将实际场景（游戏 / 业务）转化为算法模型。
    - 优化意识：从暴力解法逐步优化（时间 / 空间复杂度权衡）。
    - 边界处理：空输入、极端值、多线程竞争等场景。
    - 数学思维：规律推导、概率 / 组合计数、位运算应用。
2. **高频算法 / 数据结构**：
    - 算法：动态规划、递归回溯、分治、贪心、BFS/DFS、位运算。
    - 数据结构：链表、二叉树、队列 / 栈、堆、哈希表。
3. **微软面试特色**：
    - 不考偏题怪题，侧重基础能力的灵活应用。
    - 重视思考过程，而非仅关注代码正确性。
    - 鼓励主动沟通，明确问题边界（如 “是否允许使用额外空间”）。

本书题目难度标注清晰（1-3 星），部分题目附带扩展问题（如多线程下载优化、环形数组最大和），建议结合 LeetCode 同类题目（如子数组最大和、二叉树重建）强化练习，重点掌握 “思路推导 + 代码优化” 的完整流程。