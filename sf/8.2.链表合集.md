[TOC]

### 基础操作类

#### 1. 链表的中间节点 → **LeetCode 876. Middle of the Linked List**

```c++
class Solution {
public:
   ListNode* middleNode(ListNode* head) {
       ListNode* slow = head;
       ListNode* fast = head;
       while (fast != NULL && fast->next != NULL) {
           slow = slow->next;
           fast = fast->next->next;
       }
       return slow;
   }
};
```

#### 2. 删除链表中的节点（只给待删节点） → **LeetCode 237. Delete Node in a Linked List**

```
class Solution {
public:
    void deleteNode(ListNode* node) {
        ListNode* cur = node;
        ListNode* next = node->next;
        cur->next = node->next->next;
        cur->val = next->val;
    }
};
```



### 反转链表系列

#### 1. 反转整个链表 → **LeetCode 206. Reverse Linked List**

   ```c++
   class Solution {
   public:
       ListNode* reverseList(ListNode* head) {
           if (!head)
               return nullptr;
           ListNode* pre = nullptr;
           ListNode* cur = head;
           while (cur)
           {
               auto next = cur->next;
               cur->next = pre;
               pre = cur;
               cur = next;
           }
           return pre;
       }
   };
   ```

#### 2. 反转链表的第 m 到 n 个节点 → **LeetCode 92. Reverse Linked List II**

   ```
   class Solution {
   public:
       ListNode* reverseBetween(ListNode* head, int left, int right) {
           if (!head)
               return nullptr;
           ListNode* dummy = new ListNode(-1);
           ListNode* pre = dummy;
           dummy->next = head;
   
           auto nl = left;
           for (int i = 0; i < nl - 1; i++)
               pre = pre->next;
           ListNode* leftNode = pre->next;
   
           auto count = right - left;
           ListNode* rightNode = leftNode;
   
           for (int i = 0; i < count; i++)
               rightNode = rightNode->next;
   
           ListNode* succ = rightNode->next;
   
           pre->next = nullptr;
           rightNode->next = nullptr;
   
           ListNode* pp = nullptr;
           ListNode* cur = leftNode;
           while (cur)
           {
               ListNode* next = cur->next;
               cur->next = pp;
               pp = cur;
               cur = next;
           }
   
           pre->next = rightNode;
           leftNode->next = succ;
           return dummy->next;
       }
   };
   ```

#### 3. 两两交换链表中的节点 → **LeetCode 24. Swap Nodes in Pairs**

   交换之前的节点关系是 `temp -> node1 -> node2`，交换之后的节点关系要变成 `temp -> node2 -> node1`

   ```
   class Solution {
   public:
       ListNode* swapPairs(ListNode* head) {
           if (!head)
               return nullptr;
           ListNode dummy(-1, head);
           ListNode* temp = &dummy;
           while (temp->next && temp->next->next)
           {
               ListNode* node1 = temp->next;
               ListNode* node2 = temp->next->next;
               temp->next = node2;
               node1->next = node2->next;
               node2->next = node1;
               temp = node1;
           }
           return dummy.next;
       }
   };
   ```

   

#### 4. K 个一组反转链表 → **LeetCode 25. Reverse Nodes in k-Group**

### 环相关问题

#### 1. 判断链表是否有环 → **LeetCode 141. Linked List Cycle**

   ```
   class Solution {
   public:
       bool hasCycle(ListNode *head) {
           if (!head)
               return false;
           ListNode* slow = head;
           ListNode* fast = head->next;
           while (fast && fast->next)
           {
               if (fast == slow)
                   return true;
               slow = slow->next;
               fast = fast->next->next;
           }
           return false;
       }
   };
   ```

#### 2. 找到环的入口点 → **LeetCode 142. Linked List Cycle II**

```
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        if (!head)
            return nullptr;
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast && fast->next)
        {
            slow = slow->next;
            fast = fast->next->next;
            if (slow == fast)
            {
                ListNode* ptr = head;
                while(ptr != slow)
                {
                    ptr = ptr->next;
                    slow = slow->next;
                }
                return ptr;
            }
        }
        return nullptr;
    }
};
```

```
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        unordered_set<ListNode *> visited;
        while (head != nullptr) {
            if (visited.count(head)) {
                return head;
            }
            visited.insert(head);
            head = head->next;
        }
        return nullptr;
    }
};

```



### 相交链表问题

#### 1. 找到两个相交链表的第一个节点 → **LeetCode 160. Intersection of Two Linked Lists**

   ```
   class Solution {
   public:
       ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
           if(!headA || !headB)
               return nullptr;
           auto ha = headA;
           unordered_set<ListNode*> hash;
           while (ha)
           {
               hash.insert(ha);
               ha = ha->next;
           }
           auto hb = headB;
           while (hb)
           {
               if (hash.count(hb))
                   return hb;
               hb = hb->next;
           }
           return nullptr;
       }
   };
   ```

   ```
   class Solution {
   public:
       ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
           if (!headA || !headB)
               return nullptr;
           ListNode* ha = headA;
           ListNode* hb = headB;
           while (ha != hb)
           {
               ha = (ha == nullptr) ? headB : ha->next;
               hb = (hb == nullptr) ? headA : hb->next;
           }
           return ha;
       }
   };
   ```

   

### 删除与去重

#### 1. 删除链表中值为 val 的所有节点 → **LeetCode 203. Remove Linked List Elements**

   ```
   class Solution {
   public:
       ListNode* removeElements(ListNode* head, int val) {
           if (!head)
               return nullptr;
   
           auto h = head;
           auto dummy = new ListNode(-1, head);
           auto p = dummy;
           while (h)
           {
               if (h->val == val)
               {
                   p->next = h->next;
                   h = h->next;
               }
               else
               {
                   p = p->next;
                   h = h->next;
               }
           }
           return dummy->next;
       }
   };
   ```

   

#### 2. 删除排序链表中的重复元素（保留一个） → **LeetCode 83. Remove Duplicates from Sorted List**

   ```
   class Solution {
   public:
       ListNode* deleteDuplicates(ListNode* head) {
           if (!head)
               return nullptr;
           unordered_set<int> hash;
           ListNode* h = head;
           ListNode* dummy = new ListNode(-1, head);
           ListNode* p = dummy;
           while (h)
           {
               if (hash.count(h->val) != 0)
               {
                   p->next = h->next;
                   h = h->next;
               }
               else
               {
                   hash.insert(h->val);
                   p = p->next;
                   h = h->next;
               }
           }
           return dummy->next;
       }
   };
   ```

   

#### 3. 删除排序链表中的重复元素（完全删除） → **LeetCode 82. Remove Duplicates from Sorted List II**

   ```
   class Solution {
   public:
       ListNode* deleteDuplicates(ListNode* head) {
           if (!head)
               return nullptr;
           ListNode* dummy = new ListNode(-1, head);
           ListNode* h = head;
           ListNode* p = dummy;
           while(h && h->next)
           {
               if (h->val == h->next->val)
               {
                   while (h && h->next && (h->val == h->next->val))
                   {
                       h = h->next;
                   }
                   p->next = h->next;
                   h = h->next;
               }
               else
               {
                   p = p->next;
                   h = h->next;
               }
           }
           return dummy->next;
       }
   };
   ```

   

### 合并与拆分

#### 1. 合并两个有序链表 → **LeetCode 21. Merge Two Sorted Lists**

   ```
   class Solution {
   public:
       ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
           if (!list1)
               return list2;
           if (!list2)
               return list1;
   
           ListNode* dummy = new ListNode(-1);
           ListNode* h = dummy;
           while (list1 && list2)
           {
               if (list1->val <= list2->val)
               {
                   h->next = list1;
                   h = h->next;
                   list1 = list1->next;
               }
               else
               {
                   h->next = list2;
                   h = h->next;
                   list2 = list2->next;
               }
           }
           if (list1)
           {
               h->next = list1;
           }
           if (list2)
           {
               h->next = list2;
           }
           return dummy->next;
       }
   };
   ```

   

#### 2. 合并 K 个有序链表 → **LeetCode 23. Merge k Sorted Lists**

   ```
   class Solution {
   public:
       ListNode* mergeKLists(vector<ListNode*>& lists) {
           if (lists.empty())
               return nullptr;
           priority_queue<ListNode*, vector<ListNode*>, std::function<bool(ListNode*, ListNode*)>> q([](ListNode* l, ListNode* r) -> bool {
               return l->val > r->val;
           });
           for (auto l : lists)
           {
               if (!l)
                   continue;
               q.push(l);
           }
           ListNode* dummy = new ListNode(-1);
           ListNode* h = dummy;
           while (!q.empty())
           {
               auto cur = q.top(); q.pop();
               h->next = cur;
               if (cur && cur->next)
                   q.push(cur->next);
               h = h->next;
           }
           return dummy->next;
       }
   };
   ```

   

#### 3. 按值拆分链表（小于 x 的放前面） → **LeetCode 86. Partition List**

   两个列表，小的放一个，大的放一个，最后连到一起

   ```
   class Solution {
   public:
       ListNode* partition(ListNode* head, int x) {
           if (!head)
               return nullptr;
           ListNode* smalldummy = new ListNode(-1);
           ListNode* largedummy = new ListNode(-1);
           ListNode* sp = smalldummy;
           ListNode* lp = largedummy;
           while(head)
           {
               if (head->val < x)
               {
                   sp->next = head;
                   sp = sp->next;
               }
               else
               {
                   lp->next = head;
                   lp = lp->next;
               }
               head = head->next;
           }
           lp->next = nullptr;
           sp->next = largedummy->next;
           return smalldummy->next;
       }
   };
   ```

   

#### 4. 奇偶拆分链表 → **LeetCode 328. Odd Even Linked List**

   ```
   class Solution {
   public:
       ListNode* oddEvenList(ListNode* head) {
           if(!head)
               return nullptr;
           ListNode* odummy = new ListNode(-1);
           ListNode* edummy = new ListNode(-1);
           auto op = odummy;
           auto ep = edummy;
           int idx = 1;
           while (head)
           {
               if (idx++ % 2)
               {
                   op->next = head;
                   op = op->next;
               }
               else
               {
                   ep->next = head;
                   ep = ep->next;
               }
               head = head->next;
           }
           ep->next = nullptr;
           op->next = edummy->next;
           return odummy->next;
       }
   };
   ```

   

### 其他高频题

#### 1. 回文链表判断 → **LeetCode 234. Palindrome Linked List**

   ```
   class Solution {
   public:
       bool isPalindrome(ListNode* head) {
           if (!head)
               return false;
           vector<int> lv;
           while (head)
           {
               lv.emplace_back(head->val);
               head = head->next;
           }
           auto len = lv.size();
           int l = 0;
           int r = len - 1;
           while (l < r)
           {
               if (lv[l++] != lv[r--])
               {
                   return false;
               }
           }
           return true;
       }
   };
   ```

   

#### 2. 链表求和（逆序存储） → **LeetCode 2. Add Two Numbers**

```
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode *head = nullptr, *tail = nullptr;
        int carry = 0;
        while (l1 || l2) {
            int n1 = l1 ? l1->val: 0;
            int n2 = l2 ? l2->val: 0;
            int sum = n1 + n2 + carry;
            if (!head) {
                head = tail = new ListNode(sum % 10);
            } else {
                tail->next = new ListNode(sum % 10);
                tail = tail->next;
            }
            carry = sum / 10;
            if (l1) {
                l1 = l1->next;
            }
            if (l2) {
                l2 = l2->next;
            }
        }
        if (carry > 0) {
            tail->next = new ListNode(carry);
        }
        return head;
    }
};
```



#### 1. 复制带随机指针的链表 → **LeetCode 138. Copy List with Random Pointer**