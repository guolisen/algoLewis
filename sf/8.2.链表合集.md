[TOC]

### 基础操作类

#### 1. 链表的中间节点 → **LeetCode 876. Middle of the Linked List**

```c++
class Solution {
public:
   ListNode* middleNode(ListNode* head) {
       ListNode* slow = head;
       ListNode* fast = head;
       while (fast != NULL && fast->next != NULL) {
           slow = slow->next;
           fast = fast->next->next;
       }
       return slow;
   }
};
```

#### 2. 删除链表中的节点（只给待删节点） → **LeetCode 237. Delete Node in a Linked List**

```
class Solution {
public:
    void deleteNode(ListNode* node) {
        ListNode* cur = node;
        ListNode* next = node->next;
        cur->next = node->next->next;
        cur->val = next->val;
    }
};
```

```
class ListNode:
    """定义双向链表节点类"""
    def __init__(self, value):
        self.value = value  # 节点值
        self.prev = None    # 前驱节点引用
        self.next = None    # 后继节点引用

    def __str__(self):
        """方便打印节点值"""
        return str(self.value)


class DoublyLinkedList:
    """双向链表类"""
    def __init__(self):
        self.head = None  # 头节点
        self.tail = None  # 尾节点
        self.size = 0     # 链表节点数

    def is_empty(self):
        """判断链表是否为空"""
        return self.size == 0

    def add_to_head(self, value):
        """头部插入节点"""
        new_node = ListNode(value)
        if self.is_empty():
            # 链表为空时，头、尾节点均为新节点
            self.head = new_node
            self.tail = new_node
        else:
            # 1. 新节点的 next 指向原头节点
            new_node.next = self.head
            # 2. 原头节点的 prev 指向新节点
            self.head.prev = new_node
            # 3. 头节点更新为新节点
            self.head = new_node
        self.size += 1

    def add_to_tail(self, value):
        """尾部插入节点"""
        new_node = ListNode(value)
        if self.is_empty():
            # 链表为空时，头、尾节点均为新节点
            self.head = new_node
            self.tail = new_node
        else:
            # 1. 新节点的 prev 指向原尾节点
            new_node.prev = self.tail
            # 2. 原尾节点的 next 指向新节点
            self.tail.next = new_node
            # 3. 尾节点更新为新节点
            self.tail = new_node
        self.size += 1

    def insert_after(self, target_node, value):
        """在指定节点后插入新节点（需确保 target_node 存在）"""
        if not target_node:
            raise ValueError("目标节点不能为空")
        new_node = ListNode(value)
        # 1. 新节点的 prev 指向目标节点
        new_node.prev = target_node
        # 2. 新节点的 next 指向目标节点的后继节点
        new_node.next = target_node.next
        # 3. 若目标节点是尾节点，更新尾节点为新节点
        if target_node == self.tail:
            self.tail = new_node
        else:
            # 否则，目标节点的后继节点的 prev 指向新节点
            target_node.next.prev = new_node
        # 4. 目标节点的 next 指向新节点
        target_node.next = new_node
        self.size += 1

    def remove_node(self, node):
        """删除指定节点（需确保 node 存在）"""
        if not node:
            raise ValueError("待删除节点不能为空")
        # 情况1：节点是头节点
        if node == self.head:
            self.head = node.next
            # 若删除后链表非空，新头节点的 prev 置空
            if self.head:
                self.head.prev = None
            else:
                # 若删除后链表为空，尾节点也置空
                self.tail = None
        # 情况2：节点是尾节点
        elif node == self.tail:
            self.tail = node.prev
            self.tail.next = None
        # 情况3：节点是中间节点
        else:
            node.prev.next = node.next
            node.next.prev = node.prev
        # 清空被删除节点的引用（便于垃圾回收）
        node.prev = None
        node.next = None
        self.size -= 1

    def remove_by_value(self, value):
        """删除第一个匹配指定值的节点"""
        current = self.head
        while current:
            if current.value == value:
                self.remove_node(current)
                return True  # 删除成功返回 True
            current = current.next
        return False  # 未找到节点返回 False

    def traverse_forward(self):
        """正向遍历链表（从头到尾）"""
        result = []
        current = self.head
        while current:
            result.append(current.value)
            current = current.next
        return result

    def traverse_backward(self):
        """反向遍历链表（从尾到头）"""
        result = []
        current = self.tail
        while current:
            result.append(current.value)
            current = current.prev
        return result


# ------------------- 测试代码 -------------------
if __name__ == "__main__":
    # 初始化链表
    dll = DoublyLinkedList()

    # 1. 尾部插入节点
    dll.add_to_tail(10)
    dll.add_to_tail(20)
    dll.add_to_tail(30)
    print("正向遍历（尾部插入后）:", dll.traverse_forward())  # [10, 20, 30]
    print("反向遍历（尾部插入后）:", dll.traverse_backward())  # [30, 20, 10]

    # 2. 头部插入节点
    dll.add_to_head(5)
    print("正向遍历（头部插入后）:", dll.traverse_forward())  # [5, 10, 20, 30]

    # 3. 在指定节点后插入（在 10 后插入 15）
    target = dll.head.next  # 10 节点
    dll.insert_after(target, 15)
    print("正向遍历（指定位置插入后）:", dll.traverse_forward())  # [5, 10, 15, 20, 30]

    # 4. 删除指定节点（删除 15 节点）
    node_to_remove = target.next  # 15 节点
    dll.remove_node(node_to_remove)
    print("正向遍历（删除指定节点后）:", dll.traverse_forward())  # [5, 10, 20, 30]

    # 5. 按值删除（删除 20）
    dll.remove_by_value(20)
    print("正向遍历（按值删除后）:", dll.traverse_forward())  # [5, 10, 30]
    print("链表当前大小:", dll.size)  # 3
```





### 反转链表系列

#### 1. 反转整个链表 → **LeetCode 206. Reverse Linked List**

   ```c++
   class Solution {
   public:
       ListNode* reverseList(ListNode* head) {
           if (!head)
               return nullptr;
           ListNode* pre = nullptr;
           ListNode* cur = head;
           while (cur)
           {
               auto next = cur->next;
               cur->next = pre;
               pre = cur;
               cur = next;
           }
           return pre;
       }
   };
   ```

#### 2. 反转链表的第 m 到 n 个节点 → **LeetCode 92. Reverse Linked List II**

获取四个值 pre, leftnode   --   rightnode, succ

   ```
   class Solution {
   public:
       ListNode* reverseBetween(ListNode* head, int left, int right) {
           if (!head)
               return nullptr;
           ListNode* dummy = new ListNode(-1);
           ListNode* pre = dummy;
           dummy->next = head;
   
           auto nl = left;
           for (int i = 0; i < nl - 1; i++)
               pre = pre->next;
           ListNode* leftNode = pre->next;
   
           auto count = right - left;
           ListNode* rightNode = leftNode;
   
           for (int i = 0; i < count; i++)
               rightNode = rightNode->next;
   
           ListNode* succ = rightNode->next;
   
           pre->next = nullptr;
           rightNode->next = nullptr;
   
           ListNode* pp = nullptr;
           ListNode* cur = leftNode;
           while (cur)
           {
               ListNode* next = cur->next;
               cur->next = pp;
               pp = cur;
               cur = next;
           }
   
           pre->next = rightNode;
           leftNode->next = succ;
           return dummy->next;
       }
   };
   ```

1. **定位反转区间**：找到反转的起点（`left` 位置）及其前驱节点，以便后续连接反转后的链表。
2. **局部反转**：反转从 `left` 到 `right` 的节点（共 `right-left+1` 个节点）。
3. **重新连接**：将反转后的链表与原链表的前后部分重新连接，确保链表结构完整。

```python
# 定义链表节点
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:
        # 虚拟头节点，简化边界处理（如 left=1 时无需特殊处理）
        dummy = ListNode(0)
        dummy.next = head
        
        # 1. 找到 left 的前驱节点（pre）
        pre = dummy
        for _ in range(left - 1):
            pre = pre.next  # 循环结束后，pre 指向 left 前一个节点
        
        # 2. 反转 left 到 right 的节点
        # cur 是反转区间的第一个节点（初始为 left 位置）
        cur = pre.next
        # 反转过程中，将当前节点的 next 指向其前一个节点
        for _ in range(right - left):
            next_node = cur.next  # 暂存 cur 的下一个节点
            cur.next = next_node.next  # cur 跳过 next_node，指向更后面的节点
            next_node.next = pre.next  # next_node 成为反转区间的新头部
            pre.next = next_node  # pre 指向新头部，完成一次局部反转
        
        return dummy.next
```

**就是将cur后面的node往pre后面插入**

1. 把cur.next的node先噶出来（next_node）

```
next_node = cur.next  # 暂存 cur 的下一个节点
cur.next = next_node.next  # cur 跳过 next_node，指向更后面的节点
```

2. 把next_node插入到pre后面

```
next_node.next = pre.next  # next_node 成为反转区间的新头部
pre.next = next_node  # pre 指向新头部，完成一次局部反转
```







以 `head = [1,2,3,4,5], left=2, right=4` 为例，步骤如下：

1. **初始化虚拟头节点**：`dummy -> 1 -> 2 -> 3 -> 4 -> 5`。

2. **定位 pre**：`left=2`，循环 1 次后，`pre` 指向节点 1（left 的前驱）。

3. **局部反转**（需反转 3 个节点，循环 `4-2=2` 次）：

    - 第 1 次循环：反转节点 3 到前面

        `cur=2   next_node=3`

        操作后链表：

        ```
        1 -> 3 -> 2 -> 4 -> 5
        ```

    - 第 2 次循环：反转节点 4 到前面

        `cur=2   next_node=4`

        操作后链表：
        ```
        1 -> 4 -> 3 -> 2 -> 5
        ```

4. **返回结果**：`dummy.next` 即为 `[1,4,3,2,5]`，符合预期。

![reverse2](./assets/reverse2.jpg)



- **虚拟头节点（dummy）**：避免处理 `left=1` 时的边界问题（此时无前驱节点）。
- **局部反转技巧**：通过调整指针，每次将 `cur` 的下一个节点 “插入” 到 `pre` 后面，实现反转（无需额外空间存储节点）。
- **时间复杂度**：O (n)（仅遍历链表一次），空间复杂度：O (1)（仅用常数个指针）。

#### 3. 两两交换链表中的节点 → **LeetCode 24. Swap Nodes in Pairs**

   交换之前的节点关系是 `temp -> node1 -> node2`，交换之后的节点关系要变成 `temp -> node2 -> node1`

   ```
   class Solution {
   public:
       ListNode* swapPairs(ListNode* head) {
           if (!head)
               return nullptr;
           ListNode dummy(-1, head);
           ListNode* temp = &dummy;
           while (temp->next && temp->next->next)
           {
               ListNode* node1 = temp->next;
               ListNode* node2 = temp->next->next;
               temp->next = node2;
               node1->next = node2->next;
               node2->next = node1;
               temp = node1;
           }
           return dummy.next;
       }
   };
   ```

   

#### 4. K 个一组反转链表 → **LeetCode 25. Reverse Nodes in k-Group**

```
class Solution {
public:
    tuple<ListNode*, ListNode*, ListNode*> reverse(ListNode* h, int k)
    {
        int count = 0;
        ListNode* ch = h;
        while (ch)
        {
            ch = ch->next;
            count++;
        }

        if (count < k)
            return {h, nullptr, nullptr};
        ListNode hn;
        ListNode* p = &hn;
        ListNode* tbak = h;
        ListNode* nhbak = nullptr;
        while (h && k)
        {
            ListNode* tmp = h->next;
            h->next = p->next;
            p->next = h;
            h = tmp;
            nhbak = tmp;
            k--;
        }
        return {hn.next, tbak, nhbak};
    }
    ListNode* reverseKGroup(ListNode *head, int k) {
        if (!head)
            return nullptr;
        ListNode hn;
        ListNode* p = &hn;

        while (head)
        {
            auto r = reverse(head, k);
            p->next = get<0>(r);
            p = get<1>(r);;
            head = get<2>(r);
        }

        return hn.next;
    }
};
```

```
class Solution:
    def reverse(self, h: ListNode, k: int) -> tuple:
        """
        分组反转核心函数：反转 h 开头的 k 个节点
        返回值：(反转后的组头节点, 反转后的组尾节点, 下一组的起始节点)
        """
        # 第一步：统计当前剩余节点数，不足 k 则直接返回原头
        count = 0
        ch = h
        while ch:
            ch = ch.next
            count += 1
        
        if count < k:
            return (h, None, None)
        
        # 第二步：反转 k 个节点（用哑节点辅助）
        dummy = ListNode(-1)  # 对应 C++ 的 ListNode hn（栈上节点）
        p = dummy           # 指针指向哑节点
        tbak = h         # 记录原组头（反转后成为组尾）
        nhbak = None     # 记录下一组的起始节点
        
        while h and k > 0:
            tmp = h.next       # 保存当前节点的下一个节点
            h.next = p.next    # 反转指针
            p.next = h         # 哑节点指向当前节点
            h = tmp            # 移动到下一个节点
            nhbak = tmp        # 更新下一组起始节点
            k -= 1
        
        # 返回：反转后的组头、组尾、下一组起始
        return (dummy.next, tbak, nhbak)
    
    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:
        if not head:
            return None
        
        hn = ListNode(-1)  # 结果链表的哑节点
        p = hn           # 指针指向结果哑节点，用于拼接各组
        
        while head:
            # 反转当前 k 个节点
            rev_head, rev_tail, next_head = self.reverse(head, k)
            # 拼接反转后的组到结果链表
            p.next = rev_head
            # 移动指针到当前组尾（准备拼接下一组）
            p = rev_tail if rev_tail else p
            # 移动到下一组起始节点
            head = next_head
        
        return hn.next
```



### 环相关问题

#### 1. 判断链表是否有环 → **LeetCode 141. Linked List Cycle**

   ```
   class Solution {
   public:
       bool hasCycle(ListNode *head) {
           if (!head)
               return false;
           ListNode* slow = head;
           ListNode* fast = head->next;
           while (fast && fast->next)
           {
               if (fast == slow)
                   return true;
               slow = slow->next;
               fast = fast->next->next;
           }
           return false;
       }
   };
   ```

#### 2. 找到环的入口点 → **LeetCode 142. Linked List Cycle II**

```
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        if (!head)
            return nullptr;
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast && fast->next)
        {
            slow = slow->next;
            fast = fast->next->next;
            if (slow == fast)
            {
                ListNode* ptr = head;
                while(ptr != slow)
                {
                    ptr = ptr->next;
                    slow = slow->next;
                }
                return ptr;
            }
        }
        return nullptr;
    }
};
```

```
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        unordered_set<ListNode *> visited;
        while (head != nullptr) {
            if (visited.count(head)) {
                return head;
            }
            visited.insert(head);
            head = head->next;
        }
        return nullptr;
    }
};

```



### 相交链表问题

#### 1. 找到两个相交链表的第一个节点 → **LeetCode 160. Intersection of Two Linked Lists**

   ```
   class Solution {
   public:
       ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
           if(!headA || !headB)
               return nullptr;
           auto ha = headA;
           unordered_set<ListNode*> hash;
           while (ha)
           {
               hash.insert(ha);
               ha = ha->next;
           }
           auto hb = headB;
           while (hb)
           {
               if (hash.count(hb))
                   return hb;
               hb = hb->next;
           }
           return nullptr;
       }
   };
   ```

   ```
   class Solution {
   public:
       ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
           if (!headA || !headB)
               return nullptr;
           ListNode* ha = headA;
           ListNode* hb = headB;
           while (ha != hb)
           {
               ha = (ha == nullptr) ? headB : ha->next;
               hb = (hb == nullptr) ? headA : hb->next;
           }
           return ha;
       }
   };
   ```

   

### 删除与去重

#### 1. 删除链表中值为 val 的所有节点 → **LeetCode 203. Remove Linked List Elements**

   ```
   class Solution {
   public:
       ListNode* removeElements(ListNode* head, int val) {
           if (!head)
               return nullptr;
   
           auto h = head;
           auto dummy = new ListNode(-1, head);
           auto p = dummy;
           while (h)
           {
               if (h->val == val)
               {
                   p->next = h->next;
                   h = h->next;
               }
               else
               {
                   p = p->next;
                   h = h->next;
               }
           }
           return dummy->next;
       }
   };
   ```

   

#### 2. 删除排序链表中的重复元素（保留一个） → **LeetCode 83. Remove Duplicates from Sorted List**

   ```
   class Solution {
   public:
       ListNode* deleteDuplicates(ListNode* head) {
           if (!head)
               return nullptr;
           unordered_set<int> hash;
           ListNode* h = head;
           ListNode* dummy = new ListNode(-1, head);
           ListNode* p = dummy;
           while (h)
           {
               if (hash.count(h->val) != 0)
               {
                   p->next = h->next;
                   h = h->next;
               }
               else
               {
                   hash.insert(h->val);
                   p = p->next;
                   h = h->next;
               }
           }
           return dummy->next;
       }
   };
   ```

   

#### 3. 删除排序链表中的重复元素（完全删除） → **LeetCode 82. Remove Duplicates from Sorted List II**

   ```
   class Solution {
   public:
       ListNode* deleteDuplicates(ListNode* head) {
           if (!head)
               return nullptr;
           ListNode* dummy = new ListNode(-1, head);
           ListNode* h = head;
           ListNode* p = dummy;
           while(h && h->next)
           {
               if (h->val == h->next->val)
               {
                   while (h && h->next && (h->val == h->next->val))
                   {
                       h = h->next;
                   }
                   p->next = h->next;
                   h = h->next;
               }
               else
               {
                   p = p->next;
                   h = h->next;
               }
           }
           return dummy->next;
       }
   };
   ```

   

```python
# 定义链表节点
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        # 虚拟头节点，避免头节点被删除的边界问题
        dummy = ListNode(0)
        dummy.next = head
        
        pre = dummy  # pre 指向已确认无重复的最后一个节点
        cur = head   # 当前遍历的节点
        
        while cur and cur.next:
            if cur.val == cur.next.val:
                # 记录重复值，将 cur 移到所有重复节点的最后
                dup_val = cur.val
                while cur and cur.val == dup_val:
                    cur = cur.next
                # pre 跳过所有重复节点（指向 cur，即下一个可能无重复的节点）
                pre.next = cur
            else:
                # 无重复，pre 和 cur 都后移
                pre = cur
                cur = cur.next
        
        return dummy.next
```

以 `head = [1,2,3,3,4,4,5]` 为例：

1. 初始化：`dummy -> 1 -> 2 -> 3 -> 3 -> 4 -> 4 -> 5`，`pre = dummy`，`cur = 1`。

2. `cur.val (1) != cur.next.val (2)`：`pre` 移到 1，`cur` 移到 2。

3. `cur.val (2) != cur.next.val (3)`：`pre` 移到 2，`cur` 移到 3。

4. `cur.val (3) == cur.next.val (3)`：

    - 记录重复值 `3`，`cur` 移到第一个非 3 的节点（4）。
    - `pre.next = cur`（此时 `pre` 仍在 2，链表变为 `2 -> 4 -> 4 -> 5`）。

5. `cur.val (4) == cur.next.val (4)`：

    - 记录重复值 `4`，`cur` 移到 5。
    - `pre.next = cur`（链表变为 `2 -> 5`）。

6. 遍历结束，最终结果为 `[1,2,5]`。

    

** 虚拟头节点  **

：确保即使头节点是重复节点（如 `[1,1,2]`），也能正确处理。

 跳过重复节点 

：通过内层循环将 `cur` 移到重复序列的末尾，再用 `pre.next = cur` 直接跳过整个重复序列。

 时间复杂度 **：O (n)（仅遍历链表一次），** 空间复杂度 **：O (1)（仅用常数个指针）。



### 合并与拆分

#### 1. 合并两个有序链表 → **LeetCode 21. Merge Two Sorted Lists**

   ```
   class Solution {
   public:
       ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
           if (!list1)
               return list2;
           if (!list2)
               return list1;
   
           ListNode* dummy = new ListNode(-1);
           ListNode* h = dummy;
           while (list1 && list2)
           {
               if (list1->val <= list2->val)
               {
                   h->next = list1;
                   h = h->next;
                   list1 = list1->next;
               }
               else
               {
                   h->next = list2;
                   h = h->next;
                   list2 = list2->next;
               }
           }
           if (list1)
           {
               h->next = list1;
           }
           if (list2)
           {
               h->next = list2;
           }
           return dummy->next;
       }
   };
   ```

   ![e](./assets/2025-12-05_20-43-04.png)
```
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if (l1 == nullptr) {
            return l2;
        } else if (l2 == nullptr) {
            return l1;
        } else if (l1->val < l2->val) {
            l1->next = mergeTwoLists(l1->next, l2);
            return l1;
        } else {
            l2->next = mergeTwoLists(l1, l2->next);
            return l2;
        }
    }
```

#### 2. 合并 K 个有序链表 → **LeetCode 23. Merge k Sorted Lists**

   ```
   class Solution {
   public:
       ListNode* mergeKLists(vector<ListNode*>& lists) {
           if (lists.empty())
               return nullptr;
           priority_queue<ListNode*, vector<ListNode*>, std::function<bool(ListNode*, ListNode*)>> q([](ListNode* l, ListNode* r) -> bool {
               return l->val > r->val;
           });
           for (auto l : lists)
           {
               if (!l)
                   continue;
               q.push(l);
           }
           ListNode* dummy = new ListNode(-1);
           ListNode* h = dummy;
           while (!q.empty())
           {
               auto cur = q.top(); q.pop();
               h->next = cur;
               if (cur && cur->next)
                   q.push(cur->next);
               h = h->next;
           }
           return dummy->next;
       }
   };
   ```

   ```
   class Solution {
   public:
       struct cmd
       {
           bool operator()(const ListNode* a, const ListNode* b)
           {
               return a->val > b->val;
           }
       };
       ListNode *mergeKLists(vector<ListNode *> &lists) {
           priority_queue<ListNode*, vector<ListNode*>, cmd> q;
           int m = lists.size();
           for (int i = 0; i < m; i++)
           {
               if (lists[i])
               {
                   q.push(lists[i]);
               }
           }
   
           auto dummy = ListNode(-1);
           auto p = &dummy;
           while(!q.empty())
           {
               auto cur = q.top(); q.pop();
               p->next = cur;
               p = p->next;
               if (cur->next)
               {
                   q.push(cur->next);
               }
           }
   
           return dummy.next;
       }
   };
   
   
   ```



#### 3. 按值拆分链表（小于 x 的放前面） → **LeetCode 86. Partition List**

   两个列表，小的放一个，大的放一个，最后连到一起

   ```
   class Solution {
   public:
       ListNode* partition(ListNode* head, int x) {
           if (!head)
               return nullptr;
           ListNode* smalldummy = new ListNode(-1);
           ListNode* largedummy = new ListNode(-1);
           ListNode* sp = smalldummy;
           ListNode* lp = largedummy;
           while(head)
           {
               if (head->val < x)
               {
                   sp->next = head;
                   sp = sp->next;
               }
               else
               {
                   lp->next = head;
                   lp = lp->next;
               }
               head = head->next;
           }
           lp->next = nullptr;
           sp->next = largedummy->next;
           return smalldummy->next;
       }
   };
   ```

   

#### 4. 奇偶拆分链表 → **LeetCode 328. Odd Even Linked List**

   ```
   class Solution {
   public:
       ListNode* oddEvenList(ListNode* head) {
           if(!head)
               return nullptr;
           ListNode* odummy = new ListNode(-1);
           ListNode* edummy = new ListNode(-1);
           auto op = odummy;
           auto ep = edummy;
           int idx = 1;
           while (head)
           {
               if (idx++ % 2)
               {
                   op->next = head;
                   op = op->next;
               }
               else
               {
                   ep->next = head;
                   ep = ep->next;
               }
               head = head->next;
           }
           ep->next = nullptr;
           op->next = edummy->next;
           return odummy->next;
       }
   };
   ```

   

### 其他高频题

#### 1. 回文链表判断 → **LeetCode 234. Palindrome Linked List**

   ```
   class Solution {
   public:
       bool isPalindrome(ListNode* head) {
           if (!head)
               return false;
           vector<int> lv;
           while (head)
           {
               lv.emplace_back(head->val);
               head = head->next;
           }
           auto len = lv.size();
           int l = 0;
           int r = len - 1;
           while (l < r)
           {
               if (lv[l++] != lv[r--])
               {
                   return false;
               }
           }
           return true;
       }
   };
   ```

   

#### 2. 链表求和（逆序存储） → **LeetCode 2. Add Two Numbers**

```
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode *head = nullptr, *tail = nullptr;
        int carry = 0;
        while (l1 || l2) {
            int n1 = l1 ? l1->val: 0;
            int n2 = l2 ? l2->val: 0;
            int sum = n1 + n2 + carry;
            if (!head) {
                head = tail = new ListNode(sum % 10);
            } else {
                tail->next = new ListNode(sum % 10);
                tail = tail->next;
            }
            carry = sum / 10;
            if (l1) {
                l1 = l1->next;
            }
            if (l2) {
                l2 = l2->next;
            }
        }
        if (carry > 0) {
            tail->next = new ListNode(carry);
        }
        return head;
    }
};
```

```
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        # 虚拟头节点，简化结果链表的构建
        dummy = ListNode(0)
        current = dummy  # 当前节点指针，用于构建结果链表
        carry = 0        # 进位
        
        # 遍历两个链表，直到两个链表都遍历完且无进位
        while l1 or l2 or carry:
            # 获取当前位的数值（若链表已遍历完，视为 0）
            val1 = l1.val if l1 else 0
            val2 = l2.val if l2 else 0
            
            # 计算当前位的总和（包含进位）
            total = val1 + val2 + carry
            # 计算当前位的结果和新的进位
            current_val = total % 10
            carry = total // 10
            
            # 创建新节点，加入结果链表
            current.next = ListNode(current_val)
            current = current.next  # 移动指针
            
            # 移动两个链表的指针（若未遍历完）
            if l1:
                l1 = l1.next
            if l2:
                l2 = l2.next
        
        return dummy.next  # 虚拟头节点的下一个节点是结果的头节点
```



#### 1. 复制带随机指针的链表 → **LeetCode 138. Copy List with Random Pointer**

```
    def copyRandomList(self, head):
        h = collections.defaultdict(RandomListNode)
        arr = []
        p = head
        while p != None:
            h[p] = RandomListNode(p.label)
            arr.append(p)
            p = p.next
        
        for i in range(len(arr) - 1):
            h[arr[i]].next = h[arr[i + 1]]
            if arr[i].random in h:
                h[arr[i]].random = h[arr[i].random]
        h[arr[len(arr) - 1]].next = None
        if arr[len(arr) - 1].random in h:
            h[arr[len(arr) - 1]].random = h[arr[len(arr) - 1].random]
        return h[arr[0]]
```

