[TOC]



### 一、双指针（Two Pointers）

**核心场景**：数组 / 链表的遍历、有序序列操作、快慢指针（环检测）、左右指针（二分思想）。**模板要点**：通过两个指针同向 / 反向移动，减少嵌套循环，优化时间复杂度。

#### * 1. 两数之和 II - 输入有序数组 → **LeetCode 167. Two Sum II - Input Array Is Sorted**（左右指针）

```
    def two_sum(self, nums: List[int], target: int) -> List[int]:
        l = 0
        r = len(nums) - 1
        while l < r:
            s = nums[l] + nums[r]
            if s == target:
                return [l + 1, r + 1]
            elif s > target:
                r -= 1
            else:
                l += 1
        return []
```



#### * 2. 反转字符串 → **LeetCode 344. Reverse String**（左右指针交换）

```
    def reverse_words(self, s: str) -> str:
        wl = s.split()
        l = 0
        r = len(wl) - 1
        while l < r:
            wl[l],wl[r] = wl[r],wl[l]
            l += 1
            r -= 1
        return " ".join(wl)
```



#### * 3. 有效的回文 → **LeetCode 125. Valid Palindrome**（左右指针校验）

```
    def is_palindrome(self, s: str) -> bool:
        posts = [c.lower() if c.isalnum() else "" for c in s ]
        pstr = "".join(posts)
        l = 0
        r = len(pstr) - 1
        while l < r:
            if pstr[l] != pstr[r]:
                return False
            l += 1
            r -= 1
        return True
```

```
    def is_palindrome(self, s: str) -> bool:
        strgood = [ch.lower() for ch in s if ch.isalnum()]
        return strgood == strgood[::-1]
```



#### * 4. 移除元素 → **LeetCode 27. Remove Element**（快慢指针）

```
    def removeElement(self, A, elem):
        l = 0
        r = len(A) - 1
        while l <= r:
            if A[l] == elem:
                A[l] = A[r]
                r -= 1
            else:
                l += 1
        return r + 1
```



#### 5. 有序数组的平方 → **LeetCode 977. Squares of a Sorted Array**（左右指针合并）

```
    vector<int> squareArray(vector<int> &a) {
        priority_queue<int, vector<int>, greater<int>> p;
        for (auto c : a)
        {
            p.push(c * c);
        }
        vector<int> res;
        while(!p.empty())
        {
            res.push_back(p.top()); p.pop();
        }
        return res;
    }
```



#### 6. 环形链表 → **LeetCode 141. Linked List Cycle**（快慢指针）
#### 7. 相交链表 → **LeetCode 160. Intersection of Two Linked Lists**（双指针对齐长度）
#### * 8. 三数之和 → **LeetCode 15. 3Sum**（排序 + 固定指针 + 左右指针）

```
    def three_sum(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()
        for i in range(len(nums) - 2):
            l = i + 1
            r = len(nums) - 1
            while l < r:
                s = nums[i] + nums[l] + nums[r]
                if s == 0: 
                    if [nums[i], nums[l], nums[r]] not in res:
                        res.append([nums[i], nums[l], nums[r]])
                    l += 1
                elif s > 0:
                    r -= 1
                else:
                    l += 1
        return res
```



### 二、前缀和（Prefix Sum）

**核心场景**：快速计算子数组和、区间和相关问题，避免重复计算。**模板要点**：预处理前缀和数组 `prefix[i] = sum(nums[0..i-1])`，则区间和 `sum(i..j) = prefix[j+1] - prefix[i]`。

#### * 1. 区域和检索 - 数组不可变 → **LeetCode 303. Range Sum Query - Immutable**（基础前缀和）

一维前缀和，二维前缀和

```
class NumMatrix:
    sc = None
    def __init__(self, matrix):
        m = len(matrix)
        n = len(matrix[0])
        self.sc = [[0] * (n + 1) for _ in range(m)]
        for i in range(m):
            for j in range(1, n + 1):
                self.sc[i][j] = self.sc[i][j - 1] + matrix[i][j - 1]
        

    """
    @param: row1: An integer
    @param: col1: An integer
    @param: row2: An integer
    @param: col2: An integer
    @return: An integer
    """
    def sumRegion(self, row1, col1, row2, col2):
        res = 0
        for row in range(row1, row2 + 1):
            res += self.sc[row][col2 + 1] - self.sc[row][col1]
        return res
```



#### * 2. 和为 K 的子数组 → **LeetCode 560. Subarray Sum Equals K**（前缀和 + 哈希表优化）

记录一边的sum，并hash，找另一边的hash对应值

```
    def subarray_sum_equals_k(self, nums: List[int], k: int) -> int:
        s = [0 for _ in range(len(nums) + 1)]
        for i in range(1, len(nums) + 1):
            s[i] = s[i - 1] + nums[i - 1]
        
        res = 0
        h = collections.defaultdict(int)
        for i in range(len(nums) + 1):   #0开始，所用与s[i]
            sm = s[i]
            res += h[sm - k]
            h[sm] += 1
        return res
```



#### 3. 连续的子数组和 → **LeetCode 523. Continuous Subarray Sum**（前缀和 + 取模）
#### 4. 二维区域和检索 - 矩阵不可变 → **LeetCode 304. Range Sum Query 2D - Immutable**（二维前缀和）
#### * 5. 除自身以外数组的乘积 → **LeetCode 238. Product of Array Except Self**（前缀积 + 后缀积）

### 三、滑动窗口（Sliding Window）

**核心场景**：子串 / 子数组的连续区间问题（长度固定 / 可变）。**模板要点**：用左右指针维护窗口，右指针扩展、左指针收缩，动态更新窗口状态。

#### * 1. 无重复字符的最长子串 → **LeetCode 3. Longest Substring Without Repeating Characters**（最长可变窗口）

同向双指针

```
    def length_of_longest_substring(self, s: str) -> int:
        h = collections.defaultdict(int)
        j = 0
        res = ""
        for i in range(len(s)):
            while j < len(s) and h[s[j]] == 0:
                h[s[j]] += 1
                j += 1
            if j - i + 1 > len(res):
                res = s[i:j]
            h[s[i]] -= 1
        return len(res)
```



#### * 2. 最小覆盖子串 → **LeetCode 76. Minimum Window Substring**（最短可变窗口）
#### * 3. 找到字符串中所有字母异位词 → **LeetCode 438. Find All Anagrams in a String**（固定长度窗口）

```
class Solution: 
    def find_anagrams(self, s: str, p: str) -> List[int]:
        h = collections.defaultdict(int)
        
        for i in range(len(p)):
            h[p[i]] += 1

        l = 0
        r = 0
        match = 0
        res = []
        while r < len(s):
            if h[s[r]] > 0:
                match += 1
            h[s[r]] -= 1

            if match == len(p):
                res.append(l)

            if r - l + 1 == len(p):
                if h[s[l]] >= 0:
                    match -= 1
                h[s[l]] += 1
                l += 1
            r += 1
        return res
```



#### 4. 定长子串中元音的最大数目 → **LeetCode 1456. Maximum Number of Vowels in a Substring of Given Length**（固定窗口）
#### 5. 滑动窗口最大值 → **LeetCode 239. Sliding Window Maximum**（结合单调队列）

### 四、单调栈 / 队列（Monotonic Stack/Queue）

**核心场景**：找下一个更大 / 更小元素、维持区间极值、滑动窗口最值。**模板要点**：栈 / 队列内元素保持单调递增 / 递减，通过弹出 “无效元素” 维护单调性。

#### 单调栈

#### * 1. 下一个更大元素 I → **LeetCode 496. Next Greater Element I**（基础单调栈）

先从后向前遍历nums2, 将nums2中的每个数字，计算他的右边第一个最大值，用单调递增栈。

3， 2， 1， 5

3左边的数字，对应的第一个最大值不可能小于3，因此比3小的2，1出栈

```
    def next_greater_element(self, nums1: List[int], nums2: List[int]) -> List[int]:
        stack = []
        res = {}
        for n in reversed(nums2):
            while len(stack) > 0 and stack[-1] < n:
                stack.pop()
            res[n] = stack[-1] if len(stack) > 0 else -1
            stack.append(n)
        ret = [res[n] for n in nums1]
        return ret
```



#### * 2. 每日温度 → **LeetCode 739. Daily Temperatures**（找下一个更大元素的距离）

1. pop() 2. save 3. push()

```
class Solution:
    def daily_temperatures(self, temp: List[int]) -> List[int]:
        stack = []
        res = collections.defaultdict(int)
        for i in range(len(temp) - 1, -1, -1):
            while len(stack) > 0 and stack[-1][0] <= temp[i]:
                stack.pop()
            if len(stack) > 0:
                res[(temp[i], i)] = stack[-1]
            else:
                res[(temp[i], i)] = -1
            stack.append((temp[i], i))
        ret = []
        for k, v in res.items():
            if v == -1:
                ret.append(0)
            else:
                ret.append(v[1] - k[1])
        return list(reversed(ret))
```



#### 3. 接雨水 → **LeetCode 42. Trapping Rain Water**（单调栈求凹槽面积）

1. 当前比栈顶大，pop栈顶到cur
2. 当前栈顶stack[-1], cur, heights[i] 组成水槽的高
3. 宽度为当前i和当前stack[-1]的距离

```
    def trap_rain_water(self, heights: List[int]) -> int:
        stack = []
        res = 0
        for i in range(len(heights)):
            cur = -1
            while len(stack) > 0 and heights[stack[-1]] < heights[i]:
                cur = stack.pop()
                if len(stack) == 0:
                    break
                h =  min(heights[stack[-1]], heights[i]) - heights[cur]
                w = i - stack[-1] - 1
                res += h * w
            stack.append(i)
        return res
```



#### 4. 柱状图中最大的矩形 → **LeetCode 84. Largest Rectangle in Histogram**（单调栈找左右边界）

#### 单调队列

#### * 1. 滑动窗口最大值 → **LeetCode 239. Sliding Window Maximum**（队列存索引，维持最大值在队首）
#### 2. 队列的最大值 → **LeetCode 59. II. Maximum Value in a Queue**（剑指 Offer，单调队列辅助）

### 五、二分查找（Binary Search）

**核心场景**：有序数组 / 区间的查找、满足条件的最值问题（二分答案）。**模板要点**：明确 “搜索区间”（左闭右闭 / 左闭右开），根据条件收缩左右边界。

#### * 1. 二分查找 → **LeetCode 704. Binary Search**（基础模板）

```
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int m = nums.size();
        int l = 0;
        int r = m - 1;
        while (l < r)
        {
            int mid = (l + r) / 2;
            if (nums[mid] >= target)
            {
                r = mid;
            }
            else
            {
                l = mid + 1;
            }
        }
        if (nums[l] == target)
            return l;
        return -1;
    }
};
```



#### 2. 搜索插入位置 → **LeetCode 35. Search Insert Position**（找插入点）
#### * 3. 在排序数组中查找元素的第一个和最后一个位置 → **LeetCode 34. Find First and Last Position of Element in Sorted Array**（左右边界查找）

```
class Solution {
public:
    vector<int> searchRange(vector<int> &nums, int target) {
        if (nums.empty())
            return {-1, -1};
        int len = nums.size();
        int l = 0;
        int r = len - 1;
        vector<int> res;
        while (l < r)
        {
            int mid = (l + r) / 2;
            if (nums[mid] >= target)
                r = mid;
            else
                l = mid + 1;
        }

        if (nums[l] != target)
            return {-1, -1};
        res.push_back(l);
        l = 0;
        r = len - 1;
        while (l < r)
        {
            int mid = (l + r + 1) / 2;
            if (nums[mid] <= target)
                l = mid;
            else
                r = mid - 1;
        }
        res.push_back(l);

        return res;
    }
};
```



#### * 4. 搜索旋转排序数组 → **LeetCode 33. Search in Rotated Sorted Array**（旋转数组查找）

```
class Solution {
public:
    /**
     * @param a: an integer rotated sorted array
     * @param target: an integer to be searched
     * @return: an integer
     */
    bool check(vector<int>& a, int target, int l, int r, int mid)
    {
        if(a[l] <= a[mid])
        {
            if (a[l] <= target && target <= a[mid])
                return true;
            else
                return false;
        }
        else
        {
            if (a[mid] < target && target < a[r])
                return false;
            else
                return true;
        }
    }
    int search(vector<int> &a, int target) {
        if (a.empty())
            return -1;
        int m = a.size();
        int l = 0;
        int r = m - 1;
        while (l < r)
        {
            int mid = (l + r) / 2;
            if (check(a, target, l, r, mid))
            {
                r = mid;
            }
            else
            {
                l = mid + 1;
            }
        }
        if (a[l] == target)
            return l;
        return -1;
    }
};
```

#### 159 · Find Minimum in Rotated Sorted Array

```
class Solution:
    def find_min(self, nums: List[int]) -> int:
        m = len(nums)
        if nums[0] < nums[m - 1]:
            return nums[0]
        l = 0 
        r = m - 1
        while l < r:
            mid = (l + r) // 2
            if nums[mid] < nums[0]:
                r = mid
            else:
                l = mid + 1
        return nums[l]
```




#### 5. 寻找峰值 → **LeetCode 162. Find Peak Element**（局部有序查找）
#### * 6. 平方根 → **LeetCode 69. Sqrt(x)**（二分答案）
#### 7. 爱吃香蕉的珂珂 → **LeetCode 875. Koko Eating Bananas**（二分答案 + 条件判断）

### 六、并查集（Union-Find/Disjoint Set）

**核心场景**：处理连通性问题（动态连接、判断是否连通）、分组问题。**模板要点**：父节点数组 + 路径压缩 + 按秩合并，实现高效的 `find` 和 `union` 操作。

#### * 1. 省份数量 → **LeetCode 547. Number of Provinces**（连通分量计数）

```
class Solution {
public:
    int find(int x, unordered_map<int, int>& p)
    {
        if (x != p[x]) p[x] = find(p[x], p);
        return p[x];
    }
    int findCircleNum(vector<vector<int>>& isConnected) {
        int m = isConnected.size();
        unordered_map<int, int> p;
        for (int i = 0; i < m; i++)
        {
            p[i] = i;
        }

        for (int i = 0; i < m; i++)
        {
            for (int j = i + 1; j < m; j ++)
            {
                if (isConnected[i][j] == 1)
                    p[find(i, p)] = find(j, p);
            }
        }
        unordered_set<int> h;
        for (int i = 0; i < m; i++)
        {
            h.insert(find(i, p));
        }
        return h.size();
    }
};
```



#### * 2. 岛屿数量 → **LeetCode 200. Number of Islands**（并查集解法，替代 DFS/BFS）
#### * 3. 冗余连接 → **LeetCode 684. Redundant Connection**（找环并移除）

```
class Solution:
    def find(self, x, p):
        if p[x] != x:
            p[x] = self.find(p[x], p)
        return p[x]
    def find_redundant_connection(self, edges: List[List[int]]) -> List[int]:
        p = collections.defaultdict(int)
        n = len(edges)
        for i in range(n):
            p[i] = i
        for e in edges:
            if self.find(e[0], p) != self.find(e[1], p):
                 p[self.find(e[0], p)] = self.find(e[1], p)
            else:
                return e
        return None
```



#### 4. 朋友圈 → **LeetCode 547. Number of Provinces**（同省份数量）
#### 5. 情侣牵手 → **LeetCode 765. Couples Holding Hands**（连通分量与交换次数）
#### 6. 区间列表的交集 → **LeetCode 986. Interval List Intersections**（区间合并的并查集应用）

### 七、记忆化搜索（Memoization）

**核心场景**：递归问题中避免重复计算（如斐波那契、路径计数），本质是动态规划的递归实现。**模板要点**：用哈希表 / 数组缓存已计算的子问题结果，递归时先查缓存。

#### 1. 斐波那契数 → **LeetCode 509. Fibonacci Number**（基础记忆化）
#### * 2. 爬楼梯 → **LeetCode 70. Climbing Stairs**
#### * 3. 不同路径 → **LeetCode 62. Unique Paths**
#### 4. 最长递增子序列 → **LeetCode 300. Longest Increasing Subsequence**（记忆化 + 递归）
#### 5. 目标和 → **LeetCode 494. Target Sum**（记忆化优化递归）
#### * 6. 打家劫舍 III → **LeetCode 337. House Robber III**（树的记忆化搜索）

### 八、Trie 树（前缀树）

**核心场景**：字符串前缀匹配、字典搜索、单词频率统计。**模板要点**：节点包含字符数组（或哈希表）和结束标记，支持插入、查找、前缀匹配操作。

#### * 1. 实现 Trie (前缀树) → **LeetCode 208. Implement Trie (Prefix Tree)**（基础实现）
#### * 2. 单词搜索 II → **LeetCode 212. Word Search II**（Trie+DFS 优化）
#### 3. 前缀和后缀搜索 → **LeetCode 745. Prefix and Suffix Search**（双向 Trie）
#### 4. 键值映射 → **LeetCode 677. Map Sum Pairs**（Trie 存储前缀和）

### 九、扫描线（Sweep Line）

**核心场景**：区间重叠问题、事件调度、计算最大重叠区间数。**模板要点**：将区间端点转化为 “事件”（开始 / 结束），按坐标排序后扫描处理。

#### * 1. 会议室 II → **LeetCode 253. Meeting Rooms II**（求最少会议室数量）
#### * 2. 合并区间 → **LeetCode 56. Merge Intervals**（扫描线排序合并）
#### 3. 区间列表的交集 → **LeetCode 986. Interval List Intersections**
#### 4. 天际线问题 → **LeetCode 218. The Skyline Problem**（困难，扫描线 + 优先队列）

### 十、补充题型：动态规划（Dynamic Programming）

**核心场景**：最优子结构 + 重叠子问题（如路径、背包、序列问题），与记忆化搜索互补。**模板要点**：定义状态转移方程，用数组存储子问题结果，自底向上计算。

#### * 1. 最长回文子串 → **LeetCode 5. Longest Palindromic Substring**（区间 DP）
#### * 2. 编辑距离 → **LeetCode 72. Edit Distance**（经典 DP）
#### 3. 最长公共子序列 → **LeetCode 1143. Longest Common Subsequence**
#### * 4. 零钱兑换 → **LeetCode 322. Coin Change**（完全背包）
#### 5. 最长递增子序列 → **LeetCode 300. Longest Increasing Subsequence**