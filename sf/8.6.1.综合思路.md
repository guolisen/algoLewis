[TOC]

### 一、双指针（Two Pointers）

1. **LeetCode 167. Two Sum II - Input Array Is Sorted（两数之和 II - 输入有序数组）**
    - **题目描述**：给定一个按非递减顺序排序的整数数组 `numbers` 和目标值 `target`，找出两个数，使它们的和等于 `target`，返回这两个数的索引（索引从 1 开始）。
    - **示例**：`numbers = [2,7,11,15]`，`target = 9`，输出 `[1,2]`（2+7=9）。
    - 思路：左右指针分别从数组首尾出发，和小于目标则左指针右移，大于则右指针左移，等于则返回。
2. **LeetCode 344. Reverse String（反转字符串）**
    - **题目描述**：给定一个字符数组 `s`，原地反转该数组（不使用额外空间）。
    - **示例**：`s = ["h","e","l","l","o"]`，反转后为 `["o","l","l","e","h"]`。
    - 思路：左右指针交换字符，向中间移动，直到相遇。
3. **LeetCode 125. Valid Palindrome（有效的回文）**
    - **题目描述**：给定字符串 `s`，判断其是否为回文串（只考虑字母和数字，忽略大小写）。
    - **示例**：`s = "A man, a plan, a canal: Panama"` 是回文串，输出 `true`；`s = "race a car"` 不是，输出 `false`。
    - 思路：左右指针跳过非字母数字字符，比较字符是否相等，忽略大小写。
4. **LeetCode 27. Remove Element（移除元素）**
    - **题目描述**：给定数组 `nums` 和值 `val`，原地移除所有等于 `val` 的元素，返回移除后数组的新长度（元素顺序可改变）。
    - **示例**：`nums = [3,2,2,3]`，`val = 3`，返回长度 2（数组变为 `[2,2,...]`）。
    - 思路：快慢指针，快指针遍历数组，慢指针记录非目标值的位置，将快指针元素复制到慢指针位置。
5. **LeetCode 977. Squares of a Sorted Array（有序数组的平方）**
    - **题目描述**：给定按非递减顺序排序的整数数组 `nums`，返回每个元素的平方组成的新数组，要求也按非递减顺序排序。
    - **示例**：`nums = [-4,-1,0,3,10]`，输出 `[0,1,9,16,100]`。
    - 思路：左右指针分别指向首尾，比较平方值大小，将较大值放入结果数组末尾。
6. **LeetCode 141. Linked List Cycle（环形链表）**
    - **题目描述**：给定链表的头节点 `head`，判断链表中是否有环（即是否存在节点可通过连续遍历再次到达）。
    - **示例**：有环链表返回 `true`，无环返回 `false`。
    - 思路：快慢指针，快指针每次走 2 步，慢指针走 1 步，若相遇则有环。
7. **LeetCode 160. Intersection of Two Linked Lists（相交链表）**
    - **题目描述**：给定两个链表 `headA` 和 `headB`，找出它们的相交节点（若不相交，返回 `null`）。
    - **示例**：两链表在节点值为 8 的位置相交，返回该节点。
    - 思路：双指针对齐长度，两个指针分别遍历两个链表，到末尾后交换链表继续遍历，相遇点即为相交节点。
8. **LeetCode 15. 3Sum（三数之和）**
    - **题目描述**：给定整数数组 `nums`，找出所有和为 0 的三元组 `[nums[i], nums[j], nums[k]]`（`i≠j≠k`，结果需去重）。
    - **示例**：`nums = [-1,0,1,2,-1,-4]`，输出 `[[-1,-1,2],[-1,0,1]]`。
    - 思路：排序后，固定第一个数，左右指针找剩下两个数的和为目标值，注意去重（相同数跳过）。

### 二、前缀和（Prefix Sum）

1. **LeetCode 303. Range Sum Query - Immutable（区域和检索 - 数组不可变）**
    - **题目描述**：给定整数数组 `nums`，实现一个类，支持查询数组中 `[left, right]` 区间的元素和（多次查询）。
    - **示例**：`nums = [-2, 0, 3, -5, 2, -1]`，查询 `[0,2]` 返回 1（-2+0+3），查询 `[2,5]` 返回 -1（3-5+2-1）。
    - 思路：预处理前缀和数组 `prefixSum`，`prefixSum[0]=0`，`prefixSum[i] = prefixSum[i-1] + nums[i-1]`，区间和为 `prefixSum[j+1] - prefixSum[i]`。
2. **LeetCode 560. Subarray Sum Equals K（和为 K 的子数组）**
    - **题目描述**：给定整数数组 `nums` 和整数 `k`，返回和为 `k` 的连续子数组的个数。
    - **示例**：`nums = [1,1,1]`，`k = 2`，输出 `2`（子数组 `[1,1]` 出现两次）。
    - 思路：前缀和 + 哈希表，记录前缀和出现的次数，`currentSum - K` 存在时累加次数。
3. **LeetCode 523. Continuous Subarray Sum（连续的子数组和）**
    - **题目描述**：给定整数数组 `nums` 和整数 `k`，判断是否存在长度至少为 2 的连续子数组，其和是 `k` 的倍数（即和能被 `k` 整除）。
    - **示例**：`nums = [23,2,4,6,7]`，`k = 6`，输出 `true`（子数组 `[2,4]` 和为 6，能被 6 整除）。
    - 思路：前缀和 + 取模，若 `(prefixSum[i] - prefixSum[j]) % k == 0` 且 `i-j >= 2`，则存在符合条件的子数组，用哈希表记录余数第一次出现的索引。
4. **LeetCode 304. Range Sum Query 2D - Immutable（二维区域和检索 - 矩阵不可变）**
    - **题目描述**：给定二维矩阵 `matrix`，实现一个类，支持查询左上角 `(row1, col1)` 到右下角 `(row2, col2)` 区间的元素和（多次查询）。
    - **示例**：矩阵为 `[[3,0,1],[5,6,3]]`，查询 `(0,0)` 到 `(1,1)` 返回 3+0+5+6=14。
    - 思路：预处理二维前缀和数组，`prefixSum[i][j]` 表示左上角到 `(i-1,j-1)` 的和，区间和通过前缀和公式计算。
5. **LeetCode 238. Product of Array Except Self（除自身以外数组的乘积）**
    - **题目描述**：给定整数数组 `nums`，返回一个数组 `answer`，其中 `answer[i]` 是 `nums` 中除 `nums[i]` 外所有元素的乘积（不能用除法）。
    - **示例**：`nums = [1,2,3,4]`，输出 `[24,12,8,6]`。
    - 思路：前缀积 + 后缀积，先计算前缀积数组，再从后往前计算后缀积，每个位置的结果为前缀积 * 后缀积。

### 三、滑动窗口（Sliding Window）

1. **LeetCode 3. Longest Substring Without Repeating Characters（无重复字符的最长子串）**
    - **题目描述**：给定字符串 `s`，找出不含重复字符的最长子串的长度。
    - **示例**：`s = "abcabcbb"`，最长子串为 `"abc"`，长度 3；`s = "bbbbb"`，长度 1。
    - 思路：双指针维护窗口，哈希表记录字符最后出现的位置，右指针右移，左指针跳转到重复字符的下一位，更新最大长度。
2. **LeetCode 76. Minimum Window Substring（最小覆盖子串）**
    - **题目描述**：给定字符串 `s` 和 `t`，找出 `s` 中包含 `t` 所有字符的最小子串（字符顺序不限，可包含其他字符）。
    - **示例**：`s = "ADOBECODEBANC"`，`t = "ABC"`，最小子串为 `"BANC"`。
    - 思路：双指针 + 哈希表，右指针扩展窗口，左指针收缩窗口，记录包含所有目标字符的最小窗口。
3. **LeetCode 438. Find All Anagrams in a String（找到字符串中所有字母异位词）**
    - **题目描述**：给定字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的字母异位词的起始索引（异位词指字符相同但顺序不同的字符串）。
    - **示例**：`s = "cbaebabacd"`，`p = "abc"`，输出 `[0,6]`（子串 `"cba"` 和 `"bac"` 是异位词）。
    - 思路：固定长度窗口（长度为目标串长度），用数组记录字符频次，比较窗口内频次与目标串是否一致。
4. **LeetCode 1456. Maximum Number of Vowels in a Substring of Given Length（定长子串中元音的最大数目）**
    - **题目描述**：给定字符串 `s` 和整数 `k`，返回长度为 `k` 的子串中元音字母（a,e,i,o,u）的最大数目。
    - **示例**：`s = "abciiidef"`，`k = 3`，子串 `"iii"` 含 3 个元音，输出 `3`。
    - 思路：固定长度窗口，统计窗口内元音数量，滑动窗口时更新数量并记录最大值。
5. **LeetCode 239. Sliding Window Maximum（滑动窗口最大值）**
    - **题目描述**：给定整数数组 `nums` 和滑动窗口大小 `k`，返回每个滑动窗口中的最大值。
    - **示例**：`nums = [1,3,-1,-3,5,3,6,7]`，`k = 3`，输出 `[3,3,5,5,6,7]`。
    - 思路：单调队列，队列存储索引，保持队列中元素对应的值递减，窗口滑动时维护队列，队首即为当前窗口最大值。

### 四、单调栈 / 队列（Monotonic Stack/Queue）

#### 单调栈

1. **LeetCode 496. Next Greater Element I（下一个更大元素 I）**
    - **题目描述**：给定两个没有重复元素的数组 `nums1` 和 `nums2`，`nums1` 是 `nums2` 的子集，找出 `nums1` 中每个元素在 `nums2` 中的下一个更大元素（即右侧第一个比它大的元素，若不存在则为 -1）。
    - **示例**：`nums1 = [4,1,2]`，`nums2 = [1,3,4,2]`，输出 `[-1,3,-1]`。
    - 思路：单调栈预处理数组，记录每个元素的下一个更大元素，再根据映射查询结果。
2. **LeetCode 739. Daily Temperatures（每日温度）**
    - **题目描述**：给定每日温度数组 `temperatures`，返回一个数组，其中每个元素是需要等待几天才会有更高温度（若没有则为 0）。
    - **示例**：`temperatures = [73,74,75,71,69,72,76,73]`，输出 `[1,1,4,2,1,1,0,0]`。
    - 思路：单调栈，栈存储索引，保持栈中温度递减，遍历到更高温度时弹出栈顶，计算天数差。
3. **LeetCode 42. Trapping Rain Water（接雨水）**
    - **题目描述**：给定非负整数数组 `height`，表示柱子的高度，计算按此排列的柱子能接多少雨水。
    - **示例**：`height = [0,1,0,2,1,0,1,3,2,1,2,1]`，输出 `6`。
    - 思路：单调栈，栈存储索引，保持栈中高度递减，遇到更高高度时计算接水量。
4. **LeetCode 84. Largest Rectangle in Histogram（柱状图中最大的矩形）**
    - **题目描述**：给定非负整数数组 `heights`，表示柱状图中柱子的高度，每个柱子宽度为 1，找出柱状图中最大矩形的面积。
    - **示例**：`heights = [2,1,5,6,2,3]`，最大面积为 10（高度 5 和 6 组成的矩形，宽 2）。
    - 思路：单调栈，找每个柱子的左右边界（第一个小于当前高度的柱子），面积为 `(右边界 - 左边界 - 1) * 高度`。

#### 单调队列

1. **LeetCode 239. Sliding Window Maximum（滑动窗口最大值）**
    - **题目描述**：给定整数数组 `nums` 和滑动窗口大小 `k`，返回每个滑动窗口中的最大值。
    - **示例**：`nums = [1,3,-1,-3,5,3,6,7]`，`k = 3`，输出 `[3,3,5,5,6,7]`。
    - 思路：单调队列存储索引，保持队列中元素对应的值递减，窗口滑动时维护队列，队首为最大值。
2. **LeetCode 59. II. Maximum Value in a Queue（队列的最大值）**
    - **题目描述**：请设计一个队列，支持 `push_back`、`pop_front` 和 `max_value` 操作，`max_value` 能返回队列中的最大值（要求各操作均摊时间复杂度为 O (1)）。
    - **示例**：队列依次加入 1、3、2，`max_value` 返回 3；弹出 1 后，`max_value` 仍为 3。
    - 思路：单调队列辅助，队列存储元素，单调队列存储最大值的候选，出队时同步维护单调队列。

### 五、二分查找（Binary Search）

1. **LeetCode 704. Binary Search（二分查找）**
    - **题目描述**：给定一个按非递减顺序排序的整数数组 `nums` 和目标值 `target`，若 `target` 存在则返回索引，否则返回 -1。
    - **示例**：`nums = [-1,0,3,5,9,12]`，`target = 9`，输出 `4`；`target = 2`，输出 `-1`。
    - 思路：左右指针，`mid = left + (right - left) / 2`，比较 `nums[mid]` 与目标值，调整指针。
2. **LeetCode 35. Search Insert Position（搜索插入位置）**
    - **题目描述**：给定排序数组 `nums` 和目标值 `target`，若存在则返回索引；否则返回其按顺序插入的位置。
    - **示例**：`nums = [1,3,5,6]`，`target = 5` 输出 `2`；`target = 2` 输出 `1`。
    - 思路：二分查找，若找到则返回索引，否则返回 `left`（插入位置）。
3. **LeetCode 34. Find First and Last Position of Element in Sorted Array（在排序数组中查找元素的第一个和最后一个位置）**
    - **题目描述**：给定排序数组 `nums` 和目标值 `target`，找出 `target` 在数组中出现的第一个和最后一个位置（若不存在则返回 `[-1,-1]`）。
    - **示例**：`nums = [5,7,7,8,8,10]`，`target = 8`，输出 `[3,4]`。
    - 思路：两次二分，分别找左边界（第一个大于等于目标的索引）和右边界（最后一个小于等于目标的索引）。
4. **LeetCode 33. Search in Rotated Sorted Array（搜索旋转排序数组）**
    - **题目描述**：给定一个升序排列后旋转的数组 `nums`（如 `[0,1,2,4,5,6,7]` 旋转为 `[4,5,6,7,0,1,2]`）和目标值 `target`，返回其索引（若不存在返回 -1）。
    - **示例**：`nums = [4,5,6,7,0,1,2]`，`target = 0`，输出 `4`。
    - 思路：二分查找，先判断 mid 所在的有序区间，再根据目标值调整指针。
        - 扩展：Find Minimum in Rotated Sorted Array（旋转数组找最小值）：类似上题，找无序区间的最小值。
5. **LeetCode 162. Find Peak Element（寻找峰值）**
    - **题目描述**：峰值元素是指其值严格大于左右相邻值的元素，给定数组 `nums`，找到任意一个峰值元素并返回其索引（数组边界外视为负无穷）。
    - **示例**：`nums = [1,2,3,1]`，峰值为 3（索引 2），输出 `2`。
    - 思路：二分查找，若 `nums[mid] < nums[mid+1]` 则峰值在右半部分，否则在左半部分。
6. **LeetCode 69. Sqrt (x)（平方根）**
    - **题目描述**：实现 `int sqrt(int x)` 函数，计算并返回 `x` 的平方根（只保留整数部分）。
    - **示例**：`x = 8`，输出 `2`（√8≈2.828，取整数部分 2）。
    - 思路：二分答案，`left=0`，`right=x`，找最大的 `mid` 使得 `mid*mid <= x`。
7. **LeetCode 875. Koko Eating Bananas（爱吃香蕉的珂珂）**
    - **题目描述**：珂珂每小时最多吃 `k` 根香蕉，`piles` 数组表示各堆香蕉的数量，她想在 `h` 小时内吃完所有香蕉，求最小的 `k`。
    - **示例**：`piles = [3,6,7,11]`，`h = 8`，最小 `k` 为 4（3/4=1 小时，6/4=2 小时，7/4=2 小时，11/4=3 小时，总和 8）。
    - 思路：二分答案，最小速度 `left=1`，最大速度 `right=max(piles)`，判断当前速度是否能在规定时间内吃完。

### 六、并查集（Union-Find/Disjoint Set）

1. **LeetCode 547. Number of Provinces（省份数量）**
    - **题目描述**：有 `n` 个城市，`isConnected[i][j] = 1` 表示城市 `i` 和 `j` 相连，`0` 表示不相连，省份是一组直接或间接相连的城市，返回省份数量。
    - **示例**：`isConnected = [[1,1,0],[1,1,0],[0,0,1]]`，有 2 个省份，输出 `2`。
    - 思路：并查集，遍历所有城市，合并相连的城市，统计连通分量数量。
2. **LeetCode 200. Number of Islands（岛屿数量）**
    - **题目描述**：给定 `m x n` 网格，`'1'` 代表陆地，`'0'` 代表水，相邻陆地（水平 / 垂直）组成岛屿，返回岛屿数量。
    - **示例**：输入含 3 个岛屿的网格，输出 `3`。
    - 思路：并查集，遍历网格，合并陆地的相邻节点，统计连通分量数量（也可用 DFS/BFS）。
3. **LeetCode 684. Redundant Connection（冗余连接）**
    - **题目描述**：给定一个含 `n` 个节点的树加一条边形成的图，找出这条冗余边（移除后图变为树）。
    - **示例**：`edges = [[1,2],[1,3],[2,3]]`，冗余边为 `[2,3]`，输出 `[2,3]`。
    - 思路：并查集，遍历边，若两节点已连通则为冗余边，否则合并。
4. **LeetCode 765. Couples Holding Hands（情侣牵手）**
    - **题目描述**：`2n` 个人坐成一排，情侣按 `(0,1), (2,3), ..., (2n-2, 2n-1)` 编号，每次可交换任意两人的位置，求最少交换次数使所有情侣相邻。
    - **示例**：`row = [0,2,1,3]`，交换 2 和 1 即可，输出 `1`。
    - 思路：并查集，将情侣视为节点，统计每个连通分量的大小，交换次数为 `sum(大小 - 1)`。
5. **LeetCode 986. Interval List Intersections（区间列表的交集）**
    - **题目描述**：给定两个区间列表 `firstList` 和 `secondList`，每个区间按起始时间排序，返回所有交集区间。
    - **示例**：`firstList = [[0,2],[5,10],[13,23],[24,25]]`，`secondList = [[1,5],[8,12],[15,24],[25,26]]`，输出交集区间列表。
    - 思路：双指针遍历两个区间列表，找交集区间，也可结合并查集（较少见，双指针更直接）。

### 七、记忆化搜索（Memoization）

1. **LeetCode 509. Fibonacci Number（斐波那契数）**
    - **题目描述**：斐波那契数定义为 `F(0)=0`，`F(1)=1`，`F(n) = F(n-1) + F(n-2)`（n>1），给定 `n`，计算 `F(n)`。
    - **示例**：`n=4`，`F(4)=3`（0,1,1,2,3），输出 `3`。
    - 思路：递归 + 记忆化，存储已计算的斐波那契数，避免重复计算。
2. **LeetCode 70. Climbing Stairs（爬楼梯）**
    - **题目描述**：每次可爬 1 或 2 阶楼梯，求爬到第 `n` 阶的方法数。
    - **示例**：`n=3`，有 3 种方法（1+1+1，1+2，2+1），输出 `3`。
    - 思路：递归 + 记忆化，`dp[n] = dp[n-1] + dp[n-2]`，或迭代实现。
3. **LeetCode 62. Unique Paths（不同路径）**
    - **题目描述**：一个机器人从 `m x n` 网格的左上角走到右下角，只能向右或向下移动，求不同路径的数量。
    - **示例**：`m=3`，`n=7`，输出 `28`。
    - 思路：递归 + 记忆化，`dp[i][j] = dp[i-1][j] + dp[i][j-1]`，或迭代实现。
4. **LeetCode 300. Longest Increasing Subsequence（最长递增子序列）**
    - **题目描述**：给定整数数组 `nums`，返回最长递增子序列的长度（子序列元素相对顺序不变，严格递增）。
    - **示例**：`nums = [10,9,2,5,3,7,101,18]`，最长子序列为 `[2,3,7,101]`，长度 4。
    - 思路：记忆化 + 递归，`dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列长度，`dp[i] = max(dp[j] + 1)`（`j < i` 且 `nums[j] < nums[i]`）。
5. **LeetCode 494. Target Sum（目标和）**
    - **题目描述**：给定非负整数数组 `nums` 和目标数 `target`，给每个数前加 `+` 或 `-`，使所有数的和等于 `target`，返回方案数。
    - **示例**：`nums = [1,1,1,1,1]`，`target = 3`，输出 `5`。
    - 思路：记忆化优化递归，记录 `(index, currentSum)` 的方案数。
6. **LeetCode 337. House Robber III（打家劫舍 III）**
    - **题目描述**：二叉树的节点值表示房屋内的金额，不能抢劫相邻的房屋（父与子节点），求能抢劫的最大金额。
    - **示例**：根节点值 3，左子树 2（右子树 3），右子树 3（右子树 1），最大金额为 3+3+1=7。
    - 思路：树的记忆化搜索，后序遍历，返回偷或不偷当前节点的最大收益。

### 八、Trie 树（前缀树）

1. **LeetCode 208. Implement Trie (Prefix Tree)（实现 Trie 前缀树）**
    - **题目描述**：实现 Trie 类，支持 `insert`（插入单词）、`search`（查找单词是否存在）、`startsWith`（查找是否有以给定前缀开头的单词）操作。
    - **示例**：插入 "apple" 后，`search("apple")` 返回 `true`，`startsWith("app")` 返回 `true`，`search("app")` 返回 `false`。
    - 思路：Trie 节点包含子节点数组和是否为结尾的标记，实现插入、查找、前缀查找方法。
2. **LeetCode 212. Word Search II（单词搜索 II）**
    - **题目描述**：给定字符网格 `board` 和单词列表 `words`，返回所有在网格中能找到的单词（字母需相邻且不重复使用）。
    - **示例**：`words = ["oath","pea","eat","rain"]`，网格含 "oath" 和 "eat"，输出 `["oath","eat"]`。
    - 思路：Trie + DFS 优化，先构建单词的 Trie 树，再网格 DFS 时借助 Trie 剪枝。
3. **LeetCode 745. Prefix and Suffix Search（前缀和后缀搜索）**
    - **题目描述**：设计一个数据结构，支持 `f(prefix, suffix)` 操作，返回具有给定前缀和后缀的单词的最大索引（若不存在返回 -1）。
    - **示例**：单词列表 `["apple"]`，`f("a","e")` 返回 0（"apple" 前缀 "a" 且后缀 "e"）。
    - 思路：双向 Trie，存储单词的 `后缀#前缀` 形式，实现前缀和后缀的联合查询。
4. **LeetCode 677. Map Sum Pairs（键值映射）**
    - **题目描述**：实现 `MapSum` 类，支持 `insert(key, val)`（插入键值对，若键存在则更新值）和 `sum(prefix)`（返回所有以 `prefix` 为前缀的键的值的总和）。
    - **示例**：插入 ("apple", 3) 后，`sum("ap")` 返回 3；插入 ("app", 2) 后，`sum("ap")` 返回 5。
    - 思路：Trie 存储前缀和，每个节点记录以该前缀结尾的键的总和。

### 九、扫描线（Sweep Line）

1. **LeetCode 253. Meeting Rooms II（会议室 II）**
    - **题目描述**：给定会议时间区间 `intervals`（每个区间为 `[start, end]`），计算需要的最少会议室数量。
    - **示例**：`intervals = [[0,30],[5,10],[15,20]]`，需 2 个会议室，输出 `2`。
    - 思路：扫描线，将会议的开始和结束时间排序，遍历并统计同时进行的会议数，最大值即为所需会议室数。
2. **LeetCode 56. Merge Intervals（合并区间）**
    - **题目描述**：给定区间列表 `intervals`，合并所有重叠的区间，返回合并后的区间列表。
    - **示例**：`intervals = [[1,3],[2,6],[8,10],[15,18]]`，合并后为 `[[1,6],[8,10],[15,18]]`。
    - 思路：扫描线，区间按起始时间排序，遍历合并重叠区间。
3. **LeetCode 218. The Skyline Problem（天际线问题）**
    - **题目描述**：给定建筑物的左边界、右边界和高度 `buildings = [[left, right, height]]`，返回天际线的关键点（即高度变化的点，格式为 `[x, height]`）。
    - **示例**：建筑物 `[[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]`，输出关键点列表。
    - 思路：扫描线 + 优先队列，处理建筑的起点和终点，维护当前最高建筑，记录天际线关键点。

### 十、补充题型：动态规划（Dynamic Programming）

1. **LeetCode 5. Longest Palindromic Substring（最长回文子串）**
    - **题目描述**：给定字符串 `s`，找出其中最长的回文子串（回文串是正着读和反着读都一样的字符串）。
    - **示例**：`s = "babad"`，最长回文子串为 `"bab"` 或 `"aba"`；`s = "cbbd"`，为 `"bb"`。
    - 思路：区间 DP，`dp[i][j]` 表示 `s[i..j]` 是否为回文，`dp[i][j] = (s[i]==s[j]) && dp[i+1][j-1]`。
2. **LeetCode 72. Edit Distance（编辑距离）**
    - **题目描述**：给定两个单词 `word1` 和 `word2`，计算将 `word1` 转换为 `word2` 所需的最少操作数（操作包括插入、删除、替换一个字符）。
    - **示例**：`word1 = "horse"`，`word2 = "ros"`，最少操作数为 3（horse→rorse→rose→ros）。
    - 思路：经典 DP，`dp[i][j]` 表示 `word1[0..i-1]` 到 `word2[0..j-1]` 的最小步数，`dp[i][j] = min(插入、删除、替换) + 1`（或字符相等时取 `dp[i-1][j-1]`）。
3. **LeetCode 1143. Longest Common Subsequence（最长公共子序列）**
    - **题目描述**：给定两个字符串 `text1` 和 `text2`，返回它们的最长公共子序列的长度（子序列是不连续但顺序一致的字符序列）。
    - **示例**：`text1 = "abcde"`，`text2 = "ace"`，最长公共子序列为 `"ace"`，长度 3。
    - 思路：DP，`dp[i][j]` 表示 `text1[0..i-1]` 与 `text2[0..j-1]` 的 LCS 长度，`dp[i][j] = (text1[i-1]==text2[j-1]) ? dp[i-1][j-1]+1 : max(dp[i-1][j], dp[i][j-1])`。
4. **LeetCode 322. Coin Change（零钱兑换）**
    - **题目描述**：给定不同面额的硬币 `coins` 和总金额 `amount`，计算凑成总金额所需的最少硬币数（若无法凑成，返回 -1）。
    - **示例**：`coins = [1,2,5]`，`amount = 11`，最少硬币数为 3（5+5+1）。
    - 思路：完全背包 DP，`dp[amount]` 表示凑成金额 `amount` 的最少硬币数，`dp[amount] = min(dp[amount - coin] + 1)`（遍历所有硬币）。
5. **LeetCode 300. Longest Increasing Subsequence（最长递增子序列）**
    - **题目描述**：给定整数数组 `nums`，返回最长递增子序列的长度（子序列元素相对顺序不变，严格递增）。
    - **示例**：`nums = [10,9,2,5,3,7,101,18]`，最长子序列长度为 4。
    - 思路：DP，`dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列长度，`dp[i] = max(dp[j] + 1)`（`j < i` 且 `nums[j] < nums[i]`）。



### 十一、其他

#### 134 · LRU Cache

利用std::list::splice()方法 **将一个链表的部分或全部节点 “迁移” 到另一个链表的指定位置**

lru_.splice(lru_.begin(), lru_, table_[key]);     **将lru中的table_[key]值，移动到lru的开始**

```
    printList(list1, "初始 list1"); // list1: 1 2 3
    printList(list2, "初始 list2"); // list2: 4 5 6


    // 用法1：迁移单个节点（将 list2 的第一个节点 4 迁移到 list1 的 2 之前）
    auto it = list2.begin(); // it 指向 list2 的 4
    list1.splice(next(list1.begin()), list2, it); // next(list1.begin()) 是 2 的位置
    printList(list1, "迁移单个节点后 list1"); // list1: 1 4 2 3
    printList(list2, "迁移单个节点后 list2"); // list2: 5 6
```

将lru位于table_[key]的位置的元素，移动到lru_.begin()的地方, table_[key]为iterator

```c++
class LRUCache {
public:
    /*
    * @param capacity: An integer
    */
    LRUCache(int capacity): capacity_(capacity) {
        // do intialization if necessary
    }

    /*
     * @param key: An integer
     * @return: An integer
     */
    int get(int key) {
        if (table_.find(key) != table_.end())
        {
            lru_.splice(lru_.begin(), lru_, table_[key]);
            return table_[key]->second;
        }
        return -1;
    }

    /*
     * @param key: An integer
     * @param value: An integer
     * @return: nothing
     */
    void set(int key, int value) {
        if (table_.find(key) != table_.end())
        {
            lru_.splice(lru_.begin(), lru_, table_[key]);
            table_[key]->second = value;
            return;
        }

        lru_.push_front({key, value});
        table_[key] = lru_.begin();
        if (lru_.size() > capacity_)
        {
            table_.erase(lru_.back().first);
            lru_.pop_back();
        }
    }

    int capacity_;
    list<pair<int, int>> lru_;
    unordered_map<int, list<pair<int, int>>::iterator> table_;
};
```
#### 快速排序

假设每次选择的 pivot 都能将数组**均匀分为两半**（左右子数组长度接近 n/2），则递归过程可视为一棵**平衡二叉树**：

- **第 1 层**：处理整个数组（长度 n），分区耗时 O (n)。
- **第 2 层**：处理两个子数组（各长度 n/2），总耗时 O (n/2) + O (n/2) = O (n)。
- **第 3 层**：处理四个子数组（各长度 n/4），总耗时 4 × O (n/4) = O (n)。
- ...
- **第 log₂n 层**：处理 n 个子数组（各长度 1），总耗时 n × O (1) = O (n)。

总层数为 **log₂n**（以 2 为底），每层总耗时均为 O (n)，因此总时间复杂度为：**O(n) × log n = O(n log n)**。

#### 归并排序

1. **拆分（Divide）**：将原始数组递归地拆分为两个等长（或近似等长）的子数组，直到子数组长度为 1（单个元素天然有序）。例如：`[3,1,2,4]` → 拆分为 `[3,1]` 和 `[2,4]`，再继续拆分为 `[3]`、`[1]` 和 `[2]`、`[4]`。
2. **合并（Merge）**：将两个已排序的子数组合并为一个更大的有序数组。合并时需借助临时空间，通过双指针比较两个子数组的元素，按顺序放入临时数组，最后将临时数组的结果复制回原数组。例如：合并 `[1,3]` 和 `[2,4]` → 比较 1 vs 2 → 1 先入队；3 vs 2 → 2 入队；3 vs 4 → 3 入队；最后 4 入队 → 得到 `[1,2,3,4]`。

#### 堆排序



#### 全排列问题(无重复数字/有重复数字)





#### 验证二叉树前序序列序列化



#### 正则表达式匹配
