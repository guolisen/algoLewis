### 一、双指针（Two Pointers）

1. **LeetCode 167. Two Sum II - Input Array Is Sorted（两数之和 II - 输入有序数组）**
    - 思路：左右指针分别从数组首尾出发，和小于目标则左指针右移，大于则右指针左移，等于则返回。
2. **LeetCode 344. Reverse String（反转字符串）**
    - 思路：左右指针交换字符，向中间移动，直到相遇。
3. **LeetCode 125. Valid Palindrome（有效的回文）**
    - 思路：左右指针跳过非字母数字字符，比较字符是否相等，忽略大小写。
4. **LeetCode 27. Remove Element（移除元素）**
    - 思路：快慢指针，快指针遍历数组，慢指针记录非目标值的位置，将快指针元素复制到慢指针位置。
5. **LeetCode 977. Squares of a Sorted Array（有序数组的平方）**
    - 思路：左右指针分别指向首尾，比较平方值大小，将较大值放入结果数组末尾。
6. **LeetCode 141. Linked List Cycle（环形链表）**
    - 思路：快慢指针，快指针每次走 2 步，慢指针走 1 步，若相遇则有环。
7. **LeetCode 160. Intersection of Two Linked Lists（相交链表）**
    - 思路：双指针对齐长度，两个指针分别遍历两个链表，到末尾后交换链表继续遍历，相遇点即为相交节点。
8. **LeetCode 15. 3Sum（三数之和）**
    - 思路：排序后，固定第一个数，左右指针找剩下两个数的和为目标值，注意去重（相同数跳过）。

### 二、前缀和（Prefix Sum）

1. **LeetCode 303. Range Sum Query - Immutable（区域和检索 - 数组不可变）**
    - 思路：预处理前缀和数组 `prefixSum`，`prefixSum[0]=0`，`prefixSum[i] = prefixSum[i-1] + nums[i-1]`，区间和为 `prefixSum[j+1] - prefixSum[i]`。
2. **LeetCode 560. Subarray Sum Equals K（和为 K 的子数组）**
    - 思路：前缀和 + 哈希表，记录前缀和出现的次数，`currentSum - K` 存在时累加次数。
3. **LeetCode 523. Continuous Subarray Sum（连续的子数组和）**
    - 思路：前缀和 + 取模，若 `(prefixSum[i] - prefixSum[j]) % k == 0` 且 `i-j >= 2`，则存在符合条件的子数组，用哈希表记录余数第一次出现的索引。
4. **LeetCode 304. Range Sum Query 2D - Immutable（二维区域和检索 - 矩阵不可变）**
    - 思路：预处理二维前缀和数组，`prefixSum[i][j]` 表示左上角到 `(i-1,j-1)` 的和，区间和通过前缀和公式计算。
5. **LeetCode 238. Product of Array Except Self（除自身以外数组的乘积）**
    - 思路：前缀积 + 后缀积，先计算前缀积数组，再从后往前计算后缀积，每个位置的结果为前缀积 * 后缀积。

### 三、滑动窗口（Sliding Window）

1. **LeetCode 3. Longest Substring Without Repeating Characters（无重复字符的最长子串）**
    - 思路：双指针维护窗口，哈希表记录字符最后出现的位置，右指针右移，左指针跳转到重复字符的下一位，更新最大长度。
2. **LeetCode 76. Minimum Window Substring（最小覆盖子串）**
    - 思路：双指针 + 哈希表，右指针扩展窗口，左指针收缩窗口，记录包含所有目标字符的最小窗口。
3. **LeetCode 438. Find All Anagrams in a String（找到字符串中所有字母异位词）**
    - 思路：固定长度窗口（长度为目标串长度），用数组记录字符频次，比较窗口内频次与目标串是否一致。
4. **LeetCode 1456. Maximum Number of Vowels in a Substring of Given Length（定长子串中元音的最大数目）**
    - 思路：固定长度窗口，统计窗口内元音数量，滑动窗口时更新数量并记录最大值。
5. **LeetCode 239. Sliding Window Maximum（滑动窗口最大值）**
    - 思路：单调队列，队列存储索引，保持队列中元素对应的值递减，窗口滑动时维护队列，队首即为当前窗口最大值。

### 四、单调栈 / 队列（Monotonic Stack/Queue）

#### 单调栈

1. **LeetCode 496. Next Greater Element I（下一个更大元素 I）**
    - 思路：单调栈预处理数组，记录每个元素的下一个更大元素，再根据映射查询结果。
2. **LeetCode 739. Daily Temperatures（每日温度）**
    - 思路：单调栈，栈存储索引，保持栈中温度递减，遍历到更高温度时弹出栈顶，计算天数差。
3. **LeetCode 42. Trapping Rain Water（接雨水）**
    - 思路：单调栈，栈存储索引，保持栈中高度递减，遇到更高高度时计算接水量。
4. **LeetCode 84. Largest Rectangle in Histogram（柱状图中最大的矩形）**
    - 思路：单调栈，找每个柱子的左右边界（第一个小于当前高度的柱子），面积为 `(右边界 - 左边界 - 1) * 高度`。

#### 单调队列

1. **LeetCode 239. Sliding Window Maximum（滑动窗口最大值）**
    - 思路：单调队列存储索引，保持队列中元素对应的值递减，窗口滑动时维护队列，队首为最大值。
2. **LeetCode 59. II. Maximum Value in a Queue（队列的最大值）**
    - 思路：单调队列辅助，队列存储元素，单调队列存储最大值的候选，出队时同步维护单调队列。

### 五、二分查找（Binary Search）

1. **LeetCode 704. Binary Search（二分查找）**
    - 思路：左右指针，`mid = left + (right - left) / 2`，比较 `nums[mid]` 与目标值，调整指针。
2. **LeetCode 35. Search Insert Position（搜索插入位置）**
    - 思路：二分查找，若找到则返回索引，否则返回 `left`（插入位置）。
3. **LeetCode 34. Find First and Last Position of Element in Sorted Array（在排序数组中查找元素的第一个和最后一个位置）**
    - 思路：两次二分，分别找左边界（第一个大于等于目标的索引）和右边界（最后一个小于等于目标的索引）。
4. **LeetCode 33. Search in Rotated Sorted Array（搜索旋转排序数组）**
    - 思路：二分查找，先判断 mid 所在的有序区间，再根据目标值调整指针。
    - 1. Find Minimum in Rotated Sorted Array（旋转数组找最小值）：类似上题，找无序区间的最小值。
5. **LeetCode 162. Find Peak Element（寻找峰值）**
    - 思路：二分查找，若 `nums[mid] < nums[mid+1]` 则峰值在右半部分，否则在左半部分。
6. **LeetCode 69. Sqrt (x)（平方根）**
    - 思路：二分答案，`left=0`，`right=x`，找最大的 `mid` 使得 `mid*mid <= x`。
7. **LeetCode 875. Koko Eating Bananas（爱吃香蕉的珂珂）**
    - 思路：二分答案，最小速度 `left=1`，最大速度 `right=max(piles)`，判断当前速度是否能在规定时间内吃完。

### 六、并查集（Union-Find/Disjoint Set）

1. **LeetCode 547. Number of Provinces（省份数量）**
    - 思路：并查集，遍历所有城市，合并相连的城市，统计连通分量数量。
2. **LeetCode 200. Number of Islands（岛屿数量）**
    - 思路：并查集，遍历网格，合并陆地的相邻节点，统计连通分量数量（也可用 DFS/BFS）。
3. **LeetCode 684. Redundant Connection（冗余连接）**
    - 思路：并查集，遍历边，若两节点已连通则为冗余边，否则合并。
4. **LeetCode 547. Number of Provinces（朋友圈）**
    - 思路：同省份数量，用并查集统计连通分量。
5. **LeetCode 765. Couples Holding Hands（情侣牵手）**
    - 思路：并查集，将情侣视为节点，统计每个连通分量的大小，交换次数为 `sum(大小 - 1)`。
6. **LeetCode 986. Interval List Intersections（区间列表的交集）**
    - 思路：双指针遍历两个区间列表，找交集区间，也可结合并查集（较少见，双指针更直接）。

### 七、记忆化搜索（Memoization）

1. **LeetCode 509. Fibonacci Number（斐波那契数）**
    - 思路：递归 + 记忆化，存储已计算的斐波那契数，避免重复计算。
2. **LeetCode 70. Climbing Stairs（爬楼梯）**
    - 思路：递归 + 记忆化，`dp[n] = dp[n-1] + dp[n-2]`，或迭代实现。
3. **LeetCode 62. Unique Paths（不同路径）**
    - 思路：递归 + 记忆化，`dp[i][j] = dp[i-1][j] + dp[i][j-1]`，或迭代实现。
4. **LeetCode 300. Longest Increasing Subsequence（最长递增子序列）**
    - 思路：记忆化 + 递归，`dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列长度，`dp[i] = max(dp[j] + 1)`（`j < i` 且 `nums[j] < nums[i]`）。
5. **LeetCode 494. Target Sum（目标和）**
    - 思路：记忆化优化递归，记录 `(index, currentSum)` 的方案数。
6. **LeetCode 337. House Robber III（打家劫舍 III）**
    - 思路：树的记忆化搜索，后序遍历，返回偷或不偷当前节点的最大收益。

### 八、Trie 树（前缀树）

1. **LeetCode 208. Implement Trie (Prefix Tree)（实现 Trie 前缀树）**
    - 思路：Trie 节点包含子节点数组和是否为结尾的标记，实现插入、查找、前缀查找方法。
2. **LeetCode 212. Word Search II（单词搜索 II）**
    - 思路：Trie + DFS 优化，先构建单词的 Trie 树，再网格 DFS 时借助 Trie 剪枝。
3. **LeetCode 745. Prefix and Suffix Search（前缀和后缀搜索）**
    - 思路：双向 Trie，存储单词的 `后缀#前缀` 形式，实现前缀和后缀的联合查询。
4. **LeetCode 677. Map Sum Pairs（键值映射）**
    - 思路：Trie 存储前缀和，每个节点记录以该前缀结尾的键的总和。

### 九、扫描线（Sweep Line）

1. **LeetCode 253. Meeting Rooms II（会议室 II）**
    - 思路：扫描线，将会议的开始和结束时间排序，遍历并统计同时进行的会议数，最大值即为所需会议室数。
2. **LeetCode 56. Merge Intervals（合并区间）**
    - 思路：扫描线，区间按起始时间排序，遍历合并重叠区间。
3. **LeetCode 986. Interval List Intersections（区间列表的交集）**
    - 思路：双指针遍历两个区间列表，找交集区间。
4. **LeetCode 218. The Skyline Problem（天际线问题）**
    - 思路：扫描线 + 优先队列，处理建筑的起点和终点，维护当前最高建筑，记录天际线关键点。

### 十、补充题型：动态规划（Dynamic Programming）

1. **LeetCode 5. Longest Palindromic Substring（最长回文子串）**
    - 思路：区间 DP，`dp[i][j]` 表示 `s[i..j]` 是否为回文，`dp[i][j] = (s[i]==s[j]) && dp[i+1][j-1]`。
2. **LeetCode 72. Edit Distance（编辑距离）**
    - 思路：经典 DP，`dp[i][j]` 表示 `word1[0..i-1]` 到 `word2[0..j-1]` 的最小步数，`dp[i][j] = min(插入、删除、替换) + 1`（或字符相等时取 `dp[i-1][j-1]`）。
3. **LeetCode 1143. Longest Common Subsequence（最长公共子序列）**
    - 思路：DP，`dp[i][j]` 表示 `text1[0..i-1]` 与 `text2[0..j-1]` 的 LCS 长度，`dp[i][j] = (text1[i-1]==text2[j-1]) ? dp[i-1][j-1]+1 : max(dp[i-1][j], dp[i][j-1])`。
4. **LeetCode 322. Coin Change（零钱兑换）**
    - 思路：完全背包 DP，`dp[amount]` 表示凑成金额 `amount` 的最少硬币数，`dp[amount] = min(dp[amount - coin] + 1)`（遍历所有硬币）。
5. **LeetCode 300. Longest Increasing Subsequence（最长递增子序列）**
    - 思路：DP，`dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列长度，`dp[i] = max(dp[j] + 1)`（`j < i` 且 `nums[j] < nums[i]`）。