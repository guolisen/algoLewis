[TOC]

# 排序

https://www.algolist.net/Algorithms/Sorting/Selection_sort
https://www.algolist.net/Algorithms/Sorting/Quicksort
https://www.algolist.net/Algorithms/Sorting/Insertion_sort
https://www.algolist.net/Algorithms/Sorting/Bubble_sort
https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html

## 快速排序

### Partition
```
        int m = A.size();
        int l = 0;
        int r = m - 1;
        while (l <= r)
        {
            while (l <= r && A[l] < 0) { l++; }
            while (l <= r && A[r] >= 0) { r--; }
            if (l < r)
            {
                swap(A[l], A[r]);
            }
        }
```
### 31 · Partition Array *  148 · Sort Colors

### 143 · Sort Colors II

```
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
### 144 · 交错正负数
```
from typing import (
    List,
)

class Solution:
    def rerange(self, a: List[int]):
        m = len(a)
        neg = 0
        pos = 0
        for i in a:
            if i < 0:
                neg += 1
            else:
                pos += 1
        flag = 1 if neg < pos else -1
        self.part(a, flag)
        print(a)
        self.interl(a, neg == pos)

    def part(self, A, flag):
        l = 0;
        r = len(A) - 1
        while l <= r:
            while l <= r and A[l] * flag > 0:
                l += 1
            while l <= r and A[r] * flag < 0:
                r -= 1
            if l < r:
                A[l], A[r] = A[r], A[l]
                l += 1
                r -= 1
    def interl(self, A, is_same):
        m = len(A)
        l = 1
        r = m - 1
        if is_same:
            r = m - 2
        while l < r:
            A[l], A[r] = A[r], A[l]
            l += 2
            r -= 2
```

# 双指针

多数有序，比目标大的时候，移动r，比目标小的时候，移动l

**双指针大多都是对两层循环的优化**, 所以当暴力法涉及到两层循环遍历的时候, 我们就应该有这种思想: 能不能用到双指针的思想.

### 56 · Two Sum

```
    vector<int> twoSum(vector<int> &numbers, int target) {
        int m = numbers.size();
        vector<int> res;
        for (int i = 0; i < m - 1; i++)
        {
            for (int j = i + 1; j < m; j++)
            {
                if (numbers[i] + numbers[j] == target)
                {
                    res.push_back(i);
                    res.push_back(j);
                    return res;
                }
            }
        }
        return {-1, -1};
    }
```

### 59 · 3Sum Closest

```
    int threeSumClosest(vector<int> &numbers, int target) {
        if (numbers.empty())
            return 100000000;
        sort(numbers.begin(), numbers.end());
        int m = numbers.size();
        int minv = INT_MAX;
        for (int i = 0; i < m - 1; ++i)
        {
            int l = i + 1;
            int r = m - 1;
            while (l < r)
            {
                int sum = numbers[i] + numbers[l]  + numbers[r];
                if (abs(sum - target) < abs(minv - target))
                {
                    minv = sum;               
                }

                if (sum < target)
                {
                    l++;
                }
                else
                {
                    r--;
                }
            }

        }
        return minv;
    }
```

### 460 · Find K Closest Elements

```
class Solution {
public:
     bool isLeftClosest(vector<int> &a, int target, int l, int r)
     {
        if (l < 0)
            return false;
        if (r >= a.size())
            return true;
        if (target - a[l] <= a[r] - target)
            return true;
        return false;  
     }
    vector<int> kClosestNumbers(vector<int> &a, int target, int k) {
        vector<int> res;
        int l = 0;
        int r = a.size() - 1;
        while (l < r)
        {
            int mid = (l + r) / 2;
            if (a[mid] >= target)
            {
                r = mid;
            }
            else
            {
                l = mid + 1;
            }
        }
        int left  = l - 1;
        int right = l;
        while (k--)
        {
            if (isLeftClosest(a, target, left, right))
            {
                res.push_back(a[left--]);
            }
            else
            {
                res.push_back(a[right++]);
            }
        }
        return res;
    }
};
```



### 31 · Partition Array *  148 · Sort Colors

```
class Solution {
public:
    int partitionArray(vector<int> &nums, int k) {
        int m = nums.size();
        int l = 0;
        int r = m - 1;
        while (l <= r)
        {
            while (l <= r && nums[l] < k) { l++; }
            while (r >= l && nums[r] >= k) { r--; }
            if (l < r)
            {
                swap(nums[l], nums[r]);
            }
        }
        return l;
    }
};
```

### 64 · Merge Sorted Array(6 · Merge Two Sorted Arrays)

```
    void mergeSortedArray(int A[], int m, int B[], int n) {
        int ai = 0;
        int bi = 0;
        vector<int> ires;
        while (ai < m && bi < n)
        {
            if (A[ai] <= B[bi])
            {
                ires.push_back(A[ai++]);
            }
            else
            {
                ires.push_back(B[bi++]);
            }
        }
        while (ai < m)
        {
            ires.push_back(A[ai++]);
        }
        while (bi < n)
        {
            ires.push_back(B[bi++]);
        }

        int i = 0;
        for (auto n : ires)
        {
            A[i++] = n;
        }
    }
```

Second method:

```
    vector<int> mergeSortedArray(vector<int> &A, vector<int> &B) {
        int m = A.size();
        int n = B.size();
        vector<int> res;
        int ai = 0;
        int bi = 0;
        for (int k = 0; k < m + n; ++k)
        {
            if (ai < m && (bi == n || A[ai] < B[bi]))
            {
                res.push_back(A[ai++]);
            }
            else
            {
                res.push_back(B[bi++]);
            }
        }
        return res;
    }
```

In one array

```
    void mergeSortedArray(int A[], int m, int B[], int n) {
        int ri = m + n - 1;
        int ai = m - 1;
        int bi = n - 1;

        while (ai >= 0 && bi >= 0)
        {
            if (A[ai] > B[bi])
            {
                A[ri--] = A[ai--];
            }
            else
            {
                A[ri--] = B[bi--];
            }
        }
        while (bi >= 0)
        {
            A[ri--] = B[bi--];
        }
    }
```

### 165 · Merge Two Sorted Lists

```
    ListNode * mergeTwoLists(ListNode * l1, ListNode * l2) {
        if (!l1) return l2;
        if (!l2) return l1;
        ListNode* head = nullptr;
        if (l1->val < l2->val)
        {
            head = l1;
            head->next = mergeTwoLists(l1->next, l2);
        }
        else
        {
            head = l2;
            head->next = mergeTwoLists(l1, l2->next);
        }
        return head;
    }
```

1246 · Longest Repeating Character Replacement
同向双指针

```
    int characterReplacement(string &s, int k) {
        int m = s.size();
        int res = 0;
        for (int c = 'A'; c <= 'Z'; ++c)
        {
            int count = 0;
            for (int i = 0, j = 0; i < m; i++)
            {
                if (s[i] == c)
                    count++;                           
                while (i - j + 1 - count > k)
                {
                    if (s[j] == c)
                        count--;
                    j++;                      
                }
                res = max(res, i - j + 1);
            }
        }

        return res;
    }
```

### 460 · Find K Closest Elements

```
class Solution {
public:
    bool isClosed(vector<int>& A, int target, int l, int r)
    {
        if (l < 0)
            return false;
        if (r >= A.size())
            return true;
        if ((target - A[l]) != (A[r] - target))
            return (target - A[l]) < (A[r] - target);
        return true;
    }
    vector<int> kClosestNumbers(vector<int> &A, int target, int k) {
        int m = A.size();
        int l = 0;
        int r = m - 1;
        while (l < r)
        {
            int mid = (l + r + 1) / 2;
            if (A[mid] <= target)
            {
                l = mid;
            }
            else
            {
                r = mid - 1;
            }
        }
        int lpos = l;
        int rpos = l + 1;
        vector<int> res;
        while (res.size() < k)
        {
            if (isClosed(A, target, lpos, rpos))
            {
                res.push_back(A[lpos--]);
            }
            else
            {
                res.push_back(A[rpos++]);
            }
        }

        return res;
    }
};
```
## 基础
有序，sum 大于目标时移动r, 反之移动l
### 609 · Two Sum - Less than or equal to target
### 608 · Two Sum II - Input array is sorted
```
class Solution {
public:
    vector<int> twoSum(vector<int> &nums, int target) {
        int m = nums.size();
        sort(nums.begin(), nums.end());
        int l = 0;
        int r = m - 1;

        while (l < r)
        {
            int sum = nums[l] + nums[r];
            if (sum == target)
            {
                return {l + 1, r + 1};
            }
            else if (sum > target)
            {
                r--;
            }
            else
            {
                l++;
            }
        }
        return {0, 0};
    }
};
```

## 同向双指针

### 539 · Move Zeroes

```
class Solution {
public:
    void  moveZeroes(vector<int> &nums) {
        int m = nums.size();
        int l = 0;
        int r = 0;
        while (r < m)
        {
            if (nums[r] != 0)
            {
                swap(nums[l], nums[r]);
                l++;
            }
            r++;
        }
    }
};
```
```python
from typing import (
    List,
)

class Solution:
    def move_zeroes(self, nums: List[int]):
        m = len(nums)
        l, r = 0, 0
        while r < m:
            if nums[r] != 0:
                nums[r], nums[l] = nums[l], nums[r]
                l += 1
                r += 1
            elif nums[r] == 0:
                r += 1
```

## 相向双指针
### 443 · Two Sum - Greater than target
相向双指针
```
class Solution {
public:
    int twoSum2(vector<int> &nums, int target) {
        int m = nums.size();
        sort (nums.begin(), nums.end());
        int l = 0;
        int r = m - 1;
        int res = 0;

        while (l < r)
        {
            int sum = nums[l] + nums[r];
            if (sum > target)
            {
                res += r - l;
                r--;
            }
            else
            {
                l++;
            }
        }
        return res;
    }
};
```
## 根据大小找数
### 533 · Two Sum - Closest to target
```
class Solution {
public:
    int twoSumClosest(vector<int> &nums, int target) {
        int m = nums.size();
        sort(nums.begin(), nums.end());
        int l = 0;
        int r = m - 1;
        int res = 0x3f3f3f3f;
        while (l < r)
        {
            int t = nums[l] + nums[r];
            res = min(res, abs(target - t));
            if (t == target)
                return 0;
            else if (t > target)
                r--;
            else
                l++;
        }
        return res;
    }
};
```

## 滑动窗口

模板

```
int fixedWindow(string s, int k) { // k为固定窗口长度
    int n = s.size();
    int left = 0, right = 0;
    int windowSum = 0; // 窗口内的统计值（如和、计数等）
    int result = 0;

    // 初始化第一个窗口（[0, k-1]）
    while (right < k) {
        windowSum += s[right] - '0'; // 示例：累加数字
        right++;
    }
    result = windowSum; // 记录初始窗口的结果

    // 滑动窗口：每次右移一位，同时左移一位
    while (right < n) {
        windowSum += s[right] - '0'; // 加入右边界新元素
        windowSum -= s[left] - '0';  // 移除左边界旧元素
        right++;
        left++;
        result = max(result, windowSum); // 更新结果
    }
    return result;
}
```

```
int longestValidWindow(string s) {
    int n = s.size();
    int left = 0, right = 0;
    unordered_map<char, int> window; // 记录窗口内元素的状态
    int result = 0;

    while (right < n) {
        char c = s[right];
        right++; // 右指针右移，扩展窗口
        window[c]++; // 更新窗口状态

        // 当窗口不符合条件时（如出现重复字符），收缩左边界
        while (window[c] > 1) { // 条件：当前字符重复
            char d = s[left];
            left++; // 左指针右移，收缩窗口
            window[d]--; // 更新窗口状态
        }

        // 此时窗口符合条件，计算长度并更新最大值
        result = max(result, right - left);
    }
    return result;
}
```

```
string shortestValidWindow(string s, string t) {
    int n = s.size();
    int left = 0, right = 0;
    unordered_map<char, int> target; // 目标字符的需求（如t中各字符的数量）
    unordered_map<char, int> window; // 当前窗口中各字符的数量
    int match = 0; // 已满足需求的字符种类数
    int start = 0, minLen = INT_MAX;

    // 初始化目标需求
    for (char c : t) target[c]++;

    while (right < n) {
        char c = s[right];
        right++; // 右指针右移，扩展窗口
        if (target.count(c)) { // 若当前字符是目标字符，更新窗口状态
            window[c]++;
            if (window[c] == target[c]) { // 该字符的数量已满足需求
                match++;
            }
        }

        // 当窗口已满足所有需求时，尝试收缩左边界以找到更短的窗口
        while (match == target.size()) {
            // 更新最短窗口
            if (right - left < minLen) {
                start = left;
                minLen = right - left;
            }
            // 收缩左边界
            char d = s[left];
            left++;
            if (target.count(d)) { // 若移除的是目标字符，检查是否仍满足需求
                if (window[d] == target[d]) {
                    match--; // 该字符的数量不再满足需求
                }
                window[d]--;
            }
        }
    }

    return minLen == INT_MAX ? "" : s.substr(start, minLen);
}
```



### 1631 · Interesting Subarray

```
class Solution {
public:
    int maxLen(vector<int> &a) {
        if (a.empty())
            return 1;
        int m = a.size();
        int res = 0;
        int l = 0;
        unordered_map<int, int> counter;
        for (int r = 0; r < m; r++)
        {
            counter[a[r]]++;
            while (l < r && counter.size() > 2)
            {
                counter[a[l]]--;
                if(!counter[a[l]])
                    counter.erase(a[l]);
                l++;   
            }
            res = max(res, r - l + 1);
        }
        return res;
    }
};
```

### 384 · Longest Substring Without Repeating Characters

```
class Solution {
public:
    int lengthOfLongestSubstring(string &s) {
        int m = s.size();
        int j = 0;
        int res = 0;
        unordered_map<char, int> hash;
        for (int i = 0; i < m; i++)
        {
            while (j < m && !hash.count(s[j]))
            {
                hash[s[j]]++;
                j++;
            }
            res = max(res, (int)hash.size());
            if (hash[s[i]])
            {
                hash[s[i]]--;
                if (!hash[s[i]])
                    hash.erase(s[i]);
            }
        }
        return res;
    }
};
```

### 386 · Longest Substring with At Most K Distinct Characters

```
class Solution {
public:
    int lengthOfLongestSubstringKDistinct(string &s, int k) {
        int m = s.length();
        int sum = 0;
        int res = 0;
        unordered_map<char, int> hash;
        for (int r = 0, l = 0; r < m; r++)
        {
            hash[s[r]]++;
            if (hash[s[r]] == 1)
            {
                sum++;
            }
            while (sum > k)
            {
                if (hash[s[l]])
                {
                    hash[s[l]]--;
                }
                if (!hash[s[l]])
                {
                    sum--;
                }
                l++;
            }
            res = max(res, r - l + 1);
        }
        return res;
    }
};
```

### 32 · Minimum Window Substring

```
class Solution {
public:
    string minWindow(string &source , string &target) {
        int m = source.length();
        int n = target.length();
        unordered_map<char, int> shash;
        unordered_map<char, int> thash;
        for (auto t : target)
        {
            thash[t]++;
        }

        int sum = 0;
        int l = 0;
        string res;
        for (int r = 0; r < m; r++)
        {
            shash[source[r]]++;
            if (thash.count(source[r]) && shash[source[r]] <= thash[source[r]])
                sum++;
            while (shash[source[l]] > thash[source[l]]) 
            {
                shash[source[l++]]--;
            }
            if (sum == n)
            {
                if (res.empty() || res.length() > r - l + 1)
                {
                    res = source.substr(l, r - l + 1);
                }
            }
        }
        return res;
    }
};
```

### 1643 · Pick Fruits

```
class Solution {
public:
    int pickFruits(vector<int> &arr) {
        if (arr.empty())
            return 1;
        int m = arr.size();
        unordered_map<int, int> hash;
        int count = 0;
        int res = 0;
        for (int r = 0, l = 0; r < m; r++)
        {
            hash[arr[r]]++;
            if (hash[arr[r]] == 1)
            {
                count++;
            }
            while (count > 2)
            {
                hash[arr[l]]--;
                if (hash[arr[l]] == 0)
                {
                    count--;
                }
                l++;
            }
            res = max(res, r - l + 1);
        }
        return res;
    }
};
```

### 647 · Find All Anagrams in a String  （*）

```
class Solution {
public:
    vector<int> findAnagrams(string &s, string &p) {
        int m = s.size();
        int n = p.size();

        unordered_map<char, int> hash;
        for (auto c : p)
        {
            hash[c]++;
        }
        int match = 0;
        int start = 0;
        int end = 0;
        vector<int> res;
        while(end <= m)
        {
            if (hash[s[end]] >= 1)
                match++;
            hash[s[end]]--;
            end++;
            if (match == n)
                res.push_back(start);
            if (end - start == n)
            {
                if (hash[s[start]] >= 0)
                {
                    match--;
                }
                hash[s[start]]++;
                start++;
            }
        }
        return res;
    }
};
```

### 1375 · Substring With At Least K Distinct Characters

```
class Solution {
public:
    long long kDistinctCharacters(string &s, int k) {
        int m = s.size();
        unordered_map<char, int> hash;
        int j = 0;
        long long res = 0;
        for (int i = 0; i < m; i++)
        {
            while (j < m && hash.size() < k)
            {
                hash[s[j]]++;
                j++;
            }
            if (hash.size() >= k)
            {
                res += m - j + 1;
            }
            if (hash[s[i]])
            {
                hash[s[i]]--;
                if (hash[s[i]] == 0)
                {
                    hash.erase(s[i]);
                }
            }
        }
        return res;
    }
};
```

### 386 · Longest Substring with At Most K Distinct Characters

同向双指针

```
class Solution {
public:
    int lengthOfLongestSubstringKDistinct(string &s, int k) {
        if (k == 0)
            return 0;
        int m = s.size();
        int res = 0;
        int i = 0;
        unordered_map<char, int> hash;
        for (int j = 0; j < m; j++)
        {
            hash[s[j]]++;
            while (hash.size() > k)
            {
                if (hash[s[i]])
                {
                    hash[s[i]]--;
                    if (!hash[s[i]])
                    {
                        hash.erase(s[i]);
                    }
                    i++;
                }
            }
            res = max (res, j - i + 1);
        }
        return res;
    }
};
```

### 1169 · Permutation in String

```
class Solution {
public:
    bool isSame(vector<int>& l, vector<int>& r)
    {
        for (int i = 0; i < 26; i++)
        {
            if (l[i] != r[i])
                return false;
        }
        return true;
    }
    bool checkInclusion(string &s1, string &s2) {
        vector<int> hash(26, 0);
        vector<int> freq(26, 0);
        int n = s1.size();
        int m = s2.size();

        for (int i = 0; i < n; i++)
        {
            hash[s1[i] - 'a']++;
            freq[s2[i] - 'a']++;
        }
        if (isSame(hash, freq))
            return true;

        for (int i = 0; i + n < m; i++)
        {
            int j = i + n;
            freq[s2[i] - 'a']--;
            freq[s2[j] - 'a']++;
            if (isSame(hash, freq))
                return true;
        }
        return false;
    }
};
```

### 144 · Interleaving Positive and Negative Numbers将数据分到两边

```
    void rerange(vector<int> &a) {
        int m = a.size();
        int l = 0;
        int r = m - 1;
        int mid = 0;
        while (l < r && l < m && r >= 0)
        {
            if (a[mid] < 0)
            {
                l++; mid++;
            }
            else
            {
                swap(a[mid], a[r]);
                r--;
            }
        }
        for (auto c : a)
        {
            cout << c << endl;
        }
    }
```

# 前缀和
### 404 · 子数组求和 II
```c++
#include <numeric>
class Solution {
public:
    int subarraySumII(vector<int> &a, int start, int end) {
        int m = a.size();
        vector<int> sum(m + 1, 0);
        partial_sum(a.begin(), a.end(), sum.begin() + 1);

        int res = 0;
        for (int len = 1; len <= m; len++)
        {
            for (int i = 0; i < m - len + 1; i++)
            {
                int j = i + len - 1;
                int s = sum[j + 1] - sum[i];
                if (s <= end && s >= start)
                    res++;
            }
        }
        return res;
    }
};
```
```python
    def subarray_sum_i_i(self, a: List[int], start: int, end: int) -> int:
        m = len(a)
        S = [0 for _ in range(m + 1)]
        for i in range(1, m + 1):
            S[i] = S[i - 1] + a[i - 1]

        res = 0
        for L in range(1, m + 1):
            for i in range(m - L + 1):
                j = i + L - 1
                ps = S[j + 1] - S[i]
                if ps >= start and ps <= end:
                    res += 1
        return res
```


### 476 · Stone Game

# 单调栈 O(n)

给定一个长度为 N 的整数数列，**输出每个数左边第一个比它小的数**，如果不存在则输出 −1。

```
#include <iostream>
using namespace std;
const int N = 100010;
int stk[N], tt;

int main()
{
    int n;
    cin >> n;
    while (n -- )
    {
        int x;
        scanf("%d", &x);
        while (tt && stk[tt] >= x) tt -- ;//* 如果栈顶元素大于当前待入栈元素，则出栈
        if (!tt) printf("-1 ");//如果栈空，则没有比该元素小的值。
        else printf("%d ", stk[tt]);//栈顶元素就是左侧第一个比它小的元素。
        stk[ ++ tt] = x;
    }
    return 0;
}
```

### 1852 · Final Discounted Price

```
class Solution {
public:
    vector<int> FinalDiscountedPrice(vector<int> &prices) {
        int m = prices.size();
        stack<int> s;
        vector<int> res(m, 0);

        for (int i = 0; i < m; i++)
        {
            res[i] = prices[i];
        }

        for (int i = 0; i < m; i++)
        {
            while (!s.empty() && prices[s.top()] >= prices[i])
            {
                int index = s.top();
                s.pop();
                res[index] = prices[index] - prices[i];
            }
            s.push(i);
        }
        return res;
    }
};
```

### 122 · Largest Rectangle in Histogram

就是找某一个柱形左右连边小于他的柱形，以他们作为边界，中间的部分为最大矩形

```
class Solution {
public:
    int largestRectangleArea(vector<int> &heights) {
        if (heights.empty())
            return 0;
        int m = heights.size();
        stack<int> st;
        int res = 0;
        for (int i = 0; i <= m; i++)
        {
            int curheight = (i == m)? -1 : heights[i];
            while (!st.empty() && heights[st.top()] >= curheight)
            {
                int h = heights[st.top()]; st.pop();
                int w = st.empty()? i : (i - st.top() - 1);
                res = max(res, h * w);
            }
            st.push(i);
        }
        return res;
    }
};
```

### 1734 · Sum of Subarray Minimums

统计A种每个点是属于哪个子数组的最小值，只要找出i左边第一个比A[i]小的left，和右边第一个比A[i]小的right，所有left - right区间的子数组的最小值都是A[i]，这些子数组的个数是(i - left) * (right - i), 最后的和是(i - left) * (right - i) * A[i].
把所有的这些加到一起即为结果
相同的时候默认前面的比后边的小

```
class Solution {
public:
    int sumSubarrayMins(vector<int> &A) {
        int m = A.size();
        stack<int> fst;
        vector<int> fpos(m, 0);
        for (int i = 0; i < m; i++)
        {
            while(!fst.empty() && A[fst.top()] > A[i])
                fst.pop();
            if (fst.empty())
            {
                fpos[i] = -1;
            }
            else
            {
                fpos[i] = fst.top();
            }
            fst.push(i);
        }
        stack<int> bst;
        vector<int> bpos(m, 0);
        for (int i = m - 1; i >= 0; i--)
        {
            while(!bst.empty() && A[bst.top()] >= A[i])
                bst.pop();
            if (bst.empty())
            {
                bpos[i] = m;
            }
            else
            {
                bpos[i] = bst.top();
            }
            bst.push(i);
        }
        const long long MOD = 1e9 + 7;
        long long res = 0;
        for (int i = 0; i < m; i++)
        {
            long long finterval = i - fpos[i];
            long long binterval = bpos[i] - i;
            res += (long long)A[i] * finterval * binterval; 
            res %= MOD;
        }
        return (int)res % MOD;
    }
};
```

### 346 · xorsum of Interval extremum

以 [1, 3, 2] 为例总结下

[1] min = 1, max = 1, minXORmax = 0
[1, 3] min = 1, max = 3, minXORmax = 2
[1, 3, 2] min = 1, max = 3, minXORmax = 2
[3] min = 3, max = 3, minXORmax = 0
[3, 2] min = 2, max = 3, minXORmax = 1
[2] min = 2, max = 2, minXORmax = 0

0 xor 2 xor 2 xor 0 xor 1 xor 0 = 1

- 这个是按照题目要求做的计算，但实际这个计算本质上就是所有的min和所有的max在做一个全部的异或操作，没有先后顺序，这里面有*“四个1，五个3，三个2”*，只要把他们做一个大的异或即可
- 另一个问题是如果a ^ a = 0, 也就是在前面要异或的这些数里面如果有偶数个相同的数那么，这些偶数个数的异或结果是0，例如四个1的结果就是0，我们可以把这些结果是0的数字消掉，只计算奇数个数的数字异或。此例种我们只做2 ^ 3即可
- 对于第一个问题我们已经提到，我们只要求出所有排列的最小值和最大值，把这些数做异或即可，但是求法需要我们转换一下思路，我们要求nums[]里面每个数字，能够在多少子数组里面做最小值，以及能够在多少子数组里面做最大值。只要求出了这个，就相当于求出了第一问里面的 “四个1，五个3，三个2”， 这一步就相当于lintcode1734, 可以使用单调栈。例如计算nums[i]在多少子数组总做最小值，可以先计算nums[i]前面第一个比他小的数（因为再往前组成的子数组中，nums[i]已经不可能是最小值了）， 然后计算nums[i]后面第一个比他小的位置，最后这两个位置做一个排列计算(i - fmin[i]) * (pmin[i] - i)，即为以nums[i]为最小值的所有子数组。可以先做下lintcode1734题。
- 有了“四个1，五个3，三个2”， 就好办了，做一个循环，如果是奇数个数我们就res ^= nums[i];，偶数个直接略过即可

```
#include <functional>
class Solution {
public:
    void fstcalc(vector<int>& nums, vector<int>& vec, std::function<bool(int, int)> func)
    {
        int m = nums.size();
        stack<int> st;
        for (int i = 0; i < m; i++)
        {
            while(!st.empty() && func(nums[st.top()], nums[i]))
                st.pop();
            if (st.empty())
            {
                vec[i] = -1;
            }
            else
            {
                vec[i] = st.top();
            }
            st.push(i);
        }
    }
    void pstcalc(vector<int>& nums, vector<int>& vec, std::function<bool(int, int)> func)
    {
        int m = nums.size();
        stack<int> st;
        for (int i = m - 1; i >= 0; i--)
        {
            while(!st.empty() && func(nums[st.top()], nums[i]))
                st.pop();
            if (st.empty())
            {
                vec[i] = m;
            }
            else
            {
                vec[i] = st.top();
            }
            st.push(i);
        }
    }
    int XorSum(vector<int> &nums) {
        int m = nums.size();
        vector<int> fmin(m, 0);
        fstcalc(nums, fmin, [](int a, int b) -> bool { return a > b; });
        vector<int> pmin(m, 0);
        pstcalc(nums, pmin, [](int a, int b) -> bool { return a >= b; });
        vector<int> fmax(m, 0);
        fstcalc(nums, fmax, [](int a, int b) -> bool { return a < b; });
        vector<int> pmax(m, 0);
        pstcalc(nums, pmax, [](int a, int b) -> bool { return a <= b; });

        int res = 0;
        for (int i = 0; i < m; i++)
        {
            if (((i - fmin[i]) * (pmin[i] - i)) % 2)
            {
                res ^= nums[i];
            }

            if (((i - fmax[i]) * (pmax[i] - i)) % 2)
            {
                res ^= nums[i];
            }
        }

        return res;
    }
};
```

### 363 · Trapping Rain Water



# 单调队列

### 362 · Sliding Window Maximum （求滑动窗口中的最大值）

维护单调队列，可以对该队列进行各种查找，二分

```
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int> &nums, int k) {
        int m = nums.size();
        deque<int> dq;
        vector<int> res;
        for (int i = 0; i < m; i++)
        {
            // 弹出出窗的元素
            if (!dq.empty() && i - k + 1 > dq.front()) dq.pop_front();
            // 弹出比当前值小的元素，保证单调性
            while (!dq.empty() && nums[dq.back()] <= nums[i]) dq.pop_back();
            dq.push_back(i);
            if (i >= k - 1)
                res.push_back(nums[dq.front()]);
        }
        return res;
    }
};
```

# 二分查找

### 1219 · Heaters

target "<=" mid 返回的是左边第一个最大的，“>=”是右边第一个最小的 

带等号的用来判断有重复数字的序列

等号，当相等的时候，期望左端的值则r = mid, 期望右端的值l = mid

```
class Solution {
public:
    int getMinRadio(vector<int> &heaters, int house)
    {
        int m = heaters.size();
        int l = 0;
        int r = m - 1;
        while (l < r)
        {
            int mid = (l + r) / 2;
            if (heaters[mid] >= house)
            {
                r = mid;
            }
            else
            {
                l = mid + 1;
            }
        }
        int rpos = l;
        l = 0;
        r = m - 1;
        while (l < r)
        {
            int mid = (l + r + 1) / 2;
            if (heaters[mid] <= house)
            {
                l = mid;
            }
            else
            {
                r = mid - 1;
            }
        }
        int lpos = l;
        int lv = abs(heaters[lpos] - house);
        int rv = abs(heaters[rpos] - house);
        return lv < rv ? lv : rv;
    }
    int findRadius(vector<int> &houses, vector<int> &heaters) {
        sort(heaters.begin(), heaters.end());
        int m = houses.size();
        int res = 0;
        for (int i = 0; i < m; i++)
        {
            int dist = getMinRadio(heaters, houses[i]);
            res = max(res, dist);
        }
        return res;
    }
};
```

### 61 · Search for a Range

### 462 · Total Occurrence of Target

```
class Solution {
public:
    int totalOccurrence(vector<int> &A, int target) {
        if (A.empty())
            return 0;
        int m = A.size();
        int l = 0;
        int r = m - 1;
        while (l < r)
        {
            int mid = (l + r) / 2;
            if (A[mid] >= target)
            {
                r = mid;
            }
            else
            {
                l = mid + 1;
            }
        }

        if (A[l] != target)
            return 0;

        int left = l;
        l = 0;
        r = m - 1;
        while (l < r)
        {
            int mid = (l + r + 1) / 2;
            if (A[mid] <= target)
            {
                l = mid;
            }
            else
            {
                r = mid - 1;
            }
        }
        int right = r;

        return right - left + 1;
    }
};
```

STL 版

```
class Solution {
public:
    int totalOccurrence(vector<int> &A, int target) {
        if (A.empty())
            return 0;
        auto left  = std::lower_bound(A.begin(), A.end(), target);
        if (left == A.end())
            return 0;
        auto right = std::upper_bound(A.begin(), A.end(), target);
        return std::distance(left, right);
    }
};
```

### 74 · First Bad Version

```
    int binarySearch(int l, int r)
    {
        if (l > r) return INT_MAX;
        int mid = l + (r - l) / 2;
        if (SVNRepo::isBadVersion(mid)) 
            return std::min(mid, binarySearch(l, mid - 1));
        return binarySearch(mid + 1, r);
    }
```

### 585 · Maximum Number in Mountain Sequence

查找山峰山谷

```
class Solution {
public:
    bool check(vector<int>& nums, int mid)
    {
        int m = nums.size();
        if (mid + 1 < m)
        {
            if (nums[mid + 1] > nums[mid])
            {
                return false;
            }
        }
        return true;
    }
    int mountainSequence(vector<int> &nums) {
        int m = nums.size();
        int l = 0; 
        int r = m - 1;
        while (l < r)
        {
            int mid = (l + r) / 2;
            if (check(nums, mid))
            {
                r = mid;
            }
            else
            {
                l = mid + 1;
            }
        }
        return nums[l];
    }
};
```

### 159 · Find Minimum in Rotated Sorted Array

要和左端点比较

```
class Solution {
public:
    int findMin(vector<int> &nums) {
        int m = nums.size();
        int l = 0;
        int r = m - 1;

        while (l < r)
        {
            if (nums[l] <= nums[r])
                return nums[l];
            int mid = (l + r) / 2;
            if (nums[mid] < nums[l])
            {
                r = mid;
            }
            else
            {
                l = mid + 1;
            }
        }
        return nums[l];
    }
};
```

### 183 · Wood Cut

在结果值域上二分，check() 返回的是包含正确结果的check(带=的)，所以应该由l = mid或r= mid处理

```
class Solution {
public:
    bool check(vector<int> &L, long mid, int k)
    {
        long divide = 0;
        for (auto n : L)
        {
            divide += n / mid;
        }
        if (divide >= k)
        {
            return true;
        }

        return false;
    }
    int woodCut(vector<int> &L, int k) {
        if (L.empty())
            return 0;
        int len = L.size();
        long minVal = -9999999999;
        for (auto n : L)
        {
            if (n > minVal)
                minVal = n;
        }

        long l = 0;
        long r = minVal;

        while (l < r)
        {
            long mid = (l + r + 1) / 2;
            if (check(L, mid, k))
            {
               l = mid;
            }
            else
            {
                r = mid - 1;
            }
        }

        return l;
    }
};
```

### 438 · Copy Books II

```
class Solution {
public:
    bool check(int n, vector<int>& times, int mid)
    {
        int most = 0;
        for (auto t : times)
        {
            most += mid / t;
        }
        return n <= most;
    }
    int copyBooksII(int n, vector<int> &times) {
        int m = times.size();
        int mint = 0x3f3f3f3f;
        for (auto t : times)
        {
            mint = min(mint, t);
        }

        int l = 0;
        int r = mint * n;
        while (l < r)
        {
            int mid = (l + r) / 2;
            if (check(n, times, mid))
            {
                r = mid;
            }
            else
            {
                l = mid + 1;
            }
        }
        return l;
    }
};
```

## 二维二分

### 390 · Find Peak Element II

```
class Solution {
public:
    bool isPeak(const vector<vector<int>> &A, int i, int j) {
        return A[i][j] > A[i + 1][j] && A[i][j] > A[i - 1][j] && 
               A[i][j] > A[i][j + 1] && A[i][j] > A[i][j - 1];
    }
    int getLineMax(vector<vector<int>>& A, int line)
    {
        int idx = 0;
        int maxv = 0;
        int m = A[0].size();
        for (int i = 0; i < m; i++)
        {
            if (maxv < A[line][i])
            {
                maxv = A[line][i];
                idx = i;
            }
        }
        return idx;
    }
    vector<int> gpeak(vector<vector<int>>& A, int l, int r)
    {
        int m = A.size();
        int mid = (l + r) / 2;
        int lineMax = getLineMax(A, mid);
        if (isPeak(A, mid, lineMax))
        {
            return {mid, lineMax};
        }
        if (mid + 1 < m && A[mid][lineMax] >= A[mid + 1][lineMax])
        {
            return gpeak(A, l, mid - 1);
        }
        else
        {
            return gpeak(A, mid + 1, r);
        }
    }
    vector<int> findPeakII(vector<vector<int>> &A) {
        int m = A.size();
        int n = A[0].size();

        return gpeak(A, 1, m - 2);
    }
};
```

# 数学

## n次方 快速幂

### 428 · Pow(x, n)   50. Pow(x, n)

```
// 如果x^(n/2)，即x的一半，是偶数，x^n = y * y
// 如果x^(n/2)，即x的一半，是奇数，x^n = y * y * x
class Solution {
public:
    double quickMul(double x, long long N) {
        if (N == 0) {
            return 1.0;
        }
        double y = quickMul(x, N / 2);
        return N % 2 == 0 ? y * y : y * y * x;
    }

    double myPow(double x, int n) {
        long long N = n;
        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
    }
};
```

```
class Solution {
public:
    double myPow(double x, int n) {
        unsigned int N = abs(n);
        double res = 1;
        double cur = x;
        while (N > 0)
        {
            if (N & 1)
            {
                res *= cur;
            }
            cur *= cur;
            N >>= 1;
        }
        return n < 0 ? 1.0 / res: res;
    }
};
```

## 质数

### 1324 · Count Primes

```
class Solution {
public:
    vector<int> primes;
    int cnt = 0;   
    bool st[2000000];     
    int res = 0;
    Solution(): primes(2000000, 0) {}

    void get_primes(int n)
    {
        for (int i = 2; i <= n; i ++ )
        {
            if (!st[i]) 
            {
                primes[cnt ++ ] = i;
            }
            for (int j = 0; primes[j] <= n / i; j ++ )
            {
                st[primes[j] * i] = true;
                if (i % primes[j] == 0) break;
            }
        }
    }

    int countPrimes(int n) {
        get_primes(n);

        for (auto c : primes)
            if (c != 0 && c != n)
                res++;
        return res;
    }
};
```

## 高精度

```
// C = A + B, A >= 0, B >= 0
vector<int> add(vector<int> &A, vector<int> &B)
{
    if (A.size() < B.size()) return add(B, A);

    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i ++ )
    {
        t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }

    if (t) C.push_back(t);
    return C;
}
```

### 2. Add Two Numbers

# 并查集

### 1179 · Friend Circles

```
class Solution {
public:
    int find(vector<int>& p, int x)
    {
        if (p[x] != x) p[x] = find(p, p[x]);
        return p[x];
    }
    int findCircleNum(vector<vector<int>> &M) {
        if (M.empty())
            return 0;
        int m = M.size();
        int n = M[0].size();
        vector<int> p(m);
        for (int i = 0; i < m; i++)
        {
            p[i] = i;
        }

        for (int i = 0; i < m; i++)
        {
            for (int j = i + 1; j < n; j++)
            {
                if (M[i][j] == 1)
                {
                    p[find(p, i)] = find(p, j);
                }
            }
        }

        set<int> resset;
        for (int i = 0; i < m; i++)
        {
            resset.insert(find(p, i));
        }

        return resset.size();
    }
};
```

### 677 · Number of Big Islands

计算size的模板

```
class Solution {
public:
    int p[90000] = {0};
    int size[90000] = {0};
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
            return p[x];
    }
    int getIndex(int x, int y, int n)
    {
        return x * n + y;
    }
    bool inBound(int x, int y, int m, int n)
    {
        if (x >= m || y >= n || x < 0 || y < 0)
            return false;
        return true;
    }
    int numsofIsland(vector<vector<bool>> &grid, int k) {
        if (grid.empty())
            return 0;
        int m = grid.size();
        int n = grid[0].size();

        int dx[4] = {1, 0, -1, 0};
        int dy[4] = {0, 1, 0, -1};

        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                p[getIndex(i, j, n)] = getIndex(i, j, n);
                if (grid[i][j])
                    size[getIndex(i, j, n)] = 1;
            }
        }

        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (!grid[i][j])
                    continue;
                for (int k = 0; k < 4; k++)
                {
                    int nx = i + dx[k];
                    int ny = j + dy[k];

                    if (!inBound(nx, ny, m, n))
                        continue;

                    if (grid[nx][ny] == true)
                    {
                        if (find(getIndex(i, j, n)) != find(getIndex(nx, ny, n)))
                        {
                            size[find(getIndex(nx, ny, n))] += size[find(getIndex(i, j, n))];
                            size[find(getIndex(i, j, n))] = 0;
                            p[find(getIndex(i, j, n))] = find(getIndex(nx, ny, n));
                        }
                    }
                }
            }
        }
        int res = 0;
        int maxInd = getIndex(m - 1, n - 1, n);
        for (int i = 0; i <= maxInd; i++)
        {
            if (size[i] >= k)
                res++;   
        }

        return res;
    }
};
```

### 805 · Maximum Association Set

字符并查集

```
class UnionFind {
public:
    unordered_map<string, string> m;
    UnionFind(){}

    /*
    string find(string s) {
        if (m[s] != s) {
            m[s] = find(m[s]);
        }
        return m[s];
    }
    */

    string find(string s) {
        while (m.find(s) != m.end()) {
            s = m[s];
        }
        return s;
    }

    vector<string> getAnswer() {
        vector<string> ans;
        unordered_map<string, unordered_set<string>> temp;
        for (auto a : m) {
            string s = find(a.first);
            temp[s].insert(a.first);
            temp[s].insert(s);
        }
        for (auto a : temp) {
            if (a.second.size() > ans.size()) {
                ans = vector<string>(a.second.begin(), a.second.end());
            }
        }
        return ans;
    }

    void connect(string s1, string s2) {
        string ss1 = find(s1);
        string ss2 = find(s2);

        if (ss1 == ss2) return;
        if (ss1 < ss2) {
            m[ss1] = ss2;
        } else {
            m[ss2] = ss1;
        }
    }
};

class Solution {
public:
    vector<string> maximumAssociationSet(vector<string> &ListA, vector<string> &ListB) {
        UnionFind uf;
        for (int i = 0; i < ListA.size(); i++) {
            uf.connect(ListA[i], ListB[i]);
        }

        return uf.getAnswer();
    }
};
```

## 初始化 集合计算

### 434 · Number of Islands II

```
class Solution {
public:
    int p[100000];
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
    int index(int x, int y, int m)
    {
        return x * m + y;
    }
    vector<int> numIslands2(int n, int m, vector<Point> &operators) {
        if (operators.empty())
            return {};

        vector<int> res;
        unordered_set<int> nodes;
        int s = operators.size();
        unordered_set<int> current;
        int dx[4] = {0, 1, 0, -1};
        int dy[4] = {1, 0, -1, 0};
        int total = 0;
        for (int i = 0; i < s; i++)
        {
            int pos = index(operators[i].x, operators[i].y, m);
            nodes.insert(pos);
            if (current.count(pos))
            {
                res.push_back(total);
                continue;
            }
            total++;
            p[pos] = pos;
            for (int j = 0; j < 4; j++)
            {
                int nx = operators[i].x + dx[j];
                int ny = operators[i].y + dy[j];
                if (!(nx >= 0 && nx < n && ny >= 0 && ny < m)) 
                    continue;
                if (current.count(index(nx, ny, m)))
                {
                    int apos = index(operators[i].x, operators[i].y, m);
                    int bpos = index(nx, ny, m);
                    if (find(apos) != find(bpos))
                    {
                        p[find(apos)] = find(bpos);
                        total--;
                    }
                }
            }

            current.insert(index(operators[i].x, operators[i].y, m));
            res.push_back(total);
        }

        return res;
    }
};
```

## Size计算

### 590 · Connecting Graph II

1. if (find(a) == find(b)) 

2. size[find(b)] += size[find(a)];  // 顺序相反
   
         p[find(a)] = find(b);

3. size[i] = 1;

4. return size[find(a)];
   
   ```
   class ConnectingGraph2 {
   public:
    int p[100000];
    int size[100000];
    ConnectingGraph2(int n) {
        for (int i = 0; i <= n; i++)
        {
            p[i] = i;
            size[i] = 1;
        }
    }
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
   
    void connect(int a, int b) {
        if (find(a) == find(b)) 
            return;
        size[find(b)] += size[find(a)];
        p[find(a)] = find(b);
    }
   
    int query(int a) {
        return size[find(a)];
    }
   };
   ```

# 图论

## DFS

### 1514 · Robot Room Cleaner

```
class Solution {
public:
    void restore(Robot& robot)
    {
        robot.turnRight();
        robot.turnRight();
        robot.move();
        robot.turnRight();
        robot.turnRight();
    }
    void dfs(Robot& robot, int x, int y, set<pair<int, int>>& visit, int dirction)
    {
        int dx[4] = {-1, 0, 1, 0};
        int dy[4] = {0, 1, 0, -1};
        robot.clean();
        for (int i = 0; i < 4; i++)
        {
            int nx = x + dx[dirction];
            int ny = y + dy[dirction];
            if (visit.count({nx, ny}))
            {
                dirction = (dirction + 1) % 4;
                robot.turnRight();
                continue;
            }

            if (robot.move())
            {
                visit.insert({nx, ny});
                dfs(robot, nx, ny, visit, dirction);
                restore(robot);
            }
            dirction = (dirction + 1) % 4;
            robot.turnRight();
        }
    }
    void cleanRoom(Robot& robot) {
        set<pair<int, int>> visit;
        visit.insert({0, 0});
        dfs(robot, 0, 0, visit, 0);
    }
};
```

## BFS

### 611 · Knight Shortest Path

```
class Solution {
public:
    bool isNotOut(int x, int y, int m, int n)
    {
        if (x >= m || y >= n || x < 0 || y < 0)
            return false;
        return true;
    }
    int shortestPath(vector<vector<bool>> &grid, Point &source, Point &destination) {
        int m = grid.size();
        int n = grid[0].size();

        int dx[8] = {1, 1, -1, -1, 2, 2, -2, -2};
        int dy[8] = {2, -2, 2, -2, 1, -1, 1, -1};
        vector<vector<bool>> visit(m, vector<bool>(n, false));
        queue<Point> q;
        q.push(source);

        int step = 0;
        while (!q.empty())
        {
            int levelnum = q.size();
            step++;
            while (levelnum--)
            {
                auto cur = q.front(); q.pop();
                if (cur.x == destination.x && cur.y == destination.y)
                    return step-1;
                for (int i = 0; i < 8; i++)
                {
                    int nx = cur.x + dx[i];
                    int ny = cur.y + dy[i];

                    if (isNotOut(nx, ny, m, n) && !visit[nx][ny] && !grid[nx][ny])
                    {
                        q.push(Point(nx, ny));
                        visit[nx][ny] = true;
                    }
                }
            }
        }

        return -1;
    }
};
```

### 137 · Clone Graph

```
// DFS
class Solution {
public:
    UndirectedGraphNode* dfs(UndirectedGraphNode* node, unordered_map<int, UndirectedGraphNode*>& visit)
    {
        if (!node)
            return nullptr;

        auto it = visit.find(node->label);
        if (it == visit.end())
        {
            UndirectedGraphNode* current = new UndirectedGraphNode(node->label);
            visit.insert(make_pair(current->label, current));
            for (auto c : node->neighbors)
            {
                UndirectedGraphNode* child = dfs(c, visit);
                current->neighbors.push_back(child);
            }
        }

        return visit[node->label];
    }

    UndirectedGraphNode* cloneGraph(UndirectedGraphNode* node) {
        if (!node)
        {
            return nullptr;
        }

        unordered_map<int, UndirectedGraphNode*> visit;
        return dfs(node, visit);
    }
};

// BFS
class Solution {
public:
    UndirectedGraphNode* cloneGraph(UndirectedGraphNode* node) {
        if (!node)
        {
            return nullptr;
        }
        unordered_map<UndirectedGraphNode*, UndirectedGraphNode*> nodeMap;
        queue<UndirectedGraphNode*> q;
        nodeMap.insert(make_pair(node, new UndirectedGraphNode(node->label)));
        q.push(node);
        while (!q.empty())
        {
            auto cur = q.front(); q.pop();
            for (auto c : cur->neighbors)
            {
                auto it = nodeMap.find(c);
                if (it == nodeMap.end())
                {
                    UndirectedGraphNode* tmpnode = new UndirectedGraphNode(c->label);
                    nodeMap.insert(make_pair(c, tmpnode));
                    nodeMap[cur]->neighbors.push_back(tmpnode);
                    q.push(c);
                }
                else
                {
                    nodeMap[cur]->neighbors.push_back(nodeMap[c]);
                }
            }
        }

        return nodeMap[node];
    }
};
```

### DFS BFS 标准模板题 1563 · Shortest path to the destination

DFS

```
class Solution {
public:
    bool isInBound(int x, int y, int m, int n)
    {
        if (x >= m || x < 0 || y >= n || y < 0)
            return false;
        return true;
    }
    void dfs(vector<vector<int>> &targetMap, vector<vector<bool>> &vis, int x, int y, int current, int& res)
    {
        if (targetMap[x][y] == 2)
        {
            res = min (res, current);
            return;
        }
        int dx[4] = {1,  0, -1, 0};
        int dy[4] = {0, -1,  0, 1};
        int m = targetMap.size();
        int n = targetMap[0].size();
        for (int i = 0; i < 4; i++)
        {
            int nx = x + dx[i];
            int ny = y + dy[i];

            if (isInBound(nx, ny, m, n) && !vis[nx][ny] && targetMap[nx][ny] != 1)
            {
                vis[nx][ny] = true;
                dfs(targetMap, vis, nx, ny, current + 1, res);
                vis[nx][ny] = false;
            }
        }
    }
    int shortestPath(vector<vector<int>> &targetMap) {
        int res = INT_MAX;
        int m = targetMap.size();
        int n = targetMap[0].size();
        vector<vector<bool>> vis(m + 1, vector<bool>(n + 1, false));
        dfs(targetMap, vis, 0, 0, 0, res);
        return res == INT_MAX? -1: res;
    }
};
```

BFS

```
class Solution {
public:
    bool isInBound(int x, int y, int m, int n)
    {
        if (x >= m || x < 0 || y >= n || y < 0)
            return false;
        return true;
    }
    int shortestPath(vector<vector<int>> &targetMap) {
        int m = targetMap.size();
        int n = targetMap[0].size();
        int dx[4] = {1,  0, -1, 0};
        int dy[4] = {0, -1,  0, 1};
        vector<vector<bool>> visit(m, vector<bool>(n, false));
        queue<pair<int, int>> q;
        q.push(make_pair(0, 0));
        visit[0][0] = true;
        int step = 0;
        while (!q.empty())
        {
            int levelcount = q.size();
            while(levelcount--)
            {
                auto cur = q.front(); q.pop();
                if (targetMap[cur.first][cur.second] == 2)
                    return step;
                for (int i = 0; i < 4; i++)
                {
                    int nx = cur.first + dx[i];
                    int ny = cur.second + dy[i];
                    if (isInBound(nx, ny, m, n) && !visit[nx][ny] && targetMap[nx][ny] != 1)
                    {
                        q.push(make_pair(nx, ny));
                        visit[nx][ny] = true;
                    }
                }
            }
            step++;
        }
        return -1;
    }
};
```

### BFS记录路径的方法

```
from collections import deque

def bfs_find_path(grid, start, end):
    # 边界检查
    if not grid or not grid[0]:
        return []
    rows, cols = len(grid), len(grid[0])
    # 方向：上下左右
    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    # 1. 初始化数据结构
    visited = [[False for _ in range(cols)] for _ in range(rows)]
    prev = {}  # 键：(x,y)，值：父节点(x,y)
    q = deque()
    
    # 起点入队
    start_x, start_y = start
    end_x, end_y = end
    q.append((start_x, start_y))
    visited[start_x][start_y] = True
    found = False
    
    # 2. BFS遍历 + 记录前驱
    while q and not found:
        x, y = q.popleft()
        # 遍历四个方向
        for dx, dy in dirs:
            nx, ny = x + dx, y + dy
            # 检查边界、是否可走、是否未访问
            if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 0 and not visited[nx][ny]:
                prev[(nx, ny)] = (x, y)  # 记录前驱
                visited[nx][ny] = True
                q.append((nx, ny))
                # 找到终点，终止遍历
                if (nx, ny) == (end_x, end_y):
                    found = True
                    break
    
    # 3. 回溯前驱生成路径
    path = []
    if found:
        # 从终点回溯到起点
        curr = (end_x, end_y)
        while curr != (start_x, start_y):
            path.append(curr)
            curr = prev[curr]
        path.append(start)  # 加入起点
        path.reverse()  # 反转得到正序路径
    return path

# 测试用例
if __name__ == "__main__":
    # 迷宫：0可走，1障碍
    grid = [
        [0, 1, 0, 0, 0],
        [0, 1, 0, 1, 0],
        [0, 0, 0, 1, 0],
        [1, 1, 1, 1, 0],
        [0, 0, 0, 0, 0]
    ]
    start = (0, 0)
    end = (4, 4)
    path = bfs_find_path(grid, start, end)
    print("最短路径：", path)
```

### 1446 · 01 Matrix Walking Problem

## 拓扑排序

### 605 · 序列重构

```
class Solution {
public:
    bool sequenceReconstruction(vector<int> &org, vector<vector<int>> &seqs) {
        if (org.empty() && seqs.empty())
            return true;
        if (!org.empty() && seqs.empty())
            return false;
        if (org.empty() && !seqs.empty() && seqs[0].empty())
            return true;

        int m = org.size();
        
        std::map<int, int> indegree;
        std::unordered_map<int, vector<int>> G;
        for (auto o : org)
        {
            indegree[o] = 0;
            G[o] = {};
        }

        for (auto s : seqs)
        {
            int len = s.size();
            if (len == 0)
                return false;
            for (int i = 0; i < len; i++)
            {
                if (!indegree.count(s[i]))
                    return false;
                if (i + 1 >= len)
                    continue;
                G[s[i]].push_back(s[i + 1]);
                indegree[s[i + 1]]++;
            }
        }
        queue<int> q;
        for (auto i : indegree)
        {
            if (!i.second)
                q.push(i.first);
        }

        vector<int> res;
        while (!q.empty())
        {
            if (q.size() != 1)
                return false;
            auto cur = q.front(); q.pop();
            res.push_back(cur);
            for (auto n : G[cur])
            {
                indegree[n]--;
                if (!indegree[n])
                    q.push(n);
            }
        }
        return res == org;
    }
};
```



### 127 · Topological Sorting

```
class Solution {
public:
    vector<DirectedGraphNode*> topSort(vector<DirectedGraphNode*> graph) {
        if (graph.empty())
            return {};
        unordered_map<DirectedGraphNode*, int> inDegree;
        for (auto n : graph)
        {
            auto it = inDegree.find(n);
            if (it == inDegree.end())
                inDegree[n] = 0;
            for (auto outn : n->neighbors)
            {
                inDegree[outn]++;
            }
        }

        queue<DirectedGraphNode*> q;
        for (auto n : inDegree)
        {
            //cout << n.first->label << " " << n.second << endl;
            if (n.second == 0)
            {

                q.push(n.first);
            }
        }
        vector<DirectedGraphNode*> res;
        while (!q.empty())
        {
            auto cur = q.front(); q.pop();
            res.push_back(cur);
            for (auto c : cur->neighbors)
            {
                if (!(--inDegree[c]))
                    q.push(c);
            }
        }

        return res;
    }
};
```

### 615 · Course Schedule

### 616 · Course Schedule II

```
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<pair<int, int>> &prerequisites) {
        unordered_map<int, vector<int>> g;
        unordered_map<int, int> inDegree;
        for (int i = 0; i < numCourses; i++)
        {
            inDegree[i] = 0;
        }

        for (auto n : prerequisites)
        {
            g[n.second].push_back(n.first);
            inDegree[n.first]++;
        }

        queue<int> q;
        for (auto n : inDegree)
        {
            if (!n.second)
            {
                q.push(n.first);
            }
        }

        vector<int> res;
        while (!q.empty())
        {
            auto cur = q.front(); q.pop();
            res.push_back(cur);

            for (auto n : g[cur])
            {
                if (!(--inDegree[n]))
                {
                    q.push(n);
                }
            }
        }

        return (res.size() != numCourses) ? vector<int>() : res;
    }
};
```

## 爆搜

### 33 · N-Queens

```
class Solution {
public:
    /*
     * @param n: The number of queens
     * @return: All distinct solutions
     */
    void dfs(int r, int n, vector<string>& path, vector<vector<string>>& res)
    {      
        if (r == n)
        {
            res.push_back(path);
            return;
        }
        for (int i = 0; i < n; i++)
        {
            if (!col[i] && !row[i] && !dg[r + i] && !udg[r - i + n])
            {
                path[r][i] = 'Q';
                col[i] = row[i] = dg[r + i] = udg[r - i + n] = true;
                dfs(r + 1, n, path, res);
                path[r][i] = '.';
                col[i] = row[i] = dg[r + i] = udg[r - i + n] = false;
            }
        }
    }
    vector<bool> col;
    vector<bool> row;
    vector<bool> dg;
    vector<bool> udg;
    vector<vector<string>> solveNQueens(int n) {
        if (!n)
            return {};
        vector<bool> lcol(n, false);
        vector<bool> lrow(n, false);
        vector<bool> ldg(2 * n, false);
        vector<bool> ludg(2 * n, false);
        col = lcol;
        row = lrow;
        dg = ldg;
        udg = ludg;

        vector<vector<string>> res;
        vector<string> path(n, string(n, '.'));

        dfs(0, n, path, res);
        return res;
    }
};
```

### 802 · Sudoku Solver

```
class Solution {
public:
    /**
     * @param board: the sudoku puzzle
     * @return: nothing
     */
    bool col[9][10]; 
    bool row[9][10];
    bool cell[3][3][10];
    bool dfs(vector<vector<int>>& board, int x, int y)
    {
        //cout << x << " " << y << endl;
        if (y == 9) 
        {
            x++;
            y = 0;
        }
        if (x == 9)
        {
            return true;
        }

        if (board[x][y] != 0)
            return dfs(board, x, y + 1);

        for (int i = 0; i < 9; i++)
        {
            if (!col[x][i] && !row[y][i] && !cell[x / 3][y / 3][i])
            {
                board[x][y] = i + 1;
                col[x][i] = true; row[y][i] = true; cell[x / 3][y / 3][i] = true;
                if (dfs(board, x, y + 1))
                    return true;
                board[x][y] = 0;
                col[x][i] = false; row[y][i] = false; cell[x / 3][y / 3][i] = false;
            }
        }
        return false;
    }
    void solveSudoku(vector<vector<int>> &board) {

        memset(col, 0, 9 * 10 * sizeof(bool));
        memset(row, 0, 9 * 10 * sizeof(bool));
        memset(cell, 0, 3 * 3 * 10 * sizeof(bool));
        for (int i = 0; i < 9; i++)
        {
            for (int j = 0; j < 9; j++)
            {
                if (board[i][j] != 0)
                {
                    col[i][board[i][j] - 1] = true;
                    row[j][board[i][j] - 1] = true;
                    cell[i / 3][j / 3][board[i][j] - 1] = true;
                }
            }
        }

        dfs(board, 0, 0);

    }
};
```

## SPFA

以bfs为基础，把选择条件换成只要距离更新了就入队

### 1565 · Modern Ludo I

```
class Solution {
public:
    int modernLudo(int length, vector<vector<int>> &connections) {
        int m = connections.size();
        vector<int> st(length + 1, 0);
        queue<int> q;
        q.push(1);
        st[1] = true;
        vector<int> dist(length + 1, INT_MAX);
        dist[1] = 0;
        while (!q.empty())
        {
            auto cur = q.front(); q.pop();
            st[cur] = false;
            for (auto e : connections)
            {
                if (e[0] == cur)
                {
                    if (dist[e[1]] > dist[cur])  // dist[e[1]] > dist[cur] + 0
                    {
                        dist[e[1]] = dist[cur];
                        if (!st[e[1]])
                        {
                            q.push(e[1]);
                            st[e[1]] = true;
                        }
                    }
                }
            }
            for (int i = 1; i <= 6; i++)
            {
                auto target = cur + i;
                if (target > length)
                    break;
                if (dist[target] > dist[cur] + 1)
                {
                    dist[target] = dist[cur] + 1;
                    if (!st[target])
                    {
                        q.push(target);
                        st[target] = true;
                    }
                }
            }
        }

        return dist[length];
    }
};
```

### 1469 · Longest Path On The Tree(树的直径)

树的直径，就是从任一点开始找到最远距离点，再从这个最远距离点找另外一个最远距离点，这两点之间就是直径

```
class Solution {
public:
    void spfa(int n, unordered_map<int, vector<pair<int, int>>>& g, int start, int& maxindex, int& maxdist)
    {
        vector<bool> visit(n, false);
        vector<int> dist(n, 0x3f3f3f3f);
        queue<int> q;
        q.push(start);
        visit[start] = true;
        dist[start] = 0;
        while(!q.empty())
        {
            auto cur = q.front(); q.pop();
            visit[cur] = false;
            int m = g[cur].size();
            for (int i = 0; i < m; i++)
            {
                if (dist[g[cur][i].first] > dist[cur] + g[cur][i].second)
                {
                    dist[g[cur][i].first] = dist[cur] + g[cur][i].second;
                    if (maxdist < dist[g[cur][i].first])
                    {
                        maxdist  = dist[g[cur][i].first];
                        maxindex = g[cur][i].first;
                    }
                    if (!visit[g[cur][i].first])
                    {
                        q.push(g[cur][i].first);
                        visit[g[cur][i].first] = true;
                    }
                }
            }
        }
    }
    int longestPath(int n, vector<int> &starts, vector<int> &ends, vector<int> &lens) {
        unordered_map<int, vector<pair<int, int>>> g;
        int m = starts.size();
        for (int i = 0; i < n - 1; i++)
        {
            g[starts[i]].push_back({ends[i], lens[i]});
            g[ends[i]].push_back({starts[i], lens[i]});
        }

        int maxi = 0;
        int maxd = 0;
        spfa(n, g, 0, maxi, maxd);
        spfa(n, g, maxi, maxi, maxd);
        return maxd;
    }
};
```

### 1862 · Time to Flower Tree

```
class Solution {
public:
    int timeToFlowerTree(vector<int> &father, vector<int> &time) {
        set<tuple<int, int, int>> edges;
        int m = father.size();
        for (int i = 1; i < m; i++)
        {
            edges.insert({father[i], i, time[i]});
        }
        vector<int> dist(m, 0x3f3f3f3f);
        dist[0] = 0;
        queue<int> q;
        q.push(0);
        vector<bool> visit(m, false);
        visit[0] = true;
        while (!q.empty())
        {
            auto cur = q.front(); q.pop();
            visit[cur] = false;
            for (auto e : edges)
            {
                if (get<0>(e) != cur)
                    continue;
                if (dist[get<1>(e)] > dist[cur] + get<2>(e))
                {
                    dist[get<1>(e)] = dist[cur] + get<2>(e);
                    if (!visit[get<1>(e)])
                    {
                        q.push(get<1>(e));
                        visit[get<1>(e)] = true;
                    }
                }
            }
        }
        int res = 0;
        for (auto d : dist)
        {
            res = max(res, d);
        }

        return res;
    }
};
```

### 258 · Map Jump

```
class Solution {
public:
    int idx(int x, int y, int n)
    {
        return x * n + y;
    }
    bool isInBound(int x, int y, int m, int n)
    {
        if (x >= m || y >= n || x < 0 || y < 0)
            return false;
        return true;
    }
    int mapJump(vector<vector<int>> &arr) {
        int m = arr.size();
        int n = arr[0].size();
        int dx[4] = {0, 1, 0, -1};
        int dy[4] = {1, 0, -1, 0};
        vector<int>  dist(m * n, 0x3f3f3f3f);
        queue<pair<int, int>> q;
        q.push({0, 0});
        dist[idx(0, 0, n)] = 0;
        while (!q.empty())
        {
            auto cur = q.front(); q.pop();
            for (int i = 0; i < 4; i++)
            {
                int nx = cur.first  + dx[i];
                int ny = cur.second + dy[i];
                if (!isInBound(nx, ny, m, n))
                    continue;

                int h = max(dist[idx(cur.first, cur.second, n)], abs(arr[nx][ny] - arr[cur.first][cur.second]));
                if (dist[idx(nx, ny, n)] > h)
                {
                    dist[idx(nx, ny, n)] = h;
                    q.push({nx, ny});
                }
            }
        }
        return dist[idx(m - 1, n - 1, n)];

    }
};
```

### 1569 · Social Network

```
class Solution {
public:
    string socialNetwork(int n, vector<int> &a, vector<int> &b) {
        int m = a.size();
        unordered_map<int, unordered_set<int>> g;
        for (int i = 0; i < m; i++)
        {
            g[a[i]].insert(b[i]);
            g[b[i]].insert(a[i]);
        }

        vector<int> dist(n + 1, 0x3f3f3f3f);
        vector<bool> visit(n, false);
        queue<int> q;
        q.push(1);
        visit[1] = true;
        dist[1] = 0;
        while (!q.empty())
        {
            auto cur = q.front(); q.pop();
            visit[cur] = false;
            for (auto s : g[cur])
            {
                if (dist[s] >= dist[cur] + 1)
                {
                    dist[s] = dist[cur] + 1;
                    if (!visit[s])
                    {
                        q.push(s);
                        visit[s] = true;
                    }
                }
            }
        }

        for (int i = 1; i <= n; i++)
        {
            if (dist[i] == 0x3f3f3f3f)
                return "no";
        }
        return "yes";
    }
};
```

## Dijkstra

### 1057 · Network Delay Time

```
class Solution {
public:
    int networkDelayTime(vector<vector<int>> &times, int N, int K) {
        vector<vector<int>> g(N + 1, vector<int>(N + 1, 0x3f3f3f3f));
        for (auto e : times)
        {
            g[e[0]][e[1]] = min(g[e[0]][e[1]], e[2]);
        }
        vector<int> dist(N + 1, 0x3f3f3f3f);
        vector<bool> visit(N + 1, false);
        dist[K] = 0;
        for (int i = 0; i < N; i++)
        {
            int t = -1;
            for (int j = 1; j <= N; j++)
            {
                if (!visit[j] && (t == -1 || dist[t] > dist[j]))
                    t = j;
            }
            for (int j = 1; j <= N; j++)
            {
                if (dist[j] > dist[t] + g[t][j])
                {
                    dist[j] = dist[t] + g[t][j];
                }
            }
            visit[t] = true;
        }

        int res = 0;
        for (int i = 1; i <= N; i++)
        {
            if (dist[i] == 0x3f3f3f3f)
                return -1;
            res = max(res, dist[i]);
        }
        return res;
    }
};
```
## 记忆化搜索
### 582 · Word Break II

```
class Solution {
public:
    vector<string> dfs(string s, unordered_set<string> &dict, unordered_map<string, vector<string>>& memo)
    {
        if (memo.count(s))
        {
            return memo[s];
        }

        vector<string> res;
        if (s.empty())
        {
            return res;
        }

        if (dict.count(s))
        {
            res.push_back(s);
        }

        int m = s.size();
        for (int len = 1; len < m; len++)
        {
            string word = s.substr(0, len);
            if (!dict.count(word))
                continue;
            
            auto ret = dfs (s.substr(len), dict, memo);

            for (auto w : ret)
            {
                res.push_back(word + " " + w);
            }
        }
        memo.insert({s, res});
        return res;
    }
    vector<string> wordBreak(string &s, unordered_set<string> &wordDict) {
        unordered_map<string, vector<string>> memo;
        return dfs(s, wordDict, memo);
    }
};
```



### 192 · Wildcard Matching

```
class Solution {
public:
    bool dfs(string &s, int si, string &p, int pi, vector<vector<bool>>& visit, vector<vector<bool>>& memo)
    {
        int m = s.size();
        int n = p.size();
        if (pi == n)
        {
            return si == m;
        }

        if (si == m)
        {
            for (int i = pi; i < n; i++)
            {
                if (p[i] != '*')
                    return false;
            }
            return true;
        }

        if (visit[si][pi])
            return memo[si][pi];

        char sc = s[si];
        char pc = p[pi];
        bool match = false;
        if (pc == '*')
        {
            match = dfs(s, si, p, pi + 1, visit, memo) || 
                    dfs(s, si + 1, p, pi, visit, memo);
        }
        else
        {
            if (sc == pc || pc == '?')
            {
                match = dfs(s, si + 1, p, pi + 1, visit, memo);
            }
        }

        visit[si][pi] = true;
        memo[si][pi] = match;
        return match;
    }
    bool isMatch(string &s, string &p) {
        int m = s.size();
        int n = p.size();
        vector<vector<bool>> visit(m, vector<bool>(n, false));
        vector<vector<bool>> memo(m, vector<bool>(n, false));
        return dfs(s, 0, p, 0, visit, memo);
    }
};
```

### 114 · Unique Paths

```
class Solution {
public:
    bool isInBoundary(int x, int y, int m, int n)
    {
        if (x >= m || y >= n || x < 0 || y < 0)
            return false;
        return true;
    }
    int dfs(int x, int y, int m, int n, vector<vector<bool>>& visit, vector<vector<int>>& memo)
    {
        if (x == m - 1 && y == n - 1)
        {
            return 1;
        }

        if (memo[x][y])
            return memo[x][y];

        int dx[2] = {1, 0};
        int dy[2] = {0, 1};
        int res = 0;
        for (int i = 0; i < 2; i++)
        {
            int nx = x + dx[i];
            int ny = y + dy[i];

            if (!isInBoundary(nx, ny, m, n) || visit[nx][ny])
                continue;
            visit[nx][ny] = true;
            res += dfs(nx, ny, m, n, visit, memo);
            visit[nx][ny] = false;
        }
        memo[x][y] = res;
        return res;
    }
    int uniquePaths(int m, int n) {
        vector<vector<bool>> visit(m, vector<bool>(n, false));
        vector<vector<int>>  memo(m, vector<int>(n, 0));
        return dfs(0, 0, m, n, visit, memo);
    }
};
```

### 398 · Longest Ascent Path

```
from typing import (
    List,
)

class Solution:
    def isInBound(self, x, y, m, n):
        if x < 0 or y < 0 or x >= m or y >= n:
            return False
        return True
    def dfs(self, matrix, memo, x, y):
        m = len(matrix)
        n = len(matrix[0])
        if (x, y) in memo:
            return memo[(x, y)]
        dx = [0, 0, 1, -1]
        dy = [1, -1, 0, 0]
        longest = 1
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            if not self.isInBound(nx, ny, m, n) or matrix[nx][ny] <= matrix[x][y]:
                continue
            longest = max(longest, self.dfs(matrix, memo, nx, ny) + 1)
        memo[(x, y)] = longest
        return longest


    def longest_continuous_increasing_subsequence2(self, matrix: List[List[int]]) -> int:
        if len(matrix) == 0:
            return 0
        m = len(matrix)
        n = len(matrix[0])
        
        longest = 1
        memo = collections.defaultdict(int)
        for i in range(m):
            for j in range(n):
                longest = max(longest, self.dfs(matrix, memo, i, j))
        return longest


```





## 二分图 染色法

### 1596 · Possible Bipartition

```
class Solution {
public:
    bool dfs(unordered_map<int, vector<int>>& g, vector<int>& color, int curcolor, int p)
    {
        color[p] = curcolor;
        for (auto n : g[p])
        {
            if (color[n] == -1)
            {
                if(!dfs(g, color, !curcolor, n))
                    return false;
            }
            else if (color[n] == curcolor)
                return false;
        }
        return true;
    }
    bool possibleBipartition(int N, vector<vector<int>> &dislikes) {
        int m = dislikes.size();
        unordered_map<int, vector<int>> g;
        for (int i = 0; i < m; i++)
        {
            g[dislikes[i][0]].push_back(dislikes[i][1]);
            g[dislikes[i][1]].push_back(dislikes[i][0]);
        }
        vector<int> color(m + 1, -1);
        for (int i = 1; i <= m; i++)
        {
            if (color[i] == -1)
            { 
                if (!dfs(g, color, 0, i))
                    return false;
            }
        }
        return true;
    }
};
```

# 二叉树

### 97 · Maximum Depth of Binary Tree

```
class Solution:
    """
    @param root: The root of binary tree.
    @return: An integer
    """
    def maxDepth(self, root):
        if root is None:
            return 0
        leftDepth = self.maxDepth(root.left)
        rightDepth = self.maxDepth(root.right)
        return max(leftDepth, rightDepth) + 1
```

### 1360 · Symmetric Tree

```
class Solution {
public:
    bool isSymmetric (TreeNode* root) {
        return root == nullptr || isSymmetricHelp (root->left, root->right);
    }
    bool isSymmetricHelp (TreeNode* left, TreeNode* right) {
        if (left == nullptr || right == nullptr) {
            return left == nullptr && right == nullptr;
        }
        if (left->val != right->val) {
            return false;
        }
        return isSymmetricHelp (left->left, right->right) && isSymmetricHelp (left->right, right->left);
    }
};
```

### 1311 · Lowest Common Ancestor of a Binary Search Tree

```
class Solution {
public:
    TreeNode* dfs(TreeNode * root, TreeNode * p, TreeNode * q)
    {
        if (root == p || root == q)
            return root;
        if (q->val <= root->val && p->val <= root->val)
        {
            return dfs(root->left, p, q);
        }
        else if (q->val >= root->val && p->val >= root->val)
        {
            return dfs(root->right, p, q);
        }
        return root;
    }
    TreeNode * lowestCommonAncestor(TreeNode * root, TreeNode * p, TreeNode * q) {
        return dfs(root, p, q);
    }
};
```

### 88 · Lowest Common Ancestor of a Binary Tree(LCA)

```
class Solution {
public:
    TreeNode* ans;
    bool dfs(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == nullptr) return false;
        bool lson = dfs(root->left, p, q);
        bool rson = dfs(root->right, p, q);
        if ((lson && rson) || ((root->val == p->val || root->val == q->val) && (lson || rson))) 
        {
            ans = root;
        } 
        return lson || rson || (root->val == p->val || root->val == q->val);
    }
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        dfs(root, p, q);
        return ans;
    }
};
```

### 1593 · Construct Binary Tree from Preorder and Postorder Traversal

```

```

### 72 · Construct Binary Tree from Inorder and Postorder Traversal

```

```

### 73 · Construct Binary Tree from Preorder and Inorder Traversal

```

```

## BST 建树，插入

### 1561 · BST节点距离

```
class Solution {
public:
    TreeNode* insert(TreeNode* root, int node){
        if (root == NULL){
            return new TreeNode(node);
        }
        if (root->val > node){
            root->left = insert(root->left, node);
        }
        else if (root->val < node){
            root->right = insert(root->right, node);
        }
        return root;
    } 

    TreeNode build(vector<int> &numbers){
        TreeNode root = TreeNode(numbers[0]);
        int len = numbers.size();
        for (int i = 1; i < len; i++){
            insert(&root, numbers[i]);
        }
        return root;
    }

    bool check(vector<int> &numbers, int node1, int node2){
        bool flag1 = false, flag2 = false;
        for (auto &i: numbers){
            if (i == node1){
                flag1 = true;
            }
            if (i == node2){
                flag2 = true;
            }
        }
        return (flag1 && flag2);
    }

    int findDis(TreeNode* root, int node) {
        int dis = 0;
        while (root->val != node) {
            dis ++;
            if (root->val > node) {
                root = root->left;
            } else {
                root = root->right;
            }
        }
        return dis;
    }

    int bstDistance(vector<int> &numbers, int node1, int node2) {
        if (numbers.size() < 2){
            return -1;
        }
        if (!check(numbers, node1, node2)){
            return -1;
        }
        TreeNode root = build(numbers);
        while (node1 > root.val && node2 > root.val || node1 < root.val && node2 < root.val) {
            if (node1 > root.val && node2 > root.val) {
                root = *root.right;
            } else {
                root = *root.left;
            }

        }
        return findDis(&root, node1) + findDis(&root, node2);
    }
};
```
### 95 · Validate Binary Search Tree
```
class Solution {
public:
    bool test(TreeNode* root, long minv, long maxv)
    {
        if (!root)
            return true;
        if (root->val >= maxv || root->val <= minv)
            return false;
        return test(root->left, minv, root->val) && test(root->right, root->val, maxv);
    }
    bool isValidBST(TreeNode *root) {
        return test(root, LONG_MIN, LONG_MAX);
    }
};
```


# String

## 字符串hash

![image-20220209082215009](D:\code\sf\image-20220209082215009.png)
![image-20220209082322116](D:\code\sf\image-20220209082322116.png)
h[] 位从左到右算
进制为从右往左算

例如
1. h[R] = 123456   h[L - 1] = 123
    R= 0 ~ 5,  L = 0 ~ 2
2. h[L - 1]左移(R - (L - 1))位以后就变成了123000，与h[R]高位对齐
    h'[L - 1] = 123000
    h[R]       = 123456
3. 最后相减，即为456部分的hash
    h[R ~ L] = h[R] - h[L - 1] * P^(R - (L - 1))

```

                       (L-1) L       R        
              |--------------|-------|---------------|
h[R] =      (R-1)                    0
h[L - 1] =  (L-2)            0
将h[L - 1]左移P^(R-L+1)位以后：
                       (L-1) L       R        
              |--------------|-------|---------------|
h[R] =      (R-1)XXXXXXXXXXXXXXXXXXXXX
h[L - 1] =  (L-2)XXXXXXXXXXXX000000000

h[R] - h[L - 1] * P^(R-L+1) = h[L-R]
```

### 128 · Hash Function

```
class Solution {
public:
    int hashCode(string &key, int HASH_SIZE) {
        int P = 33;
        int sum = 0;
        int len = key.length();
        long long h[len] = {0};

        h[0] = key[0];
        for (int i = 1; i < len; i++)
        {   
            h[i] = (h[i - 1] * P + key[i]) % HASH_SIZE;
        }

        return h[len - 1];
    }
};
```

### 13 · Implement strStr()

```
#include <limits>
class Solution {
publi c:
    int strStr(string &source, string &target) {
        if (target.empty())
            return 0;
        int m = source.size();
        int n = target.size();
        int C = 31;
        long long power = 1;
        long long thash = 0;
        for (int i = 0; i < n; i++)
        {
            power *= C;
            thash = thash * C + target[i];
        }

        long long shash = 0;
        for (int i = 0; i < m; i++)
        {
            // abc + d   p2 + p1 + p0 -> p3 + p2 + p1 + p0
            shash = shash * C + source[i];
            if (i < n - 1)
                continue;

            // abcd - a  p3 + p2 + p1 + p0 -> p2 + p1 + p0
            if (i >= n)
            {
                shash = shash - source[i - n] * power;
                if (shash < 0)
                    shash += std::numeric_limits<long long>::max();
            }

            if (thash == shash)
                return i - n + 1;
        }
        return -1;
    }
};
```

解法2：

    1. p[0] = 1;
    1. i 从1 开始 source[i - 1]

```
class Solution {
public:
    unsigned long long gethash(vector<unsigned long long>& hash, vector<unsigned long long>& p, int L, int R)
    {
        return hash[R] - hash[L - 1] * p[R - (L - 1)];
    }
    int strStr(string &source, string &target) {
        if (source.empty() && target.empty())
            return 0;
        if (source.empty() && !target.empty())
            return -1;
        if (source.size() < target.size())
            return -1;
        int m = source.size();
        int n = target.size();
        vector<unsigned long long> shash(m + 1, 0);
        vector<unsigned long long> p(m + 1, 0);
        vector<unsigned long long> thash(n + 1, 0);
        const int P =  31;
        p[0] = 1;
        for (int i = 1; i <= m; i++)
        {
            p[i] = p[i - 1] * P;
            shash[i] = shash[i - 1] * P + source[i - 1];
        }
        for (int i = 1; i <= n; i++)
        {
            thash[i] = thash[i - 1] * P + target[i - 1];
        }

        for (int i = 1; i <= m; i++)
        {
            if (i + n - 1 <= m)
            {
                unsigned long long sh = gethash(shash, p, i, i + n - 1);
                if (thash[n] == sh)
                    return i - 1;
            }
        }

        return -1;
    }
};
```

### 841 · String Replace

```
class Solution {
public:
    typedef unsigned long long ULL;
    struct cmp
    {
        bool operator()(ULL a, ULL b)
        {
            return a > b;
        }
    };
    ULL gethash(vector<ULL>& h, vector<ULL>& p, int L, int R)
    {
        return h[R] - h[L - 1] * p[R - L + 1];
    }
    string stringReplace(vector<string> &a, vector<string> &b, string &s) {
        int m = s.size();
        int n = a.size();
        const int P = 31;
        map<ULL, string, cmp> hash;
        for (int i = 0; i < n; i++)
        {
            int len = a[i].size();
            vector<ULL> whash(m + 1, 0);
            for (int j = 1; j <= len; j++)
            {
                whash[j] = whash[j - 1] * P + a[i][j - 1];
            }
            hash[whash[len]] = b[i];
        }
        vector<ULL> shash(m + 1, 0);
        vector<ULL> p(m + 1, 0);
        p[0] = 1;
        for (int i = 1; i <= m; i++)
        {
            p[i] = p[i - 1] * P;
            shash[i] = shash[i - 1] * P + s[i - 1];
        }

        unordered_map<int, string> replace;
        for (int i = 1; i <= m; i++)
        {
            for (auto w : hash)
            {
                int len = w.second.size();
                if (i + len - 1 > m)
                    continue;
                ULL hs = gethash(shash, p, i, i + len - 1);
                if (hs != w.first)
                    continue;
                replace.insert({i - 1, w.second});
                i += (len - 1);
                break;
            }
        }

        for (auto r : replace)
        {
            int len = r.second.size();
            for (int i = 0; i < len; i++)
            {
                s[r.first + i] = r.second[i];
            }
        }

        return s;
    }
};
```

# Trie树

### 442 · Implement Trie (Prefix Tree)

```
class Trie {
public:
    /*
     * @param word: a word
     * @return: nothing
     */
    int son[100000][26];
    int cnt[100000];
    int idx = 0;
    void insert(string &word) {
        int m = word.size();
        int p = 0;
        for (int i = 0; i < m; i++)
        {
            int u = word[i] - 'a';
            if (!son[p][u]) son[p][u] = ++idx;
            p = son[p][u];
        }
        cnt[p]++;
    }

    /*
     * @param word: A string
     * @return: if the word is in the trie.
     */
    bool search(string &word) {
        int m = word.size();
        int p = 0;
        for (int i = 0; i < m; i++)
        {
            int u = word[i] - 'a';
            if (!son[p][u]) 
                return false;
            p = son[p][u];
        }
        return cnt[p]? true: false;
    }

    /*
     * @param prefix: A string
     * @return: if there is any word in the trie that starts with the given prefix.
     */
    bool startsWith(string &prefix) {
        int m = prefix.size();
        int p = 0;
        for (int i = 0; i < m; i++)
        {
            int u = prefix[i] - 'a';
            if (!son[p][u]) 
                return false;
            p = son[p][u];
        }
        return true;
    }
};
```
### leetcode 208. Implement Trie (Prefix Tree)

```
class Trie:
    def __init__(self):
        self.children = [None] * 26
        self.isEnd = False
    
    def searchPrefix(self, prefix: str) -> "Trie":
        node = self
        for ch in prefix:
            ch = ord(ch) - ord("a")
            if not node.children[ch]:
                return None
            node = node.children[ch]
        return node

    def insert(self, word: str) -> None:
        node = self
        for ch in word:
            ch = ord(ch) - ord("a")
            if not node.children[ch]:
                node.children[ch] = Trie()
            node = node.children[ch]
        node.isEnd = True

    def search(self, word: str) -> bool:
        node = self.searchPrefix(word)
        return node is not None and node.isEnd

    def startsWith(self, prefix: str) -> bool:
        return self.searchPrefix(prefix) is not None

```



### 132 · Word Search II

python trie树实现

```
class Trie:
    def __init__(self):
        self.children = defaultdict(Trie)
        self.word = ""

    def insert(self, word):
        cur = self
        for c in word:
            cur = cur.children[c]
        cur.is_word = True
        cur.word = word


class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        trie = Trie()
        for word in words:
            trie.insert(word)

        def dfs(now, i1, j1):
            if board[i1][j1] not in now.children:
                return

            ch = board[i1][j1]

            now = now.children[ch]
            if now.word != "":
                ans.add(now.word)

            board[i1][j1] = "#"
            for i2, j2 in [(i1 + 1, j1), (i1 - 1, j1), (i1, j1 + 1), (i1, j1 - 1)]:
                if 0 <= i2 < m and 0 <= j2 < n:
                    dfs(now, i2, j2)
            board[i1][j1] = ch

        ans = set()
        m, n = len(board), len(board[0])

        for i in range(m):
            for j in range(n):
                dfs(trie, i, j)

        return list(ans)
```



### 1848 · Word Search III

```
class Solution {
public:
    int son[100000][26] = {0};
    int cnt[100000] = {0};
    int idx = 0;
    void insert(string& s)
    {
        int p = 0;
        for (int i = 0; s[i]; i++)
        {
            int u = s[i] - 'a';
            if (!son[p][u])
                son[p][u] = ++idx;
            p = son[p][u];
        }
        cnt[p]++;
    }

    bool isInBound(int x, int y, int m, int n)
    {
        if (x >= m || y >= n || x < 0 || y < 0)
            return false;
        return true;
    }
    void dfs(vector<vector<char>> &board, int wcount, int x, int y, int p, vector<vector<bool>>& visit, int wordcount, int& res, int startx, int starty)
    {
        if (wordcount >= wcount)
            return;

        int m = board.size();
        int n = board[0].size();
        visit[x][y] = true;
        p = son[p][board[x][y] - 'a'];
        if (cnt[p])
        {
            wordcount++;
            res = max(res, wordcount);
            int tmp = cnt[p];
            cnt[p] = 0;
            for (int i = startx; i < m; i++)
            {
                for (int j = starty; j < n; j++)
                {
                    if (visit[i][j])
                        continue;
                    dfs(board, wcount, i, j, 0, visit, wordcount, res, i, j);
                }
            }
            wordcount--;
            cnt[p] = tmp;
        }
        else
        {
            int dx[4] = {0, 1, 0, -1};
            int dy[4] = {1, 0, -1, 0};
            for (int i = 0; i < 4; i++)
            {
                int nx = x + dx[i];
                int ny = y + dy[i];
                if (!isInBound(nx, ny, m, n) || visit[nx][ny] || !son[p][board[nx][ny] - 'a'])
                    continue;
                dfs(board, wcount, nx, ny, p, visit, wordcount, res, startx, starty);
            }
        }
        visit[x][y] = false;
    }

    int wordSearchIII(vector<vector<char>> &board, vector<string> &words) {
        int m = board.size();
        int n = board[0].size();
        for (auto w : words)
        {
            insert(w);
        }
        int res = 0;
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                int u = board[i][j] - 'a';
                if (son[0][u])
                {
                    vector<vector<bool>> visit(m, vector<bool>(n, 0));
                    dfs(board, words.size(), i, j, 0, visit, 0, res, 0, 0);
                }
            }
        }
        return res;
    }
};
```


# Heap

### 130 · Heapify

```
    void heapify(vector<int> &A) {
        priority_queue<int, vector<int>, greater<int>> q;
        for (auto n : A)
        {
            q.push(n);
        }
        A.clear();
        while (!q.empty())
        {
            A.push_back(q.top()); q.pop();
        }
    }

    void heapify(vector<int> &A) {

        int len = A.size();
        if (!len || len == 1)
           return;

        std::make_heap (A.begin(),A.end(), [](int a, int b){return a > b;});
    }    
```

```
void down(vector<int> &A, int i)
    {
        int t = i;
        int len = A.size();
         if (i * 2 <= len && A[i-1] > A[i * 2 - 1])
         {
             t = i * 2;
         }
         if (i * 2 + 1 <= len && A[i - 1] > A[i * 2 + 1 - 1])
         {
             t = i * 2 + 1;
         }

         if (t != i)
         {
             swap(A[t-1], A[i-1]);
             down(A, t);
         }

    }
```

### 613 · High Five

Heap 基础用法

```
class Solution {
public:
    /**
     * @param results a list of <student_id, score>
     * @return find the average of 5 highest scores for each person
     * map<int, double> (student_id, average_score)
     */
    map<int, double> highFive(vector<Record>& results) {
        map<int, priority_queue<int, vector<int>, greater<int>>> hash;
        map<int, double> hashTotal;

        for (auto n : results)
        {
            hash[n.id].push(n.score);
            hashTotal[n.id] += n.score;
            if (hash[n.id].size() > 5)
            {
                hashTotal[n.id] -= hash[n.id].top();
                hash[n.id].pop();
            }
        }
        for (auto& n : hashTotal)
        {
            n.second /= 5.0;
        }
        return hashTotal;
    }
};
```

# Hash

## 扩容

### 129 · Rehashing

将容量扩充为原来的两倍，然后将原来的数据重新计算hash放入新的buff中

```
class Solution {
public:
    int hashcode(int key, int capacity) {
        return (key % capacity + capacity) % capacity;
    }
    vector<ListNode*> rehashing(vector<ListNode*> hashTable) {
        int m = hashTable.size();
        vector<ListNode*> newHashTab(2 * m, nullptr);
        for (auto n : hashTable)
        {
            while (n)
            {
                ListNode* newNode = new ListNode(n->val);
                ListNode* l = newHashTab[hashcode(n->val, 2 * m)];
                if (!l)
                    newHashTab[hashcode(n->val, 2 * m)] = newNode;
                else
                {
                    while (l)
                    {
                        if (!l->next)
                        {
                            l->next = newNode;
                            break;
                        }
                        l = l->next;
                    }
                }
                n = n->next;
            }
        }
        return newHashTab;
    }
};
```

# 链表（见链表页）

### 103 · Linked List Cycle II 链表环

```
class Solution {
public:
    ListNode * detectCycle(ListNode * head) {
        if(head == NULL || head->next == NULL){
            return NULL;
        }
        ListNode *slow = head;
        ListNode *fast = head;
        while(fast != NULL && fast->next != NULL){
            slow = slow->next;
            fast = fast->next->next;
            if(slow == fast){
                break;
            }
        }
        if(fast == NULL || fast->next == NULL){
            return NULL;
        }
        slow = head;
        while(slow != fast){
            slow = slow->next;
            fast = fast->next;
        }
        return slow;
    }
};
```

### L21. 合并两个有序链表

### L23. 合并K个升序链表

### L19. 删除链表的倒数第 N 个结点

### L876. 链表的中间结点(228)

### 剑指 Offer 24. 反转链表

### 判断单链表是否包含环

### 剑指 Offer II 022. 链表中环的入口节点

### 剑指 Offer II 023. 两个链表的第一个重合节点

# 动态规划

### 515 · Paint House

```
class Solution {
public:
    int minCost(vector<vector<int>> &costs) {
        if (costs.empty())
            return 0;
        int m = costs.size();
        vector<vector<int>> f(m, vector<int>(3, 0));
        f[0][0] = costs[0][0];
        f[0][1] = costs[0][1];
        f[0][2] = costs[0][2];
        for (int i = 1; i < m; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                f[i][j] = min(f[i - 1][(j + 1) % 3], f[i - 1][(j + 2) % 3]) + costs[i][j];
            }
        }
        int res = INT_MAX;
        for (int i = 0; i < 3; i++)
        {
            res = min(res, f[m - 1][i]);
        }

        return res;
    }
};
```

### 111 · Climbing Stairs

```
class Solution {
public:
    int climbStairs(int n) {
        if (n == 0)
            return 0;
        vector<int> dp(n + 1, 0);
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++)
        {
            dp[i] = dp[i - 2] + dp[i - 1];
        }
        return dp[n];
    }
};
```

### 300 · Meeting Room IV

接龙

```
class Solution {
public:
    int maxValue(vector<vector<int>> &meeting, vector<int> &value) {
        int m = meeting.size();
        vector<int> f(50010, 0);

        int res = 0;
        for (int j = 1; j < 50010; j++)
        {
            f[j] = f[j - 1];
            for (int i = 1; i <= m; i++)
            {
                if (meeting[i - 1][1] != j)
                    continue;

                f[j] = max(f[j], f[meeting[i - 1][0]] + value[i - 1]);
                res = max(res, f[j]);
            }
        }

        return res;
    }
};
```

### L32. Longest Valid Parentheses

dp为 以“)” 为结尾的左边最长括号的长度

```
class Solution {
public:
    int longestValidParentheses(string s) {
        if (s.length() <= 1)
            return 0;
        int len = s.length();
        int dp[300000] = {0};

        int max = 0;
        for (int i = 1; i < len; ++i)
        {
            if (s[i] == ')')
            {
                int pre = 0;
                pre = i - dp[i - 1] - 1;
                if (pre >= 0 && s[pre] == '(')
                {
                    dp[i] = dp[i - 1] + 2;
                    if (pre > 0)
                    {
                        dp[i] += dp[pre - 1];
                    }
                }

                if (dp[i] > max)
                {
                    max = dp[i];
                }
            }
        }
        return max;
    }
};
```

## 正向推算

### L5982. Solving Questions With Brainpower

```
class Solution {
public:
    long long mostPoints(vector<vector<int>>& questions) {
        int m = questions.size();
        vector<long long> f(m, 0);
        for (int i = 0; i < m; i++)
        {
            if (i + 1 < m)
                f[i + 1] = max(f[i + 1], f[i]);
            f[i] += questions[i][0];
            int remote = i + questions[i][1] + 1;
            if (remote < m)
                f[remote] = max(f[remote], f[i]);
        }
        long long res = *std::max_element(f.begin(), f.end());
        return res;
    }
};
```

## 坐标型DP

### 115 · Unique Paths II

```
class Solution {
public:
    bool isInBound(int x, int y, int m, int n)
    {
        if (x >= m || y >= n || x < 0 || y < 0)
            return false;
        return true;
    }
    int uniquePathsWithObstacles(vector<vector<int>> &obstacleGrid) {
        if (obstacleGrid.empty())
            return 0;
        if (obstacleGrid[0][0])
            return 0;

        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        vector<vector<int>> f(m + 1, vector<int>(n + 1, 0));
        f[0][0] = 1;
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (obstacleGrid[i][j])
                    continue;
                if (isInBound(i - 1, j, m, n))
                    f[i][j] += f[i - 1][j];
                if (isInBound(i, j - 1, m, n))
                    f[i][j] += f[i][j - 1];
            }
        }
        return f[m - 1][n - 1];
    }
};
```

### 76 · Longest Increasing Subsequence(LIS)

是大于，不是大于等于。初始化为1

```
class Solution {
public:
    int longestIncreasingSubsequence(vector<int> &nums) {
        if (nums.empty())
            return 0;
        int m = nums.size();
        vector<int> f(m + 1, 1);
        int res = 0;
        for (int i = 1; i < m; i++)
        {
            for (int j = 0; j < i; j++)
            {
                if (nums[i] > nums[j])
                {
                    f[i] = max(f[i], f[j] + 1);
                }
                res = max(res, f[i]);
            }
        }
        return res;
    }
};
```

### 77 · Longest Common Subsequence(LCS)

f(i, j) 是1-i和i- j两个子序列的LCS

f(i - 1, j) 和 f(i, j - 1)都包含 f(i - 1, j - 1)这种情况，但是取max的时候实际还是取的他们三者的最大值，是否重复不重要。

```
class Solution {
public:
    int longestCommonSubsequence(string &A, string &B) {
        int m = A.size();
        int n = B.size();
        A = " " + A;
        B = " " + B;
        vector<vector<int>> f(m + 1, vector<int>(n + 1, 0));

        for (int i = 1; i <= m; i++)
        {
            for (int j = 1; j <= n; j++)
            {
                f[i][j] = max(f[i - 1][j], f[i][j - 1]);
                if (A[i] == B[j])
                {
                    f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1);
                }
            }
        }
        return f[m][n];
    }
};
```

## 区间DP

### 667 · Longest Palindromic Subsequence

len从1开始，i从0开始

中间有个k隔板

变化的是连续空间

```
int longestPalindromeSubseq(string s) {
        int n = s.size();
        vector<vector<int>> dp(n + 10, vector<int>(n + 10, 0));
        for (int len = 1; len <= n; len++)
        {
            for (int i = 0; i + len - 1 < n; ++i)
            {
                int j = i + len - 1;
                if (len == 1)
                    dp[i][j] = 1;
                else if (s[i] == s[j])
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                else
                    dp[i][j] = max(dp[i][j], max(dp[i + 1][j], dp[i][j - 1]));
            }
        }

        return dp[0][n - 1];
    }
```

常规做法, dp[j]为，以j为结尾的，最长回文子序列长度

```
class Solution {
public:
    bool isPal(const string& s)
    {
        int l = 0;
        int r = s.length() - 1;

        while (l <= r && s[l] == s[r]) { l++; r--;}
        if(l > r)
            return true;
        return false;
    }
    int longestPalindromeSubseq(string &s) {
        int len = s.length();
        int res = INT_MIN;
        vector<int> dp(len + 2, 1);
        for (int i = 1; i < len; i++)
        {
            for (int j = 0; j < i; j++)
            {
                if (isPal(s.substr(j - dp[j] + 1, dp[j]) + s[i]))
                {
                    dp[i] = max (dp[i], dp[j] + 1);
                    res = max (res, dp[i]);
                }
            }
        }
        return res;
    }
};
```

### 476 · Stone Game

算法：区间DP

这是一道区间DP问题，我们需要用区间表示状态来递推。设s是表示石头重量的数组，设f[i][j]是将s[i,...,j]的石头合并成一个所需的最少能量，那么这个最少能量按照最后一步合并的分界线可以分为以下几种情况：

1、最后一步是s[i]和s[i+1,...,j]合并，此时需要的最少能量是f[i+1][j]+sum(s[i]...s[j]),第一项是合并后者需要的能量，第二项是最后一次合并所需要的能量。s[i]自己只有一个石头，不需要合并

2、最后一步是s[i,i+1]和s[i+2,...,j]合并，此时需要的最少能量是f[i][i+1]+f[i+2][j]+sum(s[i]...s[j])，第一项是合并前两个石头需要的能量，第二项是合并后半区间石头需要的能量，最后一项是最后一次合并需要的能量；

从上面我们可以看出一个规律，f[i][j]应该是所有区间分法中前一半区间的石头合并需要的总能量加上后半区间的总能量再加上最后一次合并需要的能量

求得A的前缀和
区间长度从2开始枚举，
根据上诉思路可得递推式
dp[l][r] =min(dp[l][r], dp[l][j] + dp[j + 1][r] + sum_a[r + 1] - sum_a[l])
记得初始化dp[l][r]为一个较大值
结果存在dp[0][size-1]中

```
#include <numeric>
class Solution {
public:
    int stoneGame(vector<int> &A) {
        if (A.empty())
            return 0;
        int m = A.size();
        vector<vector<int>> f(m + 1, vector<int>(m + 1, 0));
        vector<int> sum(m + 1, 0);
        partial_sum(A.begin(), A.end(), sum.begin() + 1);

        for (int len = 2; len <= m; len++)
        {
            for (int i = 0; i + len - 1 < m; i++)
            {
                int j = i + len - 1;
                f[i][j] = 0x3f3f3f3f;
                for (int k = i; k < j; k++)
                    f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j] + (sum[j + 1] - sum[i])); 
            }
        }
        return f[0][m - 1];
    }
};
```

### 107 · Word Break

```
class Solution {
public:
    bool wordBreak(string &s, unordered_set<string> &wordSet) {
        if (s.empty())
            return true;
        if (wordSet.empty())
            return false;

        int m = s.size();
        vector<bool> dp(m + 1, false);
        dp[0] = true;
        for (int i = 1; i <= m; i++)
        {
            for (int j = i - 1; j >= 0; j--)
            {
                string t = s.substr(j, i - j);
                //cout << t << endl;
                if (dp[j] && wordSet.count(t))
                {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[m];
    }
};
```

# 贪心

### L1647. Minimum Deletions to Make Character Frequencies Unique

```
class Solution {
public:
    int minDeletions(string s) {
        int m = s.size();
        unordered_map<char, int> hash;
        for (int i = 0; i < m; i++)
        {
            hash[s[i]]++;
        }

        int i = 0;
        int k = hash.size();
        int res = 0;
        while (i < k)
        {
            unordered_map<int, int> counter;
            for (auto& n : hash)
            {
                if (counter[n.second] >= 1)
                {
                    n.second--;
                    if (!n.second)
                        hash.erase(n.first);
                    i = 0;
                    res++;
                    break;
                }
                counter[n.second]++;
                i++;
            }
        }
        return res;
    }
};
```

### 187 · Gas Station

i = i + j + 1;

```
class Solution {
public:
    int canCompleteCircuit(vector<int> &gas, vector<int> &cost) {
        if (gas.empty())
            return -1;
        int m = gas.size();
        int totalgas = 0;
        int totalcost = 0;
        for (int i = 0; i < m; i++)
        {
            totalgas += gas[i];
            totalcost += cost[i];
        }
        if (totalgas < totalcost)
            return -1;

        for (int i = 0; i < m;)
        {
            int curgas = 0;
            int j = 0;
            for (;j < m; j++)
            {
                int k = (i + j) % m;
                curgas += gas[k] - cost[k];
                if (curgas < 0)
                {
                    break;
                }
            }
            if (j == m)
                return i;
            i = i + j + 1;
        }
        return -1;
    }
};
```

# 其他

## 扫描线

### 919 · Meeting Rooms II

对所有点排序，从左到右扫描每个点，是起点就加一，是终点就减一，判断这个过程中的最大值

```
class Solution {
public:
    int minMeetingRooms(vector<Interval> &intervals) {
        int m = intervals.size();
        multimap<int, int> order;
        for (auto i : intervals)
        {
            order.insert({i.start, 1});
            order.insert({i.end, -1});
        }
        int res = 0;
        int current = 0;
        for (auto t : order)
        {
            current += t.second;
            res = max(res, current);
        }
        return res;
    }
};
```

### 218. The Skyline Problem

```
class Solution {
public:
    struct cmp
    {
        bool operator()(pair<int, int>& l, pair<int, int>& r)
        {
            if (l.first < r.first)
            {
                return true;
            }
            else if (l.first == r.first)
            {
                if (l.second < r.second)
                    return true;
            }
            return false;
        }
    };

    struct hp
    {
        priority_queue<int> q;
        priority_queue<int> d;
        void insert(int x)
        {
            q.push(x);
        }
        bool empty()
        {
            return q.empty();
        }
        int top()
        {
            while (!d.empty() && q.top() == d.top()) { q.pop(); d.pop(); }
            return q.empty()? 0: q.top();
        }
        void erase(int x)
        {
            d.push(x);
        }
    };

    vector<vector<int>> getSkyline(vector<vector<int>>& buildings) {
        int m = buildings.size();
        vector<pair<int, int>> pst;
        for (int i = 0; i < m; i++)
        {
            pst.push_back({buildings[i][0], -buildings[i][2]});
            pst.push_back({buildings[i][1], buildings[i][2]});
        }
        sort(pst.begin(), pst.end(), cmp());

        hp pri;
        int prev = 0;
        vector<vector<int>> res;
        for (auto line : pst)
        {
            int p = line.first; int hi = line.second;
            if (hi < 0)
            {
                pri.insert(-hi);
            }
            else
            { 
                pri.erase(hi);
            }

            int cur = pri.top();
            if (prev == cur)
                continue;
            res.push_back({p, cur});
            prev = cur;
        }

        return res;
    }
};
```

## 前缀和

### 604 · Window Sum

```
#include <numeric>
class Solution {
public:
    vector<int> winSum(vector<int> &nums, int k) {
        if (nums.empty())
            return {};
        int m = nums.size();
        vector<int> sums(m + 1, 0);
        partial_sum(nums.begin(), nums.end(), sums.begin() + 1);
        vector<int> res;
        for (int i = 1; i + k - 1 <= m; i++)
        {
            int j = i + k - 1;
            res.push_back(sums[j] - sums[i - 1]);
        }
        return res;
    }
};
```

### 404 · 子数组求和 II
```
#include <numeric>
class Solution {
public:
    int subarraySumII(vector<int> &A, int start, int end) {
        int m = A.size();
        vector<int> sums(m + 1, 0);
        partial_sum(A.begin(), A.end(), sums.begin() + 1);

        int res = 0;
        for (int i = 1; i <= m; i++)
        {
            for (int j = i; j <= m; j++)
            {
                int sum = sums[j] - sums[i - 1];
                if (sum >= start && sum <= end)
                    res++;
            }
        }
        return res;
    }
};
```


## 倍增

### 447 · Search in a Big Sorted Array

```
        while(reader->get(r) < target)
            r <<= 1;
```

```
class Solution {
public:
    int searchBigSortedArray(ArrayReader * reader, int target) {
        int l = 0;
        int r = 1;
        while(reader->get(r) < target)
            r <<= 1;
        while (l < r)
        {
            int mid = (l + r) / 2;
            if (reader->get(mid) >= target)
            {
                r = mid;
            }
            else
            {
                l = mid + 1;
            }
        }
        if (reader->get(l) != target)
            return -1;
        return l;
    }
};
```

### 5969. Destroying Asteroids

```
class Solution {
public:
    bool asteroidsDestroyed(int mass, vector<int>& asteroids) {
        sort(asteroids.begin(), asteroids.end());
        int m = asteroids.size();
        vector<int> minarr(18, -1);
        vector<long long> sums(18, 0);

        for (int i = 0; i < m; i++)
        {
            int h = 31 - __builtin_clz(asteroids[i]);
            if (minarr[h] == -1 || asteroids[i] < minarr[h])
            {
                minarr[h] = asteroids[i];
            }
            sums[h] += asteroids[i];
        }
        long long mm = mass;
        for (int i = 0; i < 17; i++)
        {
            if (mm < minarr[i])
                return false;
            mm += sums[i];
        }
        return true;
    }
};
```

## LRU

### 134 · LRU Cache

利用std::list::splice()方法

lru_.splice(lru_.begin(), lru_, table_[key]);     

将lru位于table_[key]的位置的元素，移动到lru_.begin()的地方, table_[key]为iterator

```
#include <list>
class LRUCache {
public:
    LRUCache(int capacity) : _capacity(capacity) {

    }

    int get(int key) {
        auto it = _table.find(key);
        if (it != _table.end()) {
            _lru.splice(_lru.begin(), _lru, it->second);
            return it->second->second;
        }
        return -1;
    }

    void set(int key, int value) {
        auto it = _table.find(key);
        if (it != _table.end()) {
            _lru.splice(_lru.begin(), _lru, it->second);
            it->second->second = value;
            return;
        }

        _lru.emplace_front(key, value);
        _table[key] = _lru.begin();

        if (_table.size() > _capacity) {
            _table.erase(_lru.back().first);
            _lru.pop_back();
        }
    }
private:
    unordered_map<int, std::list<std::pair<int, int>>::iterator> _table;
    std::list<std::pair<int, int>> _lru;
    int _capacity;
};
```

## 位运算

### 1891 · Travel Plan

位操作

```
    int setbit(int& x, int bit)
    {
        return x | (1 << bit);
    }
    int clsbit(int& x, int bit)
    {
        return x & ~(1 << bit);
    }
    bool getbit(int x, int bit)
    {
        return (x >> bit) & 1;
    }
```

```
class Solution {
public:
    int setbit(int& x, int bit)
    {
        return x | (1 << bit);
    }
    int clsbit(int& x, int bit)
    {
        return x & ~(1 << bit);
    }
    bool getbit(int x, int bit)
    {
        return (x >> bit) & 1;
    }
    void dfs(vector<vector<int>> &arr, int& visit, int cur, int curweight, int& res)
    {
        int m = arr.size();
        if (cur == 0 && visit == alltag)
        {
            res = min(res, curweight);
            return;
        }

        for (int i = 0; i < m; i++)
        {
            if (cur == i || getbit(visit, i))
                continue;
            visit = setbit(visit, i);
            dfs(arr, visit, i, curweight + arr[cur][i], res);
            visit = clsbit(visit, i);
        }
    }
    int alltag = 0;
    int travelPlan(vector<vector<int>> &arr) {
        int m = arr.size();
        for (int i = 0; i < m; i++)
        {
            alltag = setbit(alltag, i);
        }
        int res = 0x3f3f3f3f;
        int visit = 0;
        dfs(arr, visit, 0, 0, res);
        return res;
    }
};
```

### L5978. Count Words Obtained After Adding a Letter

```
class Solution {
public:
    int getbit(string& s)
    {
        int bit = 0;
        for (auto c : s)
        {
            bit = bit | (1 << (c - 'a')); 
        }
        return bit;
    }
    int wordCount(vector<string>& startWords, vector<string>& targetWords) {
        unordered_set<int> bitvec;
        for (auto w : startWords)
        {
            int wbit = getbit(w);

            bitvec.insert(wbit);
        }
        int res = 0;
        int m = targetWords.size();
        for (int i = 0; i < m; i++)
        {
            int bit = getbit(targetWords[i]);
            for (int j = 0; j < 26; j++)
            {
                if (bit & 1 << j)
                {
                    if (bitvec.count(bit & ~(1 << j)))
                    {
                        res++;
                        break;
                    }
                }
            }
        }
        return res;
    }
};
```

### 1468 · Two Numbers That Are Not Repeated

```
class Solution {
public:
    vector<int> theTwoNumbers(vector<int> &a) {
        int m = a.size();
        int xorres = 0;
        for (int i = 0; i < m; i++)
        {
            xorres ^= a[i];
        }

        int t = xorres;
        int idx = 0;
        while ((t & 1) == 0 && idx < 32)
        {
            t = t >> 1;
            idx++;
        }

        int test = 1 << idx;
        int num1 = 0;
        int num2 = 0;
        for (auto n : a)
        {
            if ((n & test) != 0)
            {
                num1 ^= n;
            }
            else
            {
                num2 ^= n;
            }
        }

        return num1 < num2? vector<int>({num1, num2}) : vector<int>({num2, num1});
    }
};
```

## 二维前缀和 + 二维差分

### L1314. Matrix Block Sum

### L304. Range Sum Query 2D - Immutable

```
class NumMatrix {
public:
    NumMatrix(vector<vector<int>>& matrix):
        m(matrix.size()), n(matrix[0].size()), 
        sums(m + 1, vector<int>(n + 1, 0)) 
    {
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                sums[i + 1][j + 1] = sums[i][j + 1] + sums[i + 1][j] - sums[i][j] + matrix[i][j]; 
            }
        }
    }
    int m;
    int n;
    vector<vector<int>> sums;
    int sumRegion(int row1, int col1, int row2, int col2) {
        int res = sums[row2 + 1][col2 + 1] - sums[row1][col2 + 1] - sums[row2 + 1][col1] + sums[row1][col1];
        return res;
    }
};
```

### 5931. Stamping the Grid

![](D:\code\sf\chafe.PNG)

```
class Solution {
public:
    void insert(vector<vector<int>>& diff, int x1, int y1, int x2, int y2)
    {
        diff[x1][y1] += 1;
        diff[x2 + 1][y2 + 1] += 1;
        diff[x1][y2 + 1] -= 1;
        diff[x2 + 1][y1] -= 1;
    }
    bool possibleToStamp(vector<vector<int>>& grid, int stampHeight, int stampWidth) {
        int m = grid.size();
        int n = grid[0].size();
        vector<vector<int>> sums(m + 1, vector<int>(n + 1, 0));
        for (int i = 1; i <= m; i++)
        {
            for (int j = 1; j <= n; j++)
            {
                sums[i][j] = sums[i - 1][j] + sums[i][j - 1] - sums[i - 1][j - 1] + grid[i - 1][j - 1];
            }
        }
        int h = stampHeight;
        int w = stampWidth;
        vector<vector<int>> markmatrix(m + 2, vector<int>(n + 2, 0));
        for (int i = h; i <= m; i++)
        {
            for (int j = w; j <= n; j++)
            {
                int check = sums[i][j] - sums[i - h][j] - sums[i][j - w] + sums[i - h][j - w];
                if (!check)
                {
                    insert(markmatrix, i - h + 1, j - w + 1, i, j);
                }
            }
        }

        vector<vector<int>> resmarkmatrix(m + 2, vector<int>(n + 2, 0));
        for (int i = 1; i <= m; i++)
        {
            for (int j = 1; j <= n; j++)
            {
                resmarkmatrix[i][j] = resmarkmatrix[i - 1][j] + resmarkmatrix[i][j - 1] - resmarkmatrix[i - 1][j - 1] + markmatrix[i][j];
            }
        }
        for (int i = 1; i <= m; i++)
        {
            for (int j = 1; j <= n; j++)
            {
                if (!resmarkmatrix[i][j] && !grid[i - 1][j - 1])
                    return false;
            }
        }

        return true;
    }
};
```

## A*

### 794 · Sliding Puzzle II

## BST 判断

### 910 · Largest BST Subtree

```
class Solution:
    def largestBSTSubtree(self, root: TreeNode) -> int:
        if root is None:
            return 0

        _, size, _, _ = self.helper(root)
        return size

    def helper(self, root):
        if root is None:
            return True, 0, sys.maxsize, -sys.maxsize

        l_bst, l_size, l_min, l_max = self.helper(root.left)
        r_bst, r_size, r_min, r_max = self.helper(root.right)

        bst = l_bst and r_bst and root.val > l_max and root.val < r_min

        if bst:
            size = l_size + r_size + 1
        else:
            size = max(l_size, r_size)

        return bst, size, min(l_min, r_min, root.val), max(l_max, r_max, root.val)
```

## KMP

### 1625 · Words Compression

## 二分图最大权匹配 KM算法

### 1576 · Optimal Match
