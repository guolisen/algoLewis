[TOC]

# 排序

https://www.algolist.net/Algorithms/Sorting/Selection_sort
https://www.algolist.net/Algorithms/Sorting/Quicksort
https://www.algolist.net/Algorithms/Sorting/Insertion_sort
https://www.algolist.net/Algorithms/Sorting/Bubble_sort
https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html

## 快速排序

### Partition
```
        int m = A.size();
        int l = 0;
        int r = m - 1;
        while (l <= r)
        {
            while (l <= r && A[l] < 0) { l++; }
            while (l <= r && A[r] >= 0) { r--; }
            if (l < r)
            {
                swap(A[l], A[r]);
            }
        }
```
### 31 · Partition Array *  148 · Sort Colors

### 143 · Sort Colors II

```
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```

# 双指针

多数有序，比目标大的时候，移动r，比目标小的时候，移动l

**双指针大多都是对两层循环的优化**, 所以当暴力法涉及到两层循环遍历的时候, 我们就应该有这种思想: 能不能用到双指针的思想.

### 56 · Two Sum

```
    vector<int> twoSum(vector<int> &numbers, int target) {
        int m = numbers.size();
        vector<int> res;
        for (int i = 0; i < m - 1; i++)
        {
            for (int j = i + 1; j < m; j++)
            {
                if (numbers[i] + numbers[j] == target)
                {
                    res.push_back(i);
                    res.push_back(j);
                    return res;
                }
            }
        }
        return {-1, -1};
    }
```

### 59 · 3Sum Closest

```
    int threeSumClosest(vector<int> &numbers, int target) {
        if (numbers.empty())
            return 100000000;
        sort(numbers.begin(), numbers.end());
        int m = numbers.size();
        int minv = INT_MAX;
        for (int i = 0; i < m - 1; ++i)
        {
            int l = i + 1;
            int r = m - 1;
            while (l < r)
            {
                int sum = numbers[i] + numbers[l]  + numbers[r];
                if (abs(sum - target) < abs(minv - target))
                {
                    minv = sum;               
                }

                if (sum < target)
                {
                    l++;
                }
                else
                {
                    r--;
                }
            }

        }
        return minv;
    }
```

### 460 · Find K Closest Elements

```
class Solution {
public:
     bool isLeftClosest(vector<int> &a, int target, int l, int r)
     {
        if (l < 0)
            return false;
        if (r >= a.size())
            return true;
        if (target - a[l] <= a[r] - target)
            return true;
        return false;  
     }
    vector<int> kClosestNumbers(vector<int> &a, int target, int k) {
        vector<int> res;
        int l = 0;
        int r = a.size() - 1;
        while (l < r)
        {
            int mid = (l + r) / 2;
            if (a[mid] >= target)
            {
                r = mid;
            }
            else
            {
                l = mid + 1;
            }
        }
        int left  = l - 1;
        int right = l;
        while (k--)
        {
            if (isLeftClosest(a, target, left, right))
            {
                res.push_back(a[left--]);
            }
            else
            {
                res.push_back(a[right++]);
            }
        }
        return res;
    }
};
```



### 31 · Partition Array *  148 · Sort Colors

```
class Solution {
public:
    int partitionArray(vector<int> &nums, int k) {
        int m = nums.size();
        int l = 0;
        int r = m - 1;
        while (l <= r)
        {
            while (l <= r && nums[l] < k) { l++; }
            while (r >= l && nums[r] >= k) { r--; }
            if (l < r)
            {
                swap(nums[l], nums[r]);
            }
        }
        return l;
    }
};
```

### 64 · Merge Sorted Array(6 · Merge Two Sorted Arrays)

```
    void mergeSortedArray(int A[], int m, int B[], int n) {
        int ai = 0;
        int bi = 0;
        vector<int> ires;
        while (ai < m && bi < n)
        {
            if (A[ai] <= B[bi])
            {
                ires.push_back(A[ai++]);
            }
            else
            {
                ires.push_back(B[bi++]);
            }
        }
        while (ai < m)
        {
            ires.push_back(A[ai++]);
        }
        while (bi < n)
        {
            ires.push_back(B[bi++]);
        }

        int i = 0;
        for (auto n : ires)
        {
            A[i++] = n;
        }
    }
```

Second method:

```
    vector<int> mergeSortedArray(vector<int> &A, vector<int> &B) {
        int m = A.size();
        int n = B.size();
        vector<int> res;
        int ai = 0;
        int bi = 0;
        for (int k = 0; k < m + n; ++k)
        {
            if (ai < m && (bi == n || A[ai] < B[bi]))
            {
                res.push_back(A[ai++]);
            }
            else
            {
                res.push_back(B[bi++]);
            }
        }
        return res;
    }
```

In one array

```
    void mergeSortedArray(int A[], int m, int B[], int n) {
        int ri = m + n - 1;
        int ai = m - 1;
        int bi = n - 1;

        while (ai >= 0 && bi >= 0)
        {
            if (A[ai] > B[bi])
            {
                A[ri--] = A[ai--];
            }
            else
            {
                A[ri--] = B[bi--];
            }
        }
        while (bi >= 0)
        {
            A[ri--] = B[bi--];
        }
    }
```

### 165 · Merge Two Sorted Lists

```
    ListNode * mergeTwoLists(ListNode * l1, ListNode * l2) {
        if (!l1) return l2;
        if (!l2) return l1;
        ListNode* head = nullptr;
        if (l1->val < l2->val)
        {
            head = l1;
            head->next = mergeTwoLists(l1->next, l2);
        }
        else
        {
            head = l2;
            head->next = mergeTwoLists(l1, l2->next);
        }
        return head;
    }
```

1246 · Longest Repeating Character Replacement
同向双指针

```
    int characterReplacement(string &s, int k) {
        int m = s.size();
        int res = 0;
        for (int c = 'A'; c <= 'Z'; ++c)
        {
            int count = 0;
            for (int i = 0, j = 0; i < m; i++)
            {
                if (s[i] == c)
                    count++;                           
                while (i - j + 1 - count > k)
                {
                    if (s[j] == c)
                        count--;
                    j++;                      
                }
                res = max(res, i - j + 1);
            }
        }

        return res;
    }
```

### 460 · Find K Closest Elements

```
class Solution {
public:
    bool isClosed(vector<int>& A, int target, int l, int r)
    {
        if (l < 0)
            return false;
        if (r >= A.size())
            return true;
        if ((target - A[l]) != (A[r] - target))
            return (target - A[l]) < (A[r] - target);
        return true;
    }
    vector<int> kClosestNumbers(vector<int> &A, int target, int k) {
        int m = A.size();
        int l = 0;
        int r = m - 1;
        while (l < r)
        {
            int mid = (l + r + 1) / 2;
            if (A[mid] <= target)
            {
                l = mid;
            }
            else
            {
                r = mid - 1;
            }
        }
        int lpos = l;
        int rpos = l + 1;
        vector<int> res;
        while (res.size() < k)
        {
            if (isClosed(A, target, lpos, rpos))
            {
                res.push_back(A[lpos--]);
            }
            else
            {
                res.push_back(A[rpos++]);
            }
        }

        return res;
    }
};
```
## 基础
有序，sum 大于目标时移动r, 反之移动l
### 609 · Two Sum - Less than or equal to target
### 608 · Two Sum II - Input array is sorted
```
class Solution {
public:
    vector<int> twoSum(vector<int> &nums, int target) {
        int m = nums.size();
        sort(nums.begin(), nums.end());
        int l = 0;
        int r = m - 1;

        while (l < r)
        {
            int sum = nums[l] + nums[r];
            if (sum == target)
            {
                return {l + 1, r + 1};
            }
            else if (sum > target)
            {
                r--;
            }
            else
            {
                l++;
            }
        }
        return {0, 0};
    }
};
```

## 同向双指针

### 539 · Move Zeroes

```
class Solution {
public:
    void  moveZeroes(vector<int> &nums) {
        int m = nums.size();
        int l = 0;
        int r = 0;
        while (r < m)
        {
            if (nums[r] != 0)
            {
                swap(nums[l], nums[r]);
                l++;
            }
            r++;
        }
    }
};
```

## 相向双指针
### 443 · Two Sum - Greater than target
相向双指针
```
class Solution {
public:
    int twoSum2(vector<int> &nums, int target) {
        int m = nums.size();
        sort (nums.begin(), nums.end());
        int l = 0;
        int r = m - 1;
        int res = 0;

        while (l < r)
        {
            int sum = nums[l] + nums[r];
            if (sum > target)
            {
                res += r - l;
                r--;
            }
            else
            {
                l++;
            }
        }
        return res;
    }
};
```
## 根据大小找数
### 533 · Two Sum - Closest to target
```
class Solution {
public:
    int twoSumClosest(vector<int> &nums, int target) {
        int m = nums.size();
        sort(nums.begin(), nums.end());
        int l = 0;
        int r = m - 1;
        int res = 0x3f3f3f3f;
        while (l < r)
        {
            int t = nums[l] + nums[r];
            res = min(res, abs(target - t));
            if (t == target)
                return 0;
            else if (t > target)
                r--;
            else
                l++;
        }
        return res;
    }
};
```

## 滑动窗口

### 1631 · Interesting Subarray

```
class Solution {
public:
    int maxLen(vector<int> &a) {
        if (a.empty())
            return 1;
        int m = a.size();
        int res = 0;
        int l = 0;
        unordered_map<int, int> counter;
        for (int r = 0; r < m; r++)
        {
            counter[a[r]]++;
            while (l < r && counter.size() > 2)
            {
                counter[a[l]]--;
                if(!counter[a[l]])
                    counter.erase(a[l]);
                l++;   
            }
            res = max(res, r - l + 1);
        }
        return res;
    }
};
```

### 384 · Longest Substring Without Repeating Characters

```
class Solution {
public:
    int lengthOfLongestSubstring(string &s) {
        int m = s.size();
        int j = 0;
        int res = 0;
        unordered_map<char, int> hash;
        for (int i = 0; i < m; i++)
        {
            while (j < m && !hash.count(s[j]))
            {
                hash[s[j]]++;
                j++;
            }
            res = max(res, (int)hash.size());
            if (hash[s[i]])
            {
                hash[s[i]]--;
                if (!hash[s[i]])
                    hash.erase(s[i]);
            }
        }
        return res;
    }
};
```

### 386 · Longest Substring with At Most K Distinct Characters

```
class Solution {
public:
    int lengthOfLongestSubstringKDistinct(string &s, int k) {
        int m = s.length();
        int sum = 0;
        int res = 0;
        unordered_map<char, int> hash;
        for (int r = 0, l = 0; r < m; r++)
        {
            hash[s[r]]++;
            if (hash[s[r]] == 1)
            {
                sum++;
            }
            while (sum > k)
            {
                if (hash[s[l]])
                {
                    hash[s[l]]--;
                }
                if (!hash[s[l]])
                {
                    sum--;
                }
                l++;
            }
            res = max(res, r - l + 1);
        }
        return res;
    }
};
```

### 32 · Minimum Window Substring

```
class Solution {
public:
    string minWindow(string &source , string &target) {
        int m = source.length();
        int n = target.length();
        unordered_map<char, int> shash;
        unordered_map<char, int> thash;
        for (auto t : target)
        {
            thash[t]++;
        }

        int sum = 0;
        int l = 0;
        string res;
        for (int r = 0; r < m; r++)
        {
            shash[source[r]]++;
            if (thash.count(source[r]) && shash[source[r]] <= thash[source[r]])
                sum++;
            while (shash[source[l]] > thash[source[l]]) 
            {
                shash[source[l++]]--;
            }
            if (sum == n)
            {
                if (res.empty() || res.length() > r - l + 1)
                {
                    res = source.substr(l, r - l + 1);
                }
            }
        }
        return res;
    }
};
```

### 1643 · Pick Fruits

```
class Solution {
public:
    int pickFruits(vector<int> &arr) {
        if (arr.empty())
            return 1;
        int m = arr.size();
        unordered_map<int, int> hash;
        int count = 0;
        int res = 0;
        for (int r = 0, l = 0; r < m; r++)
        {
            hash[arr[r]]++;
            if (hash[arr[r]] == 1)
            {
                count++;
            }
            while (count > 2)
            {
                hash[arr[l]]--;
                if (hash[arr[l]] == 0)
                {
                    count--;
                }
                l++;
            }
            res = max(res, r - l + 1);
        }
        return res;
    }
};
```

### 647 · Find All Anagrams in a String

```
class Solution {
public:
    vector<int> findAnagrams(string &s, string &p) {
        int m = s.size();
        int n = p.size();

        unordered_map<char, int> hash;
        for (auto c : p)
        {
            hash[c]++;
        }
        int match = 0;
        int start = 0;
        int end = 0;
        vector<int> res;
        while(end <= m)
        {
            if (hash[s[end]] >= 1)
                match++;
            hash[s[end]]--;
            end++;
            if (match == n)
                res.push_back(start);
            if (end - start == n)
            {
                if (hash[s[start]] >= 0)
                {
                    match--;
                }
                hash[s[start]]++;
                start++;
            }
        }
        return res;
    }
};
```

### 1375 · Substring With At Least K Distinct Characters

```
class Solution {
public:
    long long kDistinctCharacters(string &s, int k) {
        int m = s.size();
        unordered_map<char, int> hash;
        int j = 0;
        long long res = 0;
        for (int i = 0; i < m; i++)
        {
            while (j < m && hash.size() < k)
            {
                hash[s[j]]++;
                j++;
            }
            if (hash.size() >= k)
            {
                res += m - j + 1;
            }
            if (hash[s[i]])
            {
                hash[s[i]]--;
                if (hash[s[i]] == 0)
                {
                    hash.erase(s[i]);
                }
            }
        }
        return res;
    }
};
```

### 386 · Longest Substring with At Most K Distinct Characters

同向双指针

```
class Solution {
public:
    int lengthOfLongestSubstringKDistinct(string &s, int k) {
        if (k == 0)
            return 0;
        int m = s.size();
        int res = 0;
        int i = 0;
        unordered_map<char, int> hash;
        for (int j = 0; j < m; j++)
        {
            hash[s[j]]++;
            while (hash.size() > k)
            {
                if (hash[s[i]])
                {
                    hash[s[i]]--;
                    if (!hash[s[i]])
                    {
                        hash.erase(s[i]);
                    }
                    i++;
                }
            }
            res = max (res, j - i + 1);
        }
        return res;
    }
};
```

### 1169 · Permutation in String

```
class Solution {
public:
    bool isSame(vector<int>& l, vector<int>& r)
    {
        for (int i = 0; i < 26; i++)
        {
            if (l[i] != r[i])
                return false;
        }
        return true;
    }
    bool checkInclusion(string &s1, string &s2) {
        vector<int> hash(26, 0);
        vector<int> freq(26, 0);
        int n = s1.size();
        int m = s2.size();

        for (int i = 0; i < n; i++)
        {
            hash[s1[i] - 'a']++;
            freq[s2[i] - 'a']++;
        }
        if (isSame(hash, freq))
            return true;

        for (int i = 0; i + n < m; i++)
        {
            int j = i + n;
            freq[s2[i] - 'a']--;
            freq[s2[j] - 'a']++;
            if (isSame(hash, freq))
                return true;
        }
        return false;
    }
};
```

### 144 · Interleaving Positive and Negative Numbers将数据分到两边

```
    void rerange(vector<int> &a) {
        int m = a.size();
        int l = 0;
        int r = m - 1;
        int mid = 0;
        while (l < r && l < m && r >= 0)
        {
            if (a[mid] < 0)
            {
                l++; mid++;
            }
            else
            {
                swap(a[mid], a[r]);
                r--;
            }
        }
        for (auto c : a)
        {
            cout << c << endl;
        }
    }
```


# 单调栈 O(n)

给定一个长度为 N 的整数数列，**输出每个数左边第一个比它小的数**，如果不存在则输出 −1。

```
#include <iostream>
using namespace std;
const int N = 100010;
int stk[N], tt;

int main()
{
    int n;
    cin >> n;
    while (n -- )
    {
        int x;
        scanf("%d", &x);
        while (tt && stk[tt] >= x) tt -- ;//* 如果栈顶元素大于当前待入栈元素，则出栈
        if (!tt) printf("-1 ");//如果栈空，则没有比该元素小的值。
        else printf("%d ", stk[tt]);//栈顶元素就是左侧第一个比它小的元素。
        stk[ ++ tt] = x;
    }
    return 0;
}
```

### 1852 · Final Discounted Price

```
class Solution {
public:
    vector<int> FinalDiscountedPrice(vector<int> &prices) {
        int m = prices.size();
        stack<int> s;
        vector<int> res(m, 0);

        for (int i = 0; i < m; i++)
        {
            res[i] = prices[i];
        }

        for (int i = 0; i < m; i++)
        {
            while (!s.empty() && prices[s.top()] >= prices[i])
            {
                int index = s.top();
                s.pop();
                res[index] = prices[index] - prices[i];
            }
            s.push(i);
        }
        return res;
    }
};
```

### 122 · Largest Rectangle in Histogram

就是找某一个柱形左右连边小于他的柱形，以他们作为边界，中间的部分为最大矩形

```
class Solution {
public:
    int largestRectangleArea(vector<int> &heights) {
        if (heights.empty())
            return 0;
        int m = heights.size();
        stack<int> st;
        int res = 0;
        for (int i = 0; i <= m; i++)
        {
            int curheight = (i == m)? -1 : heights[i];
            while (!st.empty() && heights[st.top()] >= curheight)
            {
                int h = heights[st.top()]; st.pop();
                int w = st.empty()? i : (i - st.top() - 1);
                res = max(res, h * w);
            }
            st.push(i);
        }
        return res;
    }
};
```

### 1734 · Sum of Subarray Minimums

统计A种每个点是属于哪个子数组的最小值，只要找出i左边第一个比A[i]小的left，和右边第一个比A[i]小的right，所有left - right区间的子数组的最小值都是A[i]，这些子数组的个数是(i - left) * (right - i), 最后的和是(i - left) * (right - i) * A[i].
把所有的这些加到一起即为结果
相同的时候默认前面的比后边的小

```
class Solution {
public:
    int sumSubarrayMins(vector<int> &A) {
        int m = A.size();
        stack<int> fst;
        vector<int> fpos(m, 0);
        for (int i = 0; i < m; i++)
        {
            while(!fst.empty() && A[fst.top()] > A[i])
                fst.pop();
            if (fst.empty())
            {
                fpos[i] = -1;
            }
            else
            {
                fpos[i] = fst.top();
            }
            fst.push(i);
        }
        stack<int> bst;
        vector<int> bpos(m, 0);
        for (int i = m - 1; i >= 0; i--)
        {
            while(!bst.empty() && A[bst.top()] >= A[i])
                bst.pop();
            if (bst.empty())
            {
                bpos[i] = m;
            }
            else
            {
                bpos[i] = bst.top();
            }
            bst.push(i);
        }
        const long long MOD = 1e9 + 7;
        long long res = 0;
        for (int i = 0; i < m; i++)
        {
            long long finterval = i - fpos[i];
            long long binterval = bpos[i] - i;
            res += (long long)A[i] * finterval * binterval; 
            res %= MOD;
        }
        return (int)res % MOD;
    }
};
```

### 346 · xorsum of Interval extremum

以 [1, 3, 2] 为例总结下

[1] min = 1, max = 1, minXORmax = 0
[1, 3] min = 1, max = 3, minXORmax = 2
[1, 3, 2] min = 1, max = 3, minXORmax = 2
[3] min = 3, max = 3, minXORmax = 0
[3, 2] min = 2, max = 3, minXORmax = 1
[2] min = 2, max = 2, minXORmax = 0

0 xor 2 xor 2 xor 0 xor 1 xor 0 = 1

- 这个是按照题目要求做的计算，但实际这个计算本质上就是所有的min和所有的max在做一个全部的异或操作，没有先后顺序，这里面有*“四个1，五个3，三个2”*，只要把他们做一个大的异或即可
- 另一个问题是如果a ^ a = 0, 也就是在前面要异或的这些数里面如果有偶数个相同的数那么，这些偶数个数的异或结果是0，例如四个1的结果就是0，我们可以把这些结果是0的数字消掉，只计算奇数个数的数字异或。此例种我们只做2 ^ 3即可
- 对于第一个问题我们已经提到，我们只要求出所有排列的最小值和最大值，把这些数做异或即可，但是求法需要我们转换一下思路，我们要求nums[]里面每个数字，能够在多少子数组里面做最小值，以及能够在多少子数组里面做最大值。只要求出了这个，就相当于求出了第一问里面的 “四个1，五个3，三个2”， 这一步就相当于lintcode1734, 可以使用单调栈。例如计算nums[i]在多少子数组总做最小值，可以先计算nums[i]前面第一个比他小的数（因为再往前组成的子数组中，nums[i]已经不可能是最小值了）， 然后计算nums[i]后面第一个比他小的位置，最后这两个位置做一个排列计算(i - fmin[i]) * (pmin[i] - i)，即为以nums[i]为最小值的所有子数组。可以先做下lintcode1734题。
- 有了“四个1，五个3，三个2”， 就好办了，做一个循环，如果是奇数个数我们就res ^= nums[i];，偶数个直接略过即可

```
#include <functional>
class Solution {
public:
    void fstcalc(vector<int>& nums, vector<int>& vec, std::function<bool(int, int)> func)
    {
        int m = nums.size();
        stack<int> st;
        for (int i = 0; i < m; i++)
        {
            while(!st.empty() && func(nums[st.top()], nums[i]))
                st.pop();
            if (st.empty())
            {
                vec[i] = -1;
            }
            else
            {
                vec[i] = st.top();
            }
            st.push(i);
        }
    }
    void pstcalc(vector<int>& nums, vector<int>& vec, std::function<bool(int, int)> func)
    {
        int m = nums.size();
        stack<int> st;
        for (int i = m - 1; i >= 0; i--)
        {
            while(!st.empty() && func(nums[st.top()], nums[i]))
                st.pop();
            if (st.empty())
            {
                vec[i] = m;
            }
            else
            {
                vec[i] = st.top();
            }
            st.push(i);
        }
    }
    int XorSum(vector<int> &nums) {
        int m = nums.size();
        vector<int> fmin(m, 0);
        fstcalc(nums, fmin, [](int a, int b) -> bool { return a > b; });
        vector<int> pmin(m, 0);
        pstcalc(nums, pmin, [](int a, int b) -> bool { return a >= b; });
        vector<int> fmax(m, 0);
        fstcalc(nums, fmax, [](int a, int b) -> bool { return a < b; });
        vector<int> pmax(m, 0);
        pstcalc(nums, pmax, [](int a, int b) -> bool { return a <= b; });

        int res = 0;
        for (int i = 0; i < m; i++)
        {
            if (((i - fmin[i]) * (pmin[i] - i)) % 2)
            {
                res ^= nums[i];
            }

            if (((i - fmax[i]) * (pmax[i] - i)) % 2)
            {
                res ^= nums[i];
            }
        }

        return res;
    }
};
```

# 单调队列

### 362 · Sliding Window Maximum （求滑动窗口中的最大值）

维护单调队列，可以对该队列进行各种查找，二分

```
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int> &nums, int k) {
        int m = nums.size();
        deque<int> dq;
        vector<int> res;
        for (int i = 0; i < m; i++)
        {
            // 弹出出窗的元素
            if (!dq.empty() && i - k + 1 > dq.front()) dq.pop_front();
            // 弹出比当前值小的元素，保证单调性
            while (!dq.empty() && nums[dq.back()] <= nums[i]) dq.pop_back();
            dq.push_back(i);
            if (i >= k - 1)
                res.push_back(nums[dq.front()]);
        }
        return res;
    }
};
```

# 二分查找

### 1219 · Heaters

target "<=" mid 返回的是左边第一个最大的，“>=”是右边第一个最小的 

带等号的用来判断有重复数字的序列

等号，当相等的时候，期望左端的值则r = mid, 期望右端的值l = mid

```
class Solution {
public:
    int getMinRadio(vector<int> &heaters, int house)
    {
        int m = heaters.size();
        int l = 0;
        int r = m - 1;
        while (l < r)
        {
            int mid = (l + r) / 2;
            if (heaters[mid] >= house)
            {
                r = mid;
            }
            else
            {
                l = mid + 1;
            }
        }
        int rpos = l;
        l = 0;
        r = m - 1;
        while (l < r)
        {
            int mid = (l + r + 1) / 2;
            if (heaters[mid] <= house)
            {
                l = mid;
            }
            else
            {
                r = mid - 1;
            }
        }
        int lpos = l;
        int lv = abs(heaters[lpos] - house);
        int rv = abs(heaters[rpos] - house);
        return lv < rv ? lv : rv;
    }
    int findRadius(vector<int> &houses, vector<int> &heaters) {
        sort(heaters.begin(), heaters.end());
        int m = houses.size();
        int res = 0;
        for (int i = 0; i < m; i++)
        {
            int dist = getMinRadio(heaters, houses[i]);
            res = max(res, dist);
        }
        return res;
    }
};
```

### 61 · Search for a Range

### 462 · Total Occurrence of Target

```
class Solution {
public:
    int totalOccurrence(vector<int> &A, int target) {
        if (A.empty())
            return 0;
        int m = A.size();
        int l = 0;
        int r = m - 1;
        while (l < r)
        {
            int mid = (l + r) / 2;
            if (A[mid] >= target)
            {
                r = mid;
            }
            else
            {
                l = mid + 1;
            }
        }

        if (A[l] != target)
            return 0;

        int left = l;
        l = 0;
        r = m - 1;
        while (l < r)
        {
            int mid = (l + r + 1) / 2;
            if (A[mid] <= target)
            {
                l = mid;
            }
            else
            {
                r = mid - 1;
            }
        }
        int right = r;

        return right - left + 1;
    }
};
```

STL 版

```
class Solution {
public:
    int totalOccurrence(vector<int> &A, int target) {
        if (A.empty())
            return 0;
        auto left  = std::lower_bound(A.begin(), A.end(), target);
        if (left == A.end())
            return 0;
        auto right = std::upper_bound(A.begin(), A.end(), target);
        return std::distance(left, right);
    }
};
```

### 74 · First Bad Version

```
    int binarySearch(int l, int r)
    {
        if (l > r) return INT_MAX;
        int mid = l + (r - l) / 2;
        if (SVNRepo::isBadVersion(mid)) 
            return std::min(mid, binarySearch(l, mid - 1));
        return binarySearch(mid + 1, r);
    }
```

### 585 · Maximum Number in Mountain Sequence

查找山峰山谷

```
class Solution {
public:
    bool check(vector<int>& nums, int mid)
    {
        int m = nums.size();
        if (mid + 1 < m)
        {
            if (nums[mid + 1] > nums[mid])
            {
                return false;
            }
        }
        return true;
    }
    int mountainSequence(vector<int> &nums) {
        int m = nums.size();
        int l = 0; 
        int r = m - 1;
        while (l < r)
        {
            int mid = (l + r) / 2;
            if (check(nums, mid))
            {
                r = mid;
            }
            else
            {
                l = mid + 1;
            }
        }
        return nums[l];
    }
};
```

### 159 · Find Minimum in Rotated Sorted Array

要和左端点比较

```
class Solution {
public:
    int findMin(vector<int> &nums) {
        int m = nums.size();
        int l = 0;
        int r = m - 1;

        while (l < r)
        {
            if (nums[l] <= nums[r])
                return nums[l];
            int mid = (l + r) / 2;
            if (nums[mid] < nums[l])
            {
                r = mid;
            }
            else
            {
                l = mid + 1;
            }
        }
        return nums[l];
    }
};
```

### 183 · Wood Cut

在结果值域上二分，check() 返回的是包含正确结果的check(带=的)，所以应该由l = mid或r= mid处理

```
class Solution {
public:
    bool check(vector<int> &L, long mid, int k)
    {
        long divide = 0;
        for (auto n : L)
        {
            divide += n / mid;
        }
        if (divide >= k)
        {
            return true;
        }

        return false;
    }
    int woodCut(vector<int> &L, int k) {
        if (L.empty())
            return 0;
        int len = L.size();
        long minVal = -9999999999;
        for (auto n : L)
        {
            if (n > minVal)
                minVal = n;
        }

        long l = 0;
        long r = minVal;

        while (l < r)
        {
            long mid = (l + r + 1) / 2;
            if (check(L, mid, k))
            {
               l = mid;
            }
            else
            {
                r = mid - 1;
            }
        }

        return l;
    }
};
```

### 438 · Copy Books II

```
class Solution {
public:
    bool check(int n, vector<int>& times, int mid)
    {
        int most = 0;
        for (auto t : times)
        {
            most += mid / t;
        }
        return n <= most;
    }
    int copyBooksII(int n, vector<int> &times) {
        int m = times.size();
        int mint = 0x3f3f3f3f;
        for (auto t : times)
        {
            mint = min(mint, t);
        }

        int l = 0;
        int r = mint * n;
        while (l < r)
        {
            int mid = (l + r) / 2;
            if (check(n, times, mid))
            {
                r = mid;
            }
            else
            {
                l = mid + 1;
            }
        }
        return l;
    }
};
```

## 二维二分

### 390 · Find Peak Element II

```
class Solution {
public:
    bool isPeak(const vector<vector<int>> &A, int i, int j) {
        return A[i][j] > A[i + 1][j] && A[i][j] > A[i - 1][j] && 
               A[i][j] > A[i][j + 1] && A[i][j] > A[i][j - 1];
    }
    int getLineMax(vector<vector<int>>& A, int line)
    {
        int idx = 0;
        int maxv = 0;
        int m = A[0].size();
        for (int i = 0; i < m; i++)
        {
            if (maxv < A[line][i])
            {
                maxv = A[line][i];
                idx = i;
            }
        }
        return idx;
    }
    vector<int> gpeak(vector<vector<int>>& A, int l, int r)
    {
        int m = A.size();
        int mid = (l + r) / 2;
        int lineMax = getLineMax(A, mid);
        if (isPeak(A, mid, lineMax))
        {
            return {mid, lineMax};
        }
        if (mid + 1 < m && A[mid][lineMax] >= A[mid + 1][lineMax])
        {
            return gpeak(A, l, mid - 1);
        }
        else
        {
            return gpeak(A, mid + 1, r);
        }
    }
    vector<int> findPeakII(vector<vector<int>> &A) {
        int m = A.size();
        int n = A[0].size();

        return gpeak(A, 1, m - 2);
    }
};
```

# 数学

## n次方 快速幂

### 428 · Pow(x, n)   50. Pow(x, n)

```
// 如果x^(n/2)，即x的一半，是偶数，x^n = y * y
// 如果x^(n/2)，即x的一半，是奇数，x^n = y * y * x
class Solution {
public:
    double quickMul(double x, long long N) {
        if (N == 0) {
            return 1.0;
        }
        double y = quickMul(x, N / 2);
        return N % 2 == 0 ? y * y : y * y * x;
    }

    double myPow(double x, int n) {
        long long N = n;
        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
    }
};
```

```
class Solution {
public:
    double myPow(double x, int n) {
        unsigned int N = abs(n);
        double res = 1;
        double cur = x;
        while (N > 0)
        {
            if (N & 1)
            {
                res *= cur;
            }
            cur *= cur;
            N >>= 1;
        }
        return n < 0 ? 1.0 / res: res;
    }
};
```

## 质数

### 1324 · Count Primes

```
class Solution {
public:
    vector<int> primes;
    int cnt = 0;   
    bool st[2000000];     
    int res = 0;
    Solution(): primes(2000000, 0) {}

    void get_primes(int n)
    {
        for (int i = 2; i <= n; i ++ )
        {
            if (!st[i]) 
            {
                primes[cnt ++ ] = i;
            }
            for (int j = 0; primes[j] <= n / i; j ++ )
            {
                st[primes[j] * i] = true;
                if (i % primes[j] == 0) break;
            }
        }
    }

    int countPrimes(int n) {
        get_primes(n);

        for (auto c : primes)
            if (c != 0 && c != n)
                res++;
        return res;
    }
};
```

## 高精度

```
// C = A + B, A >= 0, B >= 0
vector<int> add(vector<int> &A, vector<int> &B)
{
    if (A.size() < B.size()) return add(B, A);

    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i ++ )
    {
        t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }

    if (t) C.push_back(t);
    return C;
}
```

### 2. Add Two Numbers

# 并查集

### 1179 · Friend Circles

```
class Solution {
public:
    int find(vector<int>& p, int x)
    {
        if (p[x] != x) p[x] = find(p, p[x]);
        return p[x];
    }
    int findCircleNum(vector<vector<int>> &M) {
        if (M.empty())
            return 0;
        int m = M.size();
        int n = M[0].size();
        vector<int> p(m);
        for (int i = 0; i < m; i++)
        {
            p[i] = i;
        }

        for (int i = 0; i < m; i++)
        {
            for (int j = i + 1; j < n; j++)
            {
                if (M[i][j] == 1)
                {
                    p[find(p, i)] = find(p, j);
                }
            }
        }

        set<int> resset;
        for (int i = 0; i < m; i++)
        {
            resset.insert(find(p, i));
        }

        return resset.size();
    }
};
```

### 677 · Number of Big Islands

计算size的模板

```
class Solution {
public:
    int p[90000] = {0};
    int size[90000] = {0};
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
            return p[x];
    }
    int getIndex(int x, int y, int n)
    {
        return x * n + y;
    }
    bool inBound(int x, int y, int m, int n)
    {
        if (x >= m || y >= n || x < 0 || y < 0)
            return false;
        return true;
    }
    int numsofIsland(vector<vector<bool>> &grid, int k) {
        if (grid.empty())
            return 0;
        int m = grid.size();
        int n = grid[0].size();

        int dx[4] = {1, 0, -1, 0};
        int dy[4] = {0, 1, 0, -1};

        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                p[getIndex(i, j, n)] = getIndex(i, j, n);
                if (grid[i][j])
                    size[getIndex(i, j, n)] = 1;
            }
        }

        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (!grid[i][j])
                    continue;
                for (int k = 0; k < 4; k++)
                {
                    int nx = i + dx[k];
                    int ny = j + dy[k];

                    if (!inBound(nx, ny, m, n))
                        continue;

                    if (grid[nx][ny] == true)
                    {
                        if (find(getIndex(i, j, n)) != find(getIndex(nx, ny, n)))
                        {
                            size[find(getIndex(nx, ny, n))] += size[find(getIndex(i, j, n))];
                            size[find(getIndex(i, j, n))] = 0;
                            p[find(getIndex(i, j, n))] = find(getIndex(nx, ny, n));
                        }
                    }
                }
            }
        }
        int res = 0;
        int maxInd = getIndex(m - 1, n - 1, n);
        for (int i = 0; i <= maxInd; i++)
        {
            if (size[i] >= k)
                res++;   
        }

        return res;
    }
};
```

### 805 · Maximum Association Set

字符并查集

```
class UnionFind {
public:
    unordered_map<string, string> m;
    UnionFind(){}

    /*
    string find(string s) {
        if (m[s] != s) {
            m[s] = find(m[s]);
        }
        return m[s];
    }
    */

    string find(string s) {
        while (m.find(s) != m.end()) {
            s = m[s];
        }
        return s;
    }

    vector<string> getAnswer() {
        vector<string> ans;
        unordered_map<string, unordered_set<string>> temp;
        for (auto a : m) {
            string s = find(a.first);
            temp[s].insert(a.first);
            temp[s].insert(s);
        }
        for (auto a : temp) {
            if (a.second.size() > ans.size()) {
                ans = vector<string>(a.second.begin(), a.second.end());
            }
        }
        return ans;
    }

    void connect(string s1, string s2) {
        string ss1 = find(s1);
        string ss2 = find(s2);

        if (ss1 == ss2) return;
        if (ss1 < ss2) {
            m[ss1] = ss2;
        } else {
            m[ss2] = ss1;
        }
    }
};

class Solution {
public:
    vector<string> maximumAssociationSet(vector<string> &ListA, vector<string> &ListB) {
        UnionFind uf;
        for (int i = 0; i < ListA.size(); i++) {
            uf.connect(ListA[i], ListB[i]);
        }

        return uf.getAnswer();
    }
};
```

## 初始化 集合计算

### 434 · Number of Islands II

```
class Solution {
public:
    int p[100000];
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
    int index(int x, int y, int m)
    {
        return x * m + y;
    }
    vector<int> numIslands2(int n, int m, vector<Point> &operators) {
        if (operators.empty())
            return {};

        vector<int> res;
        unordered_set<int> nodes;
        int s = operators.size();
        unordered_set<int> current;
        int dx[4] = {0, 1, 0, -1};
        int dy[4] = {1, 0, -1, 0};
        int total = 0;
        for (int i = 0; i < s; i++)
        {
            int pos = index(operators[i].x, operators[i].y, m);
            nodes.insert(pos);
            if (current.count(pos))
            {
                res.push_back(total);
                continue;
            }
            total++;
            p[pos] = pos;
            for (int j = 0; j < 4; j++)
            {
                int nx = operators[i].x + dx[j];
                int ny = operators[i].y + dy[j];
                if (!(nx >= 0 && nx < n && ny >= 0 && ny < m)) 
                    continue;
                if (current.count(index(nx, ny, m)))
                {
                    int apos = index(operators[i].x, operators[i].y, m);
                    int bpos = index(nx, ny, m);
                    if (find(apos) != find(bpos))
                    {
                        p[find(apos)] = find(bpos);
                        total--;
                    }
                }
            }

            current.insert(index(operators[i].x, operators[i].y, m));
            res.push_back(total);
        }

        return res;
    }
};
```

## Size计算

### 590 · Connecting Graph II

1. if (find(a) == find(b)) 

2. size[find(b)] += size[find(a)];  // 顺序相反
   
         p[find(a)] = find(b);

3. size[i] = 1;

4. return size[find(a)];
   
   ```
   class ConnectingGraph2 {
   public:
    int p[100000];
    int size[100000];
    ConnectingGraph2(int n) {
        for (int i = 0; i <= n; i++)
        {
            p[i] = i;
            size[i] = 1;
        }
    }
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
   
    void connect(int a, int b) {
        if (find(a) == find(b)) 
            return;
        size[find(b)] += size[find(a)];
        p[find(a)] = find(b);
    }
   
    int query(int a) {
        return size[find(a)];
    }
   };
   ```

# 图论

## DFS

### 1514 · Robot Room Cleaner

```
class Solution {
public:
    void restore(Robot& robot)
    {
        robot.turnRight();
        robot.turnRight();
        robot.move();
        robot.turnRight();
        robot.turnRight();
    }
    void dfs(Robot& robot, int x, int y, set<pair<int, int>>& visit, int dirction)
    {
        int dx[4] = {-1, 0, 1, 0};
        int dy[4] = {0, 1, 0, -1};
        robot.clean();
        for (int i = 0; i < 4; i++)
        {
            int nx = x + dx[dirction];
            int ny = y + dy[dirction];
            if (visit.count({nx, ny}))
            {
                dirction = (dirction + 1) % 4;
                robot.turnRight();
                continue;
            }

            if (robot.move())
            {
                visit.insert({nx, ny});
                dfs(robot, nx, ny, visit, dirction);
                restore(robot);
            }
            dirction = (dirction + 1) % 4;
            robot.turnRight();
        }
    }
    void cleanRoom(Robot& robot) {
        set<pair<int, int>> visit;
        visit.insert({0, 0});
        dfs(robot, 0, 0, visit, 0);
    }
};
```

## BFS

### 611 · Knight Shortest Path

```
class Solution {
public:
    bool isNotOut(int x, int y, int m, int n)
    {
        if (x >= m || y >= n || x < 0 || y < 0)
            return false;
        return true;
    }
    int shortestPath(vector<vector<bool>> &grid, Point &source, Point &destination) {
        int m = grid.size();
        int n = grid[0].size();

        int dx[8] = {1, 1, -1, -1, 2, 2, -2, -2};
        int dy[8] = {2, -2, 2, -2, 1, -1, 1, -1};
        vector<vector<bool>> visit(m, vector<bool>(n, false));
        queue<Point> q;
        q.push(source);

        int step = 0;
        while (!q.empty())
        {
            int levelnum = q.size();
            step++;
            while (levelnum--)
            {
                auto cur = q.front(); q.pop();
                if (cur.x == destination.x && cur.y == destination.y)
                    return step-1;
                for (int i = 0; i < 8; i++)
                {
                    int nx = cur.x + dx[i];
                    int ny = cur.y + dy[i];

                    if (isNotOut(nx, ny, m, n) && !visit[nx][ny] && !grid[nx][ny])
                    {
                        q.push(Point(nx, ny));
                        visit[nx][ny] = true;
                    }
                }
            }
        }

        return -1;
    }
};
```

### 137 · Clone Graph

```
// DFS
class Solution {
public:
    UndirectedGraphNode* dfs(UndirectedGraphNode* node, unordered_map<int, UndirectedGraphNode*>& visit)
    {
        if (!node)
            return nullptr;

        auto it = visit.find(node->label);
        if (it == visit.end())
        {
            UndirectedGraphNode* current = new UndirectedGraphNode(node->label);
            visit.insert(make_pair(current->label, current));
            for (auto c : node->neighbors)
            {
                UndirectedGraphNode* child = dfs(c, visit);
                current->neighbors.push_back(child);
            }
        }

        return visit[node->label];
    }

    UndirectedGraphNode* cloneGraph(UndirectedGraphNode* node) {
        if (!node)
        {
            return nullptr;
        }

        unordered_map<int, UndirectedGraphNode*> visit;
        return dfs(node, visit);
    }
};

// BFS
class Solution {
public:
    UndirectedGraphNode* cloneGraph(UndirectedGraphNode* node) {
        if (!node)
        {
            return nullptr;
        }
        unordered_map<UndirectedGraphNode*, UndirectedGraphNode*> nodeMap;
        queue<UndirectedGraphNode*> q;
        nodeMap.insert(make_pair(node, new UndirectedGraphNode(node->label)));
        q.push(node);
        while (!q.empty())
        {
            auto cur = q.front(); q.pop();
            for (auto c : cur->neighbors)
            {
                auto it = nodeMap.find(c);
                if (it == nodeMap.end())
                {
                    UndirectedGraphNode* tmpnode = new UndirectedGraphNode(c->label);
                    nodeMap.insert(make_pair(c, tmpnode));
                    nodeMap[cur]->neighbors.push_back(tmpnode);
                    q.push(c);
                }
                else
                {
                    nodeMap[cur]->neighbors.push_back(nodeMap[c]);
                }
            }
        }

        return nodeMap[node];
    }
};
```

### DFS BFS 标准模板题 1563 · Shortest path to the destination

DFS

```
class Solution {
public:
    bool isInBound(int x, int y, int m, int n)
    {
        if (x >= m || x < 0 || y >= n || y < 0)
            return false;
        return true;
    }
    void dfs(vector<vector<int>> &targetMap, vector<vector<bool>> &vis, int x, int y, int current, int& res)
    {
        if (targetMap[x][y] == 2)
        {
            res = min (res, current);
            return;
        }
        int dx[4] = {1,  0, -1, 0};
        int dy[4] = {0, -1,  0, 1};
        int m = targetMap.size();
        int n = targetMap[0].size();
        for (int i = 0; i < 4; i++)
        {
            int nx = x + dx[i];
            int ny = y + dy[i];

            if (isInBound(nx, ny, m, n) && !vis[nx][ny] && targetMap[nx][ny] != 1)
            {
                vis[nx][ny] = true;
                dfs(targetMap, vis, nx, ny, current + 1, res);
                vis[nx][ny] = false;
            }
        }
    }
    int shortestPath(vector<vector<int>> &targetMap) {
        int res = INT_MAX;
        int m = targetMap.size();
        int n = targetMap[0].size();
        vector<vector<bool>> vis(m + 1, vector<bool>(n + 1, false));
        dfs(targetMap, vis, 0, 0, 0, res);
        return res == INT_MAX? -1: res;
    }
};
```

BFS

```
class Solution {
public:
    bool isInBound(int x, int y, int m, int n)
    {
        if (x >= m || x < 0 || y >= n || y < 0)
            return false;
        return true;
    }
    int shortestPath(vector<vector<int>> &targetMap) {
        int m = targetMap.size();
        int n = targetMap[0].size();
        int dx[4] = {1,  0, -1, 0};
        int dy[4] = {0, -1,  0, 1};
        vector<vector<bool>> visit(m, vector<bool>(n, false));
        queue<pair<int, int>> q;
        q.push(make_pair(0, 0));
        visit[0][0] = true;
        int step = 0;
        while (!q.empty())
        {
            int levelcount = q.size();
            while(levelcount--)
            {
                auto cur = q.front(); q.pop();
                if (targetMap[cur.first][cur.second] == 2)
                    return step;
                for (int i = 0; i < 4; i++)
                {
                    int nx = cur.first + dx[i];
                    int ny = cur.second + dy[i];
                    if (isInBound(nx, ny, m, n) && !visit[nx][ny] && targetMap[nx][ny] != 1)
                    {
                        q.push(make_pair(nx, ny));
                        visit[nx][ny] = true;
                    }
                }
            }
            step++;
        }
        return -1;
    }
};
```

### BFS记录路径的方法

```
#include<cstdio>
#include<queue>
using namespace std;
struct sss
{
    int x,y;
}ans[6][6];
int map[6][6];
int flag[6][6];
int dec[4][2]={1,0,0,1,-1,0,0,-1};
void print(struct sss q)
{
    if(q.x==0&&q.y==0)
    {
        printf("(0, 0)\n");
        return;
    }
    else
    {
        print(ans[q.x][q.y]);
        printf("(%d, %d)\n",q.x,q.y);
    }
}
void bfs(int x,int y)
{
    struct sss q;
    queue<struct sss> s;
    flag[0][0]=1;
    q.x=x;
    q.y=y;
    s.push(q);
    ans[0][0].x=-1;
    ans[0][0].y=-1;
    while(!s.empty())
    {
        q=s.front();
        s.pop();
        if(q.x==4&&q.y==4)
        {
            print(q);
            return;
        }
        for(int i=0;i<4;i++)
        {
            int xx=dec[i][0]+q.x;
            int yy=dec[i][1]+q.y;
            if(xx>=0&&xx<5&&yy>=0&&yy<5&&flag[xx][yy]==0&&map[xx][yy]==0)
            {
                struct sss w;
                w.x=xx;
                w.y=yy;
                s.push(w);
                flag[xx][yy]=1;
                ans[xx][yy].x=q.x;
                ans[xx][yy].y=q.y;
            }
        }
    }
}
int main()
{
    for(int i=0;i<5;i++)
    {
        for(int j=0;j<5;j++)
        {
            scanf("%d",&map[i][j]);
        }
    }
    bfs(0,0);
}






#include<cstdio>
#include<cmath>
#include<vector>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<queue>
#include<map>
#include<string>
using namespace std;
typedef long long ll;
char mp[1001][1001];
int n,m,k;
int flag;
int d[1001][1001];
char jg[1000001];
char yx[1000001];
int dis[4][2]={1,0,0,-1,0,1,-1,0};
char str[5]={"DLRU"};
void pan(int x,int y){
    //printf("k=%d\n",k);
    int tmp=k;
    for(int i=0;i<k;i++){
        int dex=-1;
        for(int j=0;j<4;j++){
            pair<int,int> z;
            z.first=x+dis[j][0];
            z.second=y+dis[j][1];
            if(z.first>=0&&z.first<n&&z.second>=0&&z.second<m&&mp[z.first][z.second]!='*'&&d[z.first][z.second]<tmp){
                dex=j;
                break;
            }
        }
        tmp--;
        x=x+dis[dex][0];
        y=y+dis[dex][1];
        jg[i]=str[dex];
    }
    jg[k]='\0';
    printf("%s\n",jg);
}
void bfs(int x,int y)
{
    queue<pair<int,int> > q;
    q.push(make_pair(x,y));
    for(int i=0;i<1000;i++){
        for(int j=0;j<1000;j++)
          d[i][j]=10000000;
    }
    int num=0;
    d[x][y]=0;
    while(!q.empty()){
        pair<int,int> w=q.front();
        q.pop();
        num++;
        for(int i=0;i<4;i++){
            pair<int,int> z;
            z.first=w.first+dis[i][0];
            z.second=w.second+dis[i][1];
            if(z.first>=0&&z.first<n&&z.second>=0&&z.second<m&&mp[z.first][z.second]=='.'){
                if(d[z.first][z.second]>d[w.first][w.second]+1){
                    d[z.first][z.second]=d[w.first][w.second]+1;
                    q.push(z);
                }
            }
        }
    }
    /*for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            if(d[i][j]==10000000) printf("%4d",-1);
            else printf("%4d",d[i][j]);
        }
        printf("\n");
    }*/
//    printf("num=%d\n",num);
    if(num==1) printf("IMPOSSIBLE");
    else pan(x,y);
}
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    for(int i=0;i<n;i++){
        scanf("%s",mp[i]);
    }
    if(k%2){
        printf("IMPOSSIBLE");
        return 0;
    }
    int vis=0;
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++)
        {
            if(mp[i][j]=='X')
            {
                mp[i][j]='.';
                bfs(i,j);
                vis=1;
                break;    
            }        
        }
        if(vis) break;
    }
}
```

### 1446 · 01 Matrix Walking Problem

## 拓扑排序

### 127 · Topological Sorting

```
class Solution {
public:
    vector<DirectedGraphNode*> topSort(vector<DirectedGraphNode*> graph) {
        if (graph.empty())
            return {};
        unordered_map<DirectedGraphNode*, int> inDegree;
        for (auto n : graph)
        {
            auto it = inDegree.find(n);
            if (it == inDegree.end())
                inDegree[n] = 0;
            for (auto outn : n->neighbors)
            {
                inDegree[outn]++;
            }
        }

        queue<DirectedGraphNode*> q;
        for (auto n : inDegree)
        {
            //cout << n.first->label << " " << n.second << endl;
            if (n.second == 0)
            {

                q.push(n.first);
            }
        }
        vector<DirectedGraphNode*> res;
        while (!q.empty())
        {
            auto cur = q.front(); q.pop();
            res.push_back(cur);
            for (auto c : cur->neighbors)
            {
                if (!(--inDegree[c]))
                    q.push(c);
            }
        }

        return res;
    }
};
```

### 615 · Course Schedule

### 616 · Course Schedule II

```
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<pair<int, int>> &prerequisites) {
        unordered_map<int, vector<int>> g;
        unordered_map<int, int> inDegree;
        for (int i = 0; i < numCourses; i++)
        {
            inDegree[i] = 0;
        }

        for (auto n : prerequisites)
        {
            g[n.second].push_back(n.first);
            inDegree[n.first]++;
        }

        queue<int> q;
        for (auto n : inDegree)
        {
            if (!n.second)
            {
                q.push(n.first);
            }
        }

        vector<int> res;
        while (!q.empty())
        {
            auto cur = q.front(); q.pop();
            res.push_back(cur);

            for (auto n : g[cur])
            {
                if (!(--inDegree[n]))
                {
                    q.push(n);
                }
            }
        }

        return (res.size() != numCourses) ? vector<int>() : res;
    }
};
```

## 爆搜

### 33 · N-Queens

```
class Solution {
public:
    /*
     * @param n: The number of queens
     * @return: All distinct solutions
     */
    void dfs(int r, int n, vector<string>& path, vector<vector<string>>& res)
    {      
        if (r == n)
        {
            res.push_back(path);
            return;
        }
        for (int i = 0; i < n; i++)
        {
            if (!col[i] && !row[i] && !dg[r + i] && !udg[r - i + n])
            {
                path[r][i] = 'Q';
                col[i] = row[i] = dg[r + i] = udg[r - i + n] = true;
                dfs(r + 1, n, path, res);
                path[r][i] = '.';
                col[i] = row[i] = dg[r + i] = udg[r - i + n] = false;
            }
        }
    }
    vector<bool> col;
    vector<bool> row;
    vector<bool> dg;
    vector<bool> udg;
    vector<vector<string>> solveNQueens(int n) {
        if (!n)
            return {};
        vector<bool> lcol(n, false);
        vector<bool> lrow(n, false);
        vector<bool> ldg(2 * n, false);
        vector<bool> ludg(2 * n, false);
        col = lcol;
        row = lrow;
        dg = ldg;
        udg = ludg;

        vector<vector<string>> res;
        vector<string> path(n, string(n, '.'));

        dfs(0, n, path, res);
        return res;
    }
};
```

### 802 · Sudoku Solver

```
class Solution {
public:
    /**
     * @param board: the sudoku puzzle
     * @return: nothing
     */
    bool col[9][10]; 
    bool row[9][10];
    bool cell[3][3][10];
    bool dfs(vector<vector<int>>& board, int x, int y)
    {
        //cout << x << " " << y << endl;
        if (y == 9) 
        {
            x++;
            y = 0;
        }
        if (x == 9)
        {
            return true;
        }

        if (board[x][y] != 0)
            return dfs(board, x, y + 1);

        for (int i = 0; i < 9; i++)
        {
            if (!col[x][i] && !row[y][i] && !cell[x / 3][y / 3][i])
            {
                board[x][y] = i + 1;
                col[x][i] = true; row[y][i] = true; cell[x / 3][y / 3][i] = true;
                if (dfs(board, x, y + 1))
                    return true;
                board[x][y] = 0;
                col[x][i] = false; row[y][i] = false; cell[x / 3][y / 3][i] = false;
            }
        }
        return false;
    }
    void solveSudoku(vector<vector<int>> &board) {

        memset(col, 0, 9 * 10 * sizeof(bool));
        memset(row, 0, 9 * 10 * sizeof(bool));
        memset(cell, 0, 3 * 3 * 10 * sizeof(bool));
        for (int i = 0; i < 9; i++)
        {
            for (int j = 0; j < 9; j++)
            {
                if (board[i][j] != 0)
                {
                    col[i][board[i][j] - 1] = true;
                    row[j][board[i][j] - 1] = true;
                    cell[i / 3][j / 3][board[i][j] - 1] = true;
                }
            }
        }

        dfs(board, 0, 0);

    }
};
```

## SPFA

以bfs为基础，把选择条件换成只要距离更新了就入队

### 1565 · Modern Ludo I

```
class Solution {
public:
    int modernLudo(int length, vector<vector<int>> &connections) {
        int m = connections.size();
        vector<int> st(length + 1, 0);
        queue<int> q;
        q.push(1);
        st[1] = true;
        vector<int> dist(length + 1, INT_MAX);
        dist[1] = 0;
        while (!q.empty())
        {
            auto cur = q.front(); q.pop();
            st[cur] = false;
            for (auto e : connections)
            {
                if (e[0] == cur)
                {
                    if (dist[e[1]] > dist[cur])  // dist[e[1]] > dist[cur] + 0
                    {
                        dist[e[1]] = dist[cur];
                        if (!st[e[1]])
                        {
                            q.push(e[1]);
                            st[e[1]] = true;
                        }
                    }
                }
            }
            for (int i = 1; i <= 6; i++)
            {
                auto target = cur + i;
                if (target > length)
                    break;
                if (dist[target] > dist[cur] + 1)
                {
                    dist[target] = dist[cur] + 1;
                    if (!st[target])
                    {
                        q.push(target);
                        st[target] = true;
                    }
                }
            }
        }

        return dist[length];
    }
};
```

### 1469 · Longest Path On The Tree(树的直径)

树的直径，就是从任一点开始找到最远距离点，再从这个最远距离点找另外一个最远距离点，这两点之间就是直径

```
class Solution {
public:
    void spfa(int n, unordered_map<int, vector<pair<int, int>>>& g, int start, int& maxindex, int& maxdist)
    {
        vector<bool> visit(n, false);
        vector<int> dist(n, 0x3f3f3f3f);
        queue<int> q;
        q.push(start);
        visit[start] = true;
        dist[start] = 0;
        while(!q.empty())
        {
            auto cur = q.front(); q.pop();
            visit[cur] = false;
            int m = g[cur].size();
            for (int i = 0; i < m; i++)
            {
                if (dist[g[cur][i].first] > dist[cur] + g[cur][i].second)
                {
                    dist[g[cur][i].first] = dist[cur] + g[cur][i].second;
                    if (maxdist < dist[g[cur][i].first])
                    {
                        maxdist  = dist[g[cur][i].first];
                        maxindex = g[cur][i].first;
                    }
                    if (!visit[g[cur][i].first])
                    {
                        q.push(g[cur][i].first);
                        visit[g[cur][i].first] = true;
                    }
                }
            }
        }
    }
    int longestPath(int n, vector<int> &starts, vector<int> &ends, vector<int> &lens) {
        unordered_map<int, vector<pair<int, int>>> g;
        int m = starts.size();
        for (int i = 0; i < n - 1; i++)
        {
            g[starts[i]].push_back({ends[i], lens[i]});
            g[ends[i]].push_back({starts[i], lens[i]});
        }

        int maxi = 0;
        int maxd = 0;
        spfa(n, g, 0, maxi, maxd);
        spfa(n, g, maxi, maxi, maxd);
        return maxd;
    }
};
```

### 1862 · Time to Flower Tree

```
class Solution {
public:
    int timeToFlowerTree(vector<int> &father, vector<int> &time) {
        set<tuple<int, int, int>> edges;
        int m = father.size();
        for (int i = 1; i < m; i++)
        {
            edges.insert({father[i], i, time[i]});
        }
        vector<int> dist(m, 0x3f3f3f3f);
        dist[0] = 0;
        queue<int> q;
        q.push(0);
        vector<bool> visit(m, false);
        visit[0] = true;
        while (!q.empty())
        {
            auto cur = q.front(); q.pop();
            visit[cur] = false;
            for (auto e : edges)
            {
                if (get<0>(e) != cur)
                    continue;
                if (dist[get<1>(e)] > dist[cur] + get<2>(e))
                {
                    dist[get<1>(e)] = dist[cur] + get<2>(e);
                    if (!visit[get<1>(e)])
                    {
                        q.push(get<1>(e));
                        visit[get<1>(e)] = true;
                    }
                }
            }
        }
        int res = 0;
        for (auto d : dist)
        {
            res = max(res, d);
        }

        return res;
    }
};
```

### 258 · Map Jump

```
class Solution {
public:
    int idx(int x, int y, int n)
    {
        return x * n + y;
    }
    bool isInBound(int x, int y, int m, int n)
    {
        if (x >= m || y >= n || x < 0 || y < 0)
            return false;
        return true;
    }
    int mapJump(vector<vector<int>> &arr) {
        int m = arr.size();
        int n = arr[0].size();
        int dx[4] = {0, 1, 0, -1};
        int dy[4] = {1, 0, -1, 0};
        vector<int>  dist(m * n, 0x3f3f3f3f);
        queue<pair<int, int>> q;
        q.push({0, 0});
        dist[idx(0, 0, n)] = 0;
        while (!q.empty())
        {
            auto cur = q.front(); q.pop();
            for (int i = 0; i < 4; i++)
            {
                int nx = cur.first  + dx[i];
                int ny = cur.second + dy[i];
                if (!isInBound(nx, ny, m, n))
                    continue;

                int h = max(dist[idx(cur.first, cur.second, n)], abs(arr[nx][ny] - arr[cur.first][cur.second]));
                if (dist[idx(nx, ny, n)] > h)
                {
                    dist[idx(nx, ny, n)] = h;
                    q.push({nx, ny});
                }
            }
        }
        return dist[idx(m - 1, n - 1, n)];

    }
};
```

### 1569 · Social Network

```
class Solution {
public:
    string socialNetwork(int n, vector<int> &a, vector<int> &b) {
        int m = a.size();
        unordered_map<int, unordered_set<int>> g;
        for (int i = 0; i < m; i++)
        {
            g[a[i]].insert(b[i]);
            g[b[i]].insert(a[i]);
        }

        vector<int> dist(n + 1, 0x3f3f3f3f);
        vector<bool> visit(n, false);
        queue<int> q;
        q.push(1);
        visit[1] = true;
        dist[1] = 0;
        while (!q.empty())
        {
            auto cur = q.front(); q.pop();
            visit[cur] = false;
            for (auto s : g[cur])
            {
                if (dist[s] >= dist[cur] + 1)
                {
                    dist[s] = dist[cur] + 1;
                    if (!visit[s])
                    {
                        q.push(s);
                        visit[s] = true;
                    }
                }
            }
        }

        for (int i = 1; i <= n; i++)
        {
            if (dist[i] == 0x3f3f3f3f)
                return "no";
        }
        return "yes";
    }
};
```

## Dijkstra

### 1057 · Network Delay Time

```
class Solution {
public:
    int networkDelayTime(vector<vector<int>> &times, int N, int K) {
        vector<vector<int>> g(N + 1, vector<int>(N + 1, 0x3f3f3f3f));
        for (auto e : times)
        {
            g[e[0]][e[1]] = min(g[e[0]][e[1]], e[2]);
        }
        vector<int> dist(N + 1, 0x3f3f3f3f);
        vector<bool> visit(N + 1, false);
        dist[K] = 0;
        for (int i = 0; i < N; i++)
        {
            int t = -1;
            for (int j = 1; j <= N; j++)
            {
                if (!visit[j] && (t == -1 || dist[t] > dist[j]))
                    t = j;
            }
            for (int j = 1; j <= N; j++)
            {
                if (dist[j] > dist[t] + g[t][j])
                {
                    dist[j] = dist[t] + g[t][j];
                }
            }
            visit[t] = true;
        }

        int res = 0;
        for (int i = 1; i <= N; i++)
        {
            if (dist[i] == 0x3f3f3f3f)
                return -1;
            res = max(res, dist[i]);
        }
        return res;
    }
};
```
## 记忆化搜索
### 582 · Word Break II

```
class Solution {
public:
    vector<string> dfs(string s, unordered_set<string> &dict, unordered_map<string, vector<string>>& memo)
    {
        if (memo.count(s))
        {
            return memo[s];
        }

        vector<string> res;
        if (s.empty())
        {
            return res;
        }

        if (dict.count(s))
        {
            res.push_back(s);
        }

        int m = s.size();
        for (int len = 1; len < m; len++)
        {
            string word = s.substr(0, len);
            if (!dict.count(word))
                continue;
            
            auto ret = dfs (s.substr(len), dict, memo);

            for (auto w : ret)
            {
                res.push_back(word + " " + w);
            }
        }
        memo.insert({s, res});
        return res;
    }
    vector<string> wordBreak(string &s, unordered_set<string> &wordDict) {
        unordered_map<string, vector<string>> memo;
        return dfs(s, wordDict, memo);
    }
};
```



### 192 · Wildcard Matching

```
class Solution {
public:
    bool dfs(string &s, int si, string &p, int pi, vector<vector<bool>>& visit, vector<vector<bool>>& memo)
    {
        int m = s.size();
        int n = p.size();
        if (pi == n)
        {
            return si == m;
        }

        if (si == m)
        {
            for (int i = pi; i < n; i++)
            {
                if (p[i] != '*')
                    return false;
            }
            return true;
        }

        if (visit[si][pi])
            return memo[si][pi];

        char sc = s[si];
        char pc = p[pi];
        bool match = false;
        if (pc == '*')
        {
            match = dfs(s, si, p, pi + 1, visit, memo) || 
                    dfs(s, si + 1, p, pi, visit, memo);
        }
        else
        {
            if (sc == pc || pc == '?')
            {
                match = dfs(s, si + 1, p, pi + 1, visit, memo);
            }
        }

        visit[si][pi] = true;
        memo[si][pi] = match;
        return match;
    }
    bool isMatch(string &s, string &p) {
        int m = s.size();
        int n = p.size();
        vector<vector<bool>> visit(m, vector<bool>(n, false));
        vector<vector<bool>> memo(m, vector<bool>(n, false));
        return dfs(s, 0, p, 0, visit, memo);
    }
};
```

### 114 · Unique Paths

```
class Solution {
public:
    bool isInBoundary(int x, int y, int m, int n)
    {
        if (x >= m || y >= n || x < 0 || y < 0)
            return false;
        return true;
    }
    int dfs(int x, int y, int m, int n, vector<vector<bool>>& visit, vector<vector<int>>& memo)
    {
        if (x == m - 1 && y == n - 1)
        {
            return 1;
        }

        if (memo[x][y])
            return memo[x][y];

        int dx[2] = {1, 0};
        int dy[2] = {0, 1};
        int res = 0;
        for (int i = 0; i < 2; i++)
        {
            int nx = x + dx[i];
            int ny = y + dy[i];

            if (!isInBoundary(nx, ny, m, n) || visit[nx][ny])
                continue;
            visit[nx][ny] = true;
            res += dfs(nx, ny, m, n, visit, memo);
            visit[nx][ny] = false;
        }
        memo[x][y] = res;
        return res;
    }
    int uniquePaths(int m, int n) {
        vector<vector<bool>> visit(m, vector<bool>(n, false));
        vector<vector<int>>  memo(m, vector<int>(n, 0));
        return dfs(0, 0, m, n, visit, memo);
    }
};
```



## 二分图 染色法

### 1596 · Possible Bipartition

```
class Solution {
public:
    bool dfs(unordered_map<int, vector<int>>& g, vector<int>& color, int curcolor, int p)
    {
        color[p] = curcolor;
        for (auto n : g[p])
        {
            if (color[n] == -1)
            {
                if(!dfs(g, color, !curcolor, n))
                    return false;
            }
            else if (color[n] == curcolor)
                return false;
        }
        return true;
    }
    bool possibleBipartition(int N, vector<vector<int>> &dislikes) {
        int m = dislikes.size();
        unordered_map<int, vector<int>> g;
        for (int i = 0; i < m; i++)
        {
            g[dislikes[i][0]].push_back(dislikes[i][1]);
            g[dislikes[i][1]].push_back(dislikes[i][0]);
        }
        vector<int> color(m + 1, -1);
        for (int i = 1; i <= m; i++)
        {
            if (color[i] == -1)
            { 
                if (!dfs(g, color, 0, i))
                    return false;
            }
        }
        return true;
    }
};
```

# 二叉树

### 97 · Maximum Depth of Binary Tree

```
class Solution:
    """
    @param root: The root of binary tree.
    @return: An integer
    """
    def maxDepth(self, root):
        if root is None:
            return 0
        leftDepth = self.maxDepth(root.left)
        rightDepth = self.maxDepth(root.right)
        return max(leftDepth, rightDepth) + 1
```

### 1360 · Symmetric Tree

```
class Solution {
public:
    bool isSymmetric (TreeNode* root) {
        return root == nullptr || isSymmetricHelp (root->left, root->right);
    }
    bool isSymmetricHelp (TreeNode* left, TreeNode* right) {
        if (left == nullptr || right == nullptr) {
            return left == nullptr && right == nullptr;
        }
        if (left->val != right->val) {
            return false;
        }
        return isSymmetricHelp (left->left, right->right) && isSymmetricHelp (left->right, right->left);
    }
};
```

### 1311 · Lowest Common Ancestor of a Binary Search Tree

```
class Solution {
public:
    TreeNode* dfs(TreeNode * root, TreeNode * p, TreeNode * q)
    {
        if (root == p || root == q)
            return root;
        if (q->val <= root->val && p->val <= root->val)
        {
            return dfs(root->left, p, q);
        }
        else if (q->val >= root->val && p->val >= root->val)
        {
            return dfs(root->right, p, q);
        }
        return root;
    }
    TreeNode * lowestCommonAncestor(TreeNode * root, TreeNode * p, TreeNode * q) {
        return dfs(root, p, q);
    }
};
```

### 88 · Lowest Common Ancestor of a Binary Tree(LCA)

```
class Solution {
public:
    TreeNode* ans;
    bool dfs(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == nullptr) return false;
        bool lson = dfs(root->left, p, q);
        bool rson = dfs(root->right, p, q);
        if ((lson && rson) || ((root->val == p->val || root->val == q->val) && (lson || rson))) 
        {
            ans = root;
        } 
        return lson || rson || (root->val == p->val || root->val == q->val);
    }
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        dfs(root, p, q);
        return ans;
    }
};
```

### 1593 · Construct Binary Tree from Preorder and Postorder Traversal

```

```

### 72 · Construct Binary Tree from Inorder and Postorder Traversal

```

```

### 73 · Construct Binary Tree from Preorder and Inorder Traversal

```

```

## BST 建树，插入

### 1561 · BST节点距离

```
class Solution {
public:
    TreeNode* insert(TreeNode* root, int node){
        if (root == NULL){
            return new TreeNode(node);
        }
        if (root->val > node){
            root->left = insert(root->left, node);
        }
        else if (root->val < node){
            root->right = insert(root->right, node);
        }
        return root;
    } 

    TreeNode build(vector<int> &numbers){
        TreeNode root = TreeNode(numbers[0]);
        int len = numbers.size();
        for (int i = 1; i < len; i++){
            insert(&root, numbers[i]);
        }
        return root;
    }

    bool check(vector<int> &numbers, int node1, int node2){
        bool flag1 = false, flag2 = false;
        for (auto &i: numbers){
            if (i == node1){
                flag1 = true;
            }
            if (i == node2){
                flag2 = true;
            }
        }
        return (flag1 && flag2);
    }

    int findDis(TreeNode* root, int node) {
        int dis = 0;
        while (root->val != node) {
            dis ++;
            if (root->val > node) {
                root = root->left;
            } else {
                root = root->right;
            }
        }
        return dis;
    }

    int bstDistance(vector<int> &numbers, int node1, int node2) {
        if (numbers.size() < 2){
            return -1;
        }
        if (!check(numbers, node1, node2)){
            return -1;
        }
        TreeNode root = build(numbers);
        while (node1 > root.val && node2 > root.val || node1 < root.val && node2 < root.val) {
            if (node1 > root.val && node2 > root.val) {
                root = *root.right;
            } else {
                root = *root.left;
            }

        }
        return findDis(&root, node1) + findDis(&root, node2);
    }
};
```
### 95 · Validate Binary Search Tree
```
class Solution {
public:
    bool test(TreeNode* root, long minv, long maxv)
    {
        if (!root)
            return true;
        if (root->val >= maxv || root->val <= minv)
            return false;
        return test(root->left, minv, root->val) && test(root->right, root->val, maxv);
    }
    bool isValidBST(TreeNode *root) {
        return test(root, LONG_MIN, LONG_MAX);
    }
};
```


# String

## 字符串hash

![image-20220209082215009](D:\code\sf\image-20220209082215009.png)
![image-20220209082322116](D:\code\sf\image-20220209082322116.png)
h[] 位从做到右算
进制为从右往左算

例如
1. h[R] = 123456   h[L - 1] = 123
R= 0 ~ 5,  L = 0 ~ 2
2. h[L - 1]左移(R - (L - 1))位以后就变成了123000，与h[R]高位对齐
h'[L - 1] = 123000
h[R]       = 123456
3. 最后相减，即为456部分的hash
h[R ~ L] = h[R] - h[L - 1] * P^(R - (L - 1))

### 128 · Hash Function

```
class Solution {
public:
    int hashCode(string &key, int HASH_SIZE) {
        int P = 33;
        int sum = 0;
        int len = key.length();
        long long h[len] = {0};

        h[0] = key[0];
        for (int i = 1; i < len; i++)
        {   
            h[i] = (h[i - 1] * P + key[i]) % HASH_SIZE;
        }

        return h[len - 1];
    }
};
```

### 13 · Implement strStr()

```
#include <limits>
class Solution {
publi c:
    int strStr(string &source, string &target) {
        if (target.empty())
            return 0;
        int m = source.size();
        int n = target.size();
        int C = 31;
        long long power = 1;
        long long thash = 0;
        for (int i = 0; i < n; i++)
        {
            power *= C;
            thash = thash * C + target[i];
        }

        long long shash = 0;
        for (int i = 0; i < m; i++)
        {
            // abc + d   p2 + p1 + p0 -> p3 + p2 + p1 + p0
            shash = shash * C + source[i];
            if (i < n - 1)
                continue;

            // abcd - a  p3 + p2 + p1 + p0 -> p2 + p1 + p0
            if (i >= n)
            {
                shash = shash - source[i - n] * power;
                if (shash < 0)
                    shash += std::numeric_limits<long long>::max();
            }

            if (thash == shash)
                return i - n + 1;
        }
        return -1;
    }
};
```

解法2：

    1. p[0] = 1;
    1. i 从1 开始 source[i - 1]

```
class Solution {
public:
    unsigned long long gethash(vector<unsigned long long>& hash, vector<unsigned long long>& p, int L, int R)
    {
        return hash[R] - hash[L - 1] * p[R - (L - 1)];
    }
    int strStr(string &source, string &target) {
        if (source.empty() && target.empty())
            return 0;
        if (source.empty() && !target.empty())
            return -1;
        if (source.size() < target.size())
            return -1;
        int m = source.size();
        int n = target.size();
        vector<unsigned long long> shash(m + 1, 0);
        vector<unsigned long long> p(m + 1, 0);
        vector<unsigned long long> thash(n + 1, 0);
        const int P =  31;
        p[0] = 1;
        for (int i = 1; i <= m; i++)
        {
            p[i] = p[i - 1] * P;
            shash[i] = shash[i - 1] * P + source[i - 1];
        }
        for (int i = 1; i <= n; i++)
        {
            thash[i] = thash[i - 1] * P + target[i - 1];
        }

        for (int i = 1; i <= m; i++)
        {
            if (i + n - 1 <= m)
            {
                unsigned long long sh = gethash(shash, p, i, i + n - 1);
                if (thash[n] == sh)
                    return i - 1;
            }
        }

        return -1;
    }
};
```

### 841 · String Replace

```
class Solution {
public:
    typedef unsigned long long ULL;
    struct cmp
    {
        bool operator()(ULL a, ULL b)
        {
            return a > b;
        }
    };
    ULL gethash(vector<ULL>& h, vector<ULL>& p, int L, int R)
    {
        return h[R] - h[L - 1] * p[R - L + 1];
    }
    string stringReplace(vector<string> &a, vector<string> &b, string &s) {
        int m = s.size();
        int n = a.size();
        const int P = 31;
        map<ULL, string, cmp> hash;
        for (int i = 0; i < n; i++)
        {
            int len = a[i].size();
            vector<ULL> whash(m + 1, 0);
            for (int j = 1; j <= len; j++)
            {
                whash[j] = whash[j - 1] * P + a[i][j - 1];
            }
            hash[whash[len]] = b[i];
        }
        vector<ULL> shash(m + 1, 0);
        vector<ULL> p(m + 1, 0);
        p[0] = 1;
        for (int i = 1; i <= m; i++)
        {
            p[i] = p[i - 1] * P;
            shash[i] = shash[i - 1] * P + s[i - 1];
        }

        unordered_map<int, string> replace;
        for (int i = 1; i <= m; i++)
        {
            for (auto w : hash)
            {
                int len = w.second.size();
                if (i + len - 1 > m)
                    continue;
                ULL hs = gethash(shash, p, i, i + len - 1);
                if (hs != w.first)
                    continue;
                replace.insert({i - 1, w.second});
                i += (len - 1);
                break;
            }
        }

        for (auto r : replace)
        {
            int len = r.second.size();
            for (int i = 0; i < len; i++)
            {
                s[r.first + i] = r.second[i];
            }
        }

        return s;
    }
};
```

# Trie树

### 442 · Implement Trie (Prefix Tree)

```
class Trie {
public:
    /*
     * @param word: a word
     * @return: nothing
     */
    int son[100000][26];
    int cnt[100000];
    int idx = 0;
    void insert(string &word) {
        int m = word.size();
        int p = 0;
        for (int i = 0; i < m; i++)
        {
            int u = word[i] - 'a';
            if (!son[p][u]) son[p][u] = ++idx;
            p = son[p][u];
        }
        cnt[p]++;
    }

    /*
     * @param word: A string
     * @return: if the word is in the trie.
     */
    bool search(string &word) {
        int m = word.size();
        int p = 0;
        for (int i = 0; i < m; i++)
        {
            int u = word[i] - 'a';
            if (!son[p][u]) 
                return false;
            p = son[p][u];
        }
        return cnt[p]? true: false;
    }

    /*
     * @param prefix: A string
     * @return: if there is any word in the trie that starts with the given prefix.
     */
    bool startsWith(string &prefix) {
        int m = prefix.size();
        int p = 0;
        for (int i = 0; i < m; i++)
        {
            int u = prefix[i] - 'a';
            if (!son[p][u]) 
                return false;
            p = son[p][u];
        }
        return true;
    }
};
```
### 1848 · Word Search III

```
class Solution {
public:
    int son[100000][26] = {0};
    int cnt[100000] = {0};
    int idx = 0;
    void insert(string& s)
    {
        int p = 0;
        for (int i = 0; s[i]; i++)
        {
            int u = s[i] - 'a';
            if (!son[p][u])
                son[p][u] = ++idx;
            p = son[p][u];
        }
        cnt[p]++;
    }

    bool isInBound(int x, int y, int m, int n)
    {
        if (x >= m || y >= n || x < 0 || y < 0)
            return false;
        return true;
    }
    void dfs(vector<vector<char>> &board, int wcount, int x, int y, int p, vector<vector<bool>>& visit, int wordcount, int& res, int startx, int starty)
    {
        if (wordcount >= wcount)
            return;

        int m = board.size();
        int n = board[0].size();
        visit[x][y] = true;
        p = son[p][board[x][y] - 'a'];
        if (cnt[p])
        {
            wordcount++;
            res = max(res, wordcount);
            int tmp = cnt[p];
            cnt[p] = 0;
            for (int i = startx; i < m; i++)
            {
                for (int j = starty; j < n; j++)
                {
                    if (visit[i][j])
                        continue;
                    dfs(board, wcount, i, j, 0, visit, wordcount, res, i, j);
                }
            }
            wordcount--;
            cnt[p] = tmp;
        }
        else
        {
            int dx[4] = {0, 1, 0, -1};
            int dy[4] = {1, 0, -1, 0};
            for (int i = 0; i < 4; i++)
            {
                int nx = x + dx[i];
                int ny = y + dy[i];
                if (!isInBound(nx, ny, m, n) || visit[nx][ny] || !son[p][board[nx][ny] - 'a'])
                    continue;
                dfs(board, wcount, nx, ny, p, visit, wordcount, res, startx, starty);
            }
        }
        visit[x][y] = false;
    }

    int wordSearchIII(vector<vector<char>> &board, vector<string> &words) {
        int m = board.size();
        int n = board[0].size();
        for (auto w : words)
        {
            insert(w);
        }
        int res = 0;
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                int u = board[i][j] - 'a';
                if (son[0][u])
                {
                    vector<vector<bool>> visit(m, vector<bool>(n, 0));
                    dfs(board, words.size(), i, j, 0, visit, 0, res, 0, 0);
                }
            }
        }
        return res;
    }
};
```


# Heap

### 130 · Heapify

```
    void heapify(vector<int> &A) {
        priority_queue<int, vector<int>, greater<int>> q;
        for (auto n : A)
        {
            q.push(n);
        }
        A.clear();
        while (!q.empty())
        {
            A.push_back(q.top()); q.pop();
        }
    }

    void heapify(vector<int> &A) {

        int len = A.size();
        if (!len || len == 1)
           return;

        std::make_heap (A.begin(),A.end(), [](int a, int b){return a > b;});
    }    
```

```
void down(vector<int> &A, int i)
    {
        int t = i;
        int len = A.size();
         if (i * 2 <= len && A[i-1] > A[i * 2 - 1])
         {
             t = i * 2;
         }
         if (i * 2 + 1 <= len && A[i - 1] > A[i * 2 + 1 - 1])
         {
             t = i * 2 + 1;
         }

         if (t != i)
         {
             swap(A[t-1], A[i-1]);
             down(A, t);
         }

    }
```

### 613 · High Five

Heap 基础用法

```
class Solution {
public:
    /**
     * @param results a list of <student_id, score>
     * @return find the average of 5 highest scores for each person
     * map<int, double> (student_id, average_score)
     */
    map<int, double> highFive(vector<Record>& results) {
        map<int, priority_queue<int, vector<int>, greater<int>>> hash;
        map<int, double> hashTotal;

        for (auto n : results)
        {
            hash[n.id].push(n.score);
            hashTotal[n.id] += n.score;
            if (hash[n.id].size() > 5)
            {
                hashTotal[n.id] -= hash[n.id].top();
                hash[n.id].pop();
            }
        }
        for (auto& n : hashTotal)
        {
            n.second /= 5.0;
        }
        return hashTotal;
    }
};
```

# Hash

## 扩容

### 129 · Rehashing

将容量扩充为原来的两倍，然后将原来的数据重新计算hash放入新的buff中

```
class Solution {
public:
    int hashcode(int key, int capacity) {
        return (key % capacity + capacity) % capacity;
    }
    vector<ListNode*> rehashing(vector<ListNode*> hashTable) {
        int m = hashTable.size();
        vector<ListNode*> newHashTab(2 * m, nullptr);
        for (auto n : hashTable)
        {
            while (n)
            {
                ListNode* newNode = new ListNode(n->val);
                ListNode* l = newHashTab[hashcode(n->val, 2 * m)];
                if (!l)
                    newHashTab[hashcode(n->val, 2 * m)] = newNode;
                else
                {
                    while (l)
                    {
                        if (!l->next)
                        {
                            l->next = newNode;
                            break;
                        }
                        l = l->next;
                    }
                }
                n = n->next;
            }
        }
        return newHashTab;
    }
};
```

# 链表（见链表页）

### 103 · Linked List Cycle II 链表环

```
class Solution {
public:
    ListNode * detectCycle(ListNode * head) {
        if(head == NULL || head->next == NULL){
            return NULL;
        }
        ListNode *slow = head;
        ListNode *fast = head;
        while(fast != NULL && fast->next != NULL){
            slow = slow->next;
            fast = fast->next->next;
            if(slow == fast){
                break;
            }
        }
        if(fast == NULL || fast->next == NULL){
            return NULL;
        }
        slow = head;
        while(slow != fast){
            slow = slow->next;
            fast = fast->next;
        }
        return slow;
    }
};
```

### L21. 合并两个有序链表

### L23. 合并K个升序链表

### L19. 删除链表的倒数第 N 个结点

### L876. 链表的中间结点(228)

### 剑指 Offer 24. 反转链表

### 判断单链表是否包含环

### 剑指 Offer II 022. 链表中环的入口节点

### 剑指 Offer II 023. 两个链表的第一个重合节点

# 动态规划

### 515 · Paint House

```
class Solution {
public:
    int minCost(vector<vector<int>> &costs) {
        if (costs.empty())
            return 0;
        int m = costs.size();
        vector<vector<int>> f(m, vector<int>(3, 0));
        f[0][0] = costs[0][0];
        f[0][1] = costs[0][1];
        f[0][2] = costs[0][2];
        for (int i = 1; i < m; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                f[i][j] = min(f[i - 1][(j + 1) % 3], f[i - 1][(j + 2) % 3]) + costs[i][j];
            }
        }
        int res = INT_MAX;
        for (int i = 0; i < 3; i++)
        {
            res = min(res, f[m - 1][i]);
        }

        return res;
    }
};
```

### 111 · Climbing Stairs

```
class Solution {
public:
    int climbStairs(int n) {
        if (n == 0)
            return 0;
        vector<int> dp(n + 1, 0);
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++)
        {
            dp[i] = dp[i - 2] + dp[i - 1];
        }
        return dp[n];
    }
};
```

### 300 · Meeting Room IV

接龙

```
class Solution {
public:
    int maxValue(vector<vector<int>> &meeting, vector<int> &value) {
        int m = meeting.size();
        vector<int> f(50010, 0);

        int res = 0;
        for (int j = 1; j < 50010; j++)
        {
            f[j] = f[j - 1];
            for (int i = 1; i <= m; i++)
            {
                if (meeting[i - 1][1] != j)
                    continue;

                f[j] = max(f[j], f[meeting[i - 1][0]] + value[i - 1]);
                res = max(res, f[j]);
            }
        }

        return res;
    }
};
```

### L32. Longest Valid Parentheses

dp为 以“)” 为结尾的左边最长括号的长度

```
class Solution {
public:
    int longestValidParentheses(string s) {
        if (s.length() <= 1)
            return 0;
        int len = s.length();
        int dp[300000] = {0};

        int max = 0;
        for (int i = 1; i < len; ++i)
        {
            if (s[i] == ')')
            {
                int pre = 0;
                pre = i - dp[i - 1] - 1;
                if (pre >= 0 && s[pre] == '(')
                {
                    dp[i] = dp[i - 1] + 2;
                    if (pre > 0)
                    {
                        dp[i] += dp[pre - 1];
                    }
                }

                if (dp[i] > max)
                {
                    max = dp[i];
                }
            }
        }
        return max;
    }
};
```

## 正向推算

### L5982. Solving Questions With Brainpower

```
class Solution {
public:
    long long mostPoints(vector<vector<int>>& questions) {
        int m = questions.size();
        vector<long long> f(m, 0);
        for (int i = 0; i < m; i++)
        {
            if (i + 1 < m)
                f[i + 1] = max(f[i + 1], f[i]);
            f[i] += questions[i][0];
            int remote = i + questions[i][1] + 1;
            if (remote < m)
                f[remote] = max(f[remote], f[i]);
        }
        long long res = *std::max_element(f.begin(), f.end());
        return res;
    }
};
```

## 坐标型DP

### 115 · Unique Paths II

```
class Solution {
public:
    bool isInBound(int x, int y, int m, int n)
    {
        if (x >= m || y >= n || x < 0 || y < 0)
            return false;
        return true;
    }
    int uniquePathsWithObstacles(vector<vector<int>> &obstacleGrid) {
        if (obstacleGrid.empty())
            return 0;
        if (obstacleGrid[0][0])
            return 0;

        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        vector<vector<int>> f(m + 1, vector<int>(n + 1, 0));
        f[0][0] = 1;
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (obstacleGrid[i][j])
                    continue;
                if (isInBound(i - 1, j, m, n))
                    f[i][j] += f[i - 1][j];
                if (isInBound(i, j - 1, m, n))
                    f[i][j] += f[i][j - 1];
            }
        }
        return f[m - 1][n - 1];
    }
};
```

### 76 · Longest Increasing Subsequence(LIS)

是大于，不是大于等于。初始化为1

```
class Solution {
public:
    int longestIncreasingSubsequence(vector<int> &nums) {
        if (nums.empty())
            return 0;
        int m = nums.size();
        vector<int> f(m + 1, 1);
        int res = 0;
        for (int i = 1; i < m; i++)
        {
            for (int j = 0; j < i; j++)
            {
                if (nums[i] > nums[j])
                {
                    f[i] = max(f[i], f[j] + 1);
                }
                res = max(res, f[i]);
            }
        }
        return res;
    }
};
```

### 77 · Longest Common Subsequence(LCS)

f(i, j) 是1-i和i- j两个子序列的LCS

f(i - 1, j) 和 f(i, j - 1)都包含 f(i - 1, j - 1)这种情况，但是取max的时候实际还是取的他们三者的最大值，是否重复不重要。

```
class Solution {
public:
    int longestCommonSubsequence(string &A, string &B) {
        int m = A.size();
        int n = B.size();
        A = " " + A;
        B = " " + B;
        vector<vector<int>> f(m + 1, vector<int>(n + 1, 0));

        for (int i = 1; i <= m; i++)
        {
            for (int j = 1; j <= n; j++)
            {
                f[i][j] = max(f[i - 1][j], f[i][j - 1]);
                if (A[i] == B[j])
                {
                    f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1);
                }
            }
        }
        return f[m][n];
    }
};
```

## 区间DP

### 667 · Longest Palindromic Subsequence

len从1开始，i从0开始

中间有个k隔板

变化的是连续空间

```
int longestPalindromeSubseq(string s) {
        int n = s.size();
        vector<vector<int>> dp(n + 10, vector<int>(n + 10, 0));
        for (int len = 1; len <= n; len++)
        {
            for (int i = 0; i + len - 1 < n; ++i)
            {
                int j = i + len - 1;
                if (len == 1)
                    dp[i][j] = 1;
                else if (s[i] == s[j])
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                else
                    dp[i][j] = max(dp[i][j], max(dp[i + 1][j], dp[i][j - 1]));
            }
        }

        return dp[0][n - 1];
    }
```

常规做法, dp[j]为，以j为结尾的，最长回文子序列长度

```
class Solution {
public:
    bool isPal(const string& s)
    {
        int l = 0;
        int r = s.length() - 1;

        while (l <= r && s[l] == s[r]) { l++; r--;}
        if(l > r)
            return true;
        return false;
    }
    int longestPalindromeSubseq(string &s) {
        int len = s.length();
        int res = INT_MIN;
        vector<int> dp(len + 2, 1);
        for (int i = 1; i < len; i++)
        {
            for (int j = 0; j < i; j++)
            {
                if (isPal(s.substr(j - dp[j] + 1, dp[j]) + s[i]))
                {
                    dp[i] = max (dp[i], dp[j] + 1);
                    res = max (res, dp[i]);
                }
            }
        }
        return res;
    }
};
```

### 476 · Stone Game

算法：区间DP

这是一道区间DP问题，我们需要用区间表示状态来递推。设s是表示石头重量的数组，设f[i][j]是将s[i,...,j]的石头合并成一个所需的最少能量，那么这个最少能量按照最后一步合并的分界线可以分为以下几种情况：

1、最后一步是s[i]和s[i+1,...,j]合并，此时需要的最少能量是f[i+1][j]+sum(s[i]...s[j]),第一项是合并后者需要的能量，第二项是最后一次合并所需要的能量。s[i]自己只有一个石头，不需要合并

2、最后一步是s[i,i+1]和s[i+2,...,j]合并，此时需要的最少能量是f[i][i+1]+f[i+2][j]+sum(s[i]...s[j])，第一项是合并前两个石头需要的能量，第二项是合并后半区间石头需要的能量，最后一项是最后一次合并需要的能量；

从上面我们可以看出一个规律，f[i][j]应该是所有区间分法中前一半区间的石头合并需要的总能量加上后半区间的总能量再加上最后一次合并需要的能量

求得A的前缀和
区间长度从2开始枚举，
根据上诉思路可得递推式
dp[l][r] =min(dp[l][r], dp[l][j] + dp[j + 1][r] + sum_a[r + 1] - sum_a[l])
记得初始化dp[l][r]为一个较大值
结果存在dp[0][size-1]中

```
#include <numeric>
class Solution {
public:
    int stoneGame(vector<int> &A) {
        if (A.empty())
            return 0;
        int m = A.size();
        vector<vector<int>> f(m + 1, vector<int>(m + 1, 0));
        vector<int> sum(m + 1, 0);
        partial_sum(A.begin(), A.end(), sum.begin() + 1);

        for (int len = 2; len <= m; len++)
        {
            for (int i = 0; i + len - 1 < m; i++)
            {
                int j = i + len - 1;
                f[i][j] = 0x3f3f3f3f;
                for (int k = i; k < j; k++)
                    f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j] + (sum[j + 1] - sum[i])); 
            }
        }
        return f[0][m - 1];
    }
};
```

### 107 · Word Break

```
class Solution {
public:
    bool wordBreak(string &s, unordered_set<string> &wordSet) {
        if (s.empty())
            return true;
        if (wordSet.empty())
            return false;

        int m = s.size();
        vector<bool> dp(m + 1, false);
        dp[0] = true;
        for (int i = 1; i <= m; i++)
        {
            for (int j = i - 1; j >= 0; j--)
            {
                string t = s.substr(j, i - j);
                //cout << t << endl;
                if (dp[j] && wordSet.count(t))
                {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[m];
    }
};
```

# 贪心

### L1647. Minimum Deletions to Make Character Frequencies Unique

```
class Solution {
public:
    int minDeletions(string s) {
        int m = s.size();
        unordered_map<char, int> hash;
        for (int i = 0; i < m; i++)
        {
            hash[s[i]]++;
        }

        int i = 0;
        int k = hash.size();
        int res = 0;
        while (i < k)
        {
            unordered_map<int, int> counter;
            for (auto& n : hash)
            {
                if (counter[n.second] >= 1)
                {
                    n.second--;
                    if (!n.second)
                        hash.erase(n.first);
                    i = 0;
                    res++;
                    break;
                }
                counter[n.second]++;
                i++;
            }
        }
        return res;
    }
};
```

### 187 · Gas Station

i = i + j + 1;

```
class Solution {
public:
    int canCompleteCircuit(vector<int> &gas, vector<int> &cost) {
        if (gas.empty())
            return -1;
        int m = gas.size();
        int totalgas = 0;
        int totalcost = 0;
        for (int i = 0; i < m; i++)
        {
            totalgas += gas[i];
            totalcost += cost[i];
        }
        if (totalgas < totalcost)
            return -1;

        for (int i = 0; i < m;)
        {
            int curgas = 0;
            int j = 0;
            for (;j < m; j++)
            {
                int k = (i + j) % m;
                curgas += gas[k] - cost[k];
                if (curgas < 0)
                {
                    break;
                }
            }
            if (j == m)
                return i;
            i = i + j + 1;
        }
        return -1;
    }
};
```

# 其他

## 扫描线

### 919 · Meeting Rooms II

对所有点排序，从左到右扫描每个点，是起点就加一，是终点就减一，判断这个过程中的最大值

```
class Solution {
public:
    int minMeetingRooms(vector<Interval> &intervals) {
        int m = intervals.size();
        multimap<int, int> order;
        for (auto i : intervals)
        {
            order.insert({i.start, 1});
            order.insert({i.end, -1});
        }
        int res = 0;
        int current = 0;
        for (auto t : order)
        {
            current += t.second;
            res = max(res, current);
        }
        return res;
    }
};
```

### 218. The Skyline Problem

```
class Solution {
public:
    struct cmp
    {
        bool operator()(pair<int, int>& l, pair<int, int>& r)
        {
            if (l.first < r.first)
            {
                return true;
            }
            else if (l.first == r.first)
            {
                if (l.second < r.second)
                    return true;
            }
            return false;
        }
    };

    struct hp
    {
        priority_queue<int> q;
        priority_queue<int> d;
        void insert(int x)
        {
            q.push(x);
        }
        bool empty()
        {
            return q.empty();
        }
        int top()
        {
            while (!d.empty() && q.top() == d.top()) { q.pop(); d.pop(); }
            return q.empty()? 0: q.top();
        }
        void erase(int x)
        {
            d.push(x);
        }
    };

    vector<vector<int>> getSkyline(vector<vector<int>>& buildings) {
        int m = buildings.size();
        vector<pair<int, int>> pst;
        for (int i = 0; i < m; i++)
        {
            pst.push_back({buildings[i][0], -buildings[i][2]});
            pst.push_back({buildings[i][1], buildings[i][2]});
        }
        sort(pst.begin(), pst.end(), cmp());

        hp pri;
        int prev = 0;
        vector<vector<int>> res;
        for (auto line : pst)
        {
            int p = line.first; int hi = line.second;
            if (hi < 0)
            {
                pri.insert(-hi);
            }
            else
            { 
                pri.erase(hi);
            }

            int cur = pri.top();
            if (prev == cur)
                continue;
            res.push_back({p, cur});
            prev = cur;
        }

        return res;
    }
};
```

## 前缀和

### 604 · Window Sum

```
#include <numeric>
class Solution {
public:
    vector<int> winSum(vector<int> &nums, int k) {
        if (nums.empty())
            return {};
        int m = nums.size();
        vector<int> sums(m + 1, 0);
        partial_sum(nums.begin(), nums.end(), sums.begin() + 1);
        vector<int> res;
        for (int i = 1; i + k - 1 <= m; i++)
        {
            int j = i + k - 1;
            res.push_back(sums[j] - sums[i - 1]);
        }
        return res;
    }
};
```

# 404 · 子数组求和 II
```
#include <numeric>
class Solution {
public:
    int subarraySumII(vector<int> &A, int start, int end) {
        int m = A.size();
        vector<int> sums(m + 1, 0);
        partial_sum(A.begin(), A.end(), sums.begin() + 1);

        int res = 0;
        for (int i = 1; i <= m; i++)
        {
            for (int j = i; j <= m; j++)
            {
                int sum = sums[j] - sums[i - 1];
                if (sum >= start && sum <= end)
                    res++;
            }
        }
        return res;
    }
};
```


## 倍增

### 447 · Search in a Big Sorted Array

```
        while(reader->get(r) < target)
            r <<= 1;
```

```
class Solution {
public:
    int searchBigSortedArray(ArrayReader * reader, int target) {
        int l = 0;
        int r = 1;
        while(reader->get(r) < target)
            r <<= 1;
        while (l < r)
        {
            int mid = (l + r) / 2;
            if (reader->get(mid) >= target)
            {
                r = mid;
            }
            else
            {
                l = mid + 1;
            }
        }
        if (reader->get(l) != target)
            return -1;
        return l;
    }
};
```

### 5969. Destroying Asteroids

```
class Solution {
public:
    bool asteroidsDestroyed(int mass, vector<int>& asteroids) {
        sort(asteroids.begin(), asteroids.end());
        int m = asteroids.size();
        vector<int> minarr(18, -1);
        vector<long long> sums(18, 0);

        for (int i = 0; i < m; i++)
        {
            int h = 31 - __builtin_clz(asteroids[i]);
            if (minarr[h] == -1 || asteroids[i] < minarr[h])
            {
                minarr[h] = asteroids[i];
            }
            sums[h] += asteroids[i];
        }
        long long mm = mass;
        for (int i = 0; i < 17; i++)
        {
            if (mm < minarr[i])
                return false;
            mm += sums[i];
        }
        return true;
    }
};
```

## LRU

### 134 · LRU Cache

利用std::list::splice()方法

lru_.splice(lru_.begin(), lru_, table_[key]);     

将lru位于table_[key]的位置的元素，移动到lru_.begin()的地方, table_[key]为iterator

```
#include <list>
class LRUCache {
public:
    LRUCache(int capacity) : _capacity(capacity) {

    }

    int get(int key) {
        auto it = _table.find(key);
        if (it != _table.end()) {
            _lru.splice(_lru.begin(), _lru, it->second);
            return it->second->second;
        }
        return -1;
    }

    void set(int key, int value) {
        auto it = _table.find(key);
        if (it != _table.end()) {
            _lru.splice(_lru.begin(), _lru, it->second);
            it->second->second = value;
            return;
        }

        _lru.emplace_front(key, value);
        _table[key] = _lru.begin();

        if (_table.size() > _capacity) {
            _table.erase(_lru.back().first);
            _lru.pop_back();
        }
    }
private:
    unordered_map<int, std::list<std::pair<int, int>>::iterator> _table;
    std::list<std::pair<int, int>> _lru;
    int _capacity;
};
```

## 位运算

### 1891 · Travel Plan

位操作

```
    int setbit(int& x, int bit)
    {
        return x | (1 << bit);
    }
    int clsbit(int& x, int bit)
    {
        return x & ~(1 << bit);
    }
    bool getbit(int x, int bit)
    {
        return (x >> bit) & 1;
    }
```

```
class Solution {
public:
    int setbit(int& x, int bit)
    {
        return x | (1 << bit);
    }
    int clsbit(int& x, int bit)
    {
        return x & ~(1 << bit);
    }
    bool getbit(int x, int bit)
    {
        return (x >> bit) & 1;
    }
    void dfs(vector<vector<int>> &arr, int& visit, int cur, int curweight, int& res)
    {
        int m = arr.size();
        if (cur == 0 && visit == alltag)
        {
            res = min(res, curweight);
            return;
        }

        for (int i = 0; i < m; i++)
        {
            if (cur == i || getbit(visit, i))
                continue;
            visit = setbit(visit, i);
            dfs(arr, visit, i, curweight + arr[cur][i], res);
            visit = clsbit(visit, i);
        }
    }
    int alltag = 0;
    int travelPlan(vector<vector<int>> &arr) {
        int m = arr.size();
        for (int i = 0; i < m; i++)
        {
            alltag = setbit(alltag, i);
        }
        int res = 0x3f3f3f3f;
        int visit = 0;
        dfs(arr, visit, 0, 0, res);
        return res;
    }
};
```

### L5978. Count Words Obtained After Adding a Letter

```
class Solution {
public:
    int getbit(string& s)
    {
        int bit = 0;
        for (auto c : s)
        {
            bit = bit | (1 << (c - 'a')); 
        }
        return bit;
    }
    int wordCount(vector<string>& startWords, vector<string>& targetWords) {
        unordered_set<int> bitvec;
        for (auto w : startWords)
        {
            int wbit = getbit(w);

            bitvec.insert(wbit);
        }
        int res = 0;
        int m = targetWords.size();
        for (int i = 0; i < m; i++)
        {
            int bit = getbit(targetWords[i]);
            for (int j = 0; j < 26; j++)
            {
                if (bit & 1 << j)
                {
                    if (bitvec.count(bit & ~(1 << j)))
                    {
                        res++;
                        break;
                    }
                }
            }
        }
        return res;
    }
};
```

### 1468 · Two Numbers That Are Not Repeated

```
class Solution {
public:
    vector<int> theTwoNumbers(vector<int> &a) {
        int m = a.size();
        int xorres = 0;
        for (int i = 0; i < m; i++)
        {
            xorres ^= a[i];
        }

        int t = xorres;
        int idx = 0;
        while ((t & 1) == 0 && idx < 32)
        {
            t = t >> 1;
            idx++;
        }

        int test = 1 << idx;
        int num1 = 0;
        int num2 = 0;
        for (auto n : a)
        {
            if ((n & test) != 0)
            {
                num1 ^= n;
            }
            else
            {
                num2 ^= n;
            }
        }

        return num1 < num2? vector<int>({num1, num2}) : vector<int>({num2, num1});
    }
};
```

## 二维前缀和 + 二维差分

### L1314. Matrix Block Sum

### L304. Range Sum Query 2D - Immutable

```
class NumMatrix {
public:
    NumMatrix(vector<vector<int>>& matrix):
        m(matrix.size()), n(matrix[0].size()), 
        sums(m + 1, vector<int>(n + 1, 0)) 
    {
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                sums[i + 1][j + 1] = sums[i][j + 1] + sums[i + 1][j] - sums[i][j] + matrix[i][j]; 
            }
        }
    }
    int m;
    int n;
    vector<vector<int>> sums;
    int sumRegion(int row1, int col1, int row2, int col2) {
        int res = sums[row2 + 1][col2 + 1] - sums[row1][col2 + 1] - sums[row2 + 1][col1] + sums[row1][col1];
        return res;
    }
};
```

### 5931. Stamping the Grid

![](D:\code\sf\chafe.PNG)

```
class Solution {
public:
    void insert(vector<vector<int>>& diff, int x1, int y1, int x2, int y2)
    {
        diff[x1][y1] += 1;
        diff[x2 + 1][y2 + 1] += 1;
        diff[x1][y2 + 1] -= 1;
        diff[x2 + 1][y1] -= 1;
    }
    bool possibleToStamp(vector<vector<int>>& grid, int stampHeight, int stampWidth) {
        int m = grid.size();
        int n = grid[0].size();
        vector<vector<int>> sums(m + 1, vector<int>(n + 1, 0));
        for (int i = 1; i <= m; i++)
        {
            for (int j = 1; j <= n; j++)
            {
                sums[i][j] = sums[i - 1][j] + sums[i][j - 1] - sums[i - 1][j - 1] + grid[i - 1][j - 1];
            }
        }
        int h = stampHeight;
        int w = stampWidth;
        vector<vector<int>> markmatrix(m + 2, vector<int>(n + 2, 0));
        for (int i = h; i <= m; i++)
        {
            for (int j = w; j <= n; j++)
            {
                int check = sums[i][j] - sums[i - h][j] - sums[i][j - w] + sums[i - h][j - w];
                if (!check)
                {
                    insert(markmatrix, i - h + 1, j - w + 1, i, j);
                }
            }
        }

        vector<vector<int>> resmarkmatrix(m + 2, vector<int>(n + 2, 0));
        for (int i = 1; i <= m; i++)
        {
            for (int j = 1; j <= n; j++)
            {
                resmarkmatrix[i][j] = resmarkmatrix[i - 1][j] + resmarkmatrix[i][j - 1] - resmarkmatrix[i - 1][j - 1] + markmatrix[i][j];
            }
        }
        for (int i = 1; i <= m; i++)
        {
            for (int j = 1; j <= n; j++)
            {
                if (!resmarkmatrix[i][j] && !grid[i - 1][j - 1])
                    return false;
            }
        }

        return true;
    }
};
```

## A*

### 794 · Sliding Puzzle II

## BST 判断

### 910 · Largest BST Subtree

```
class Solution:
    def largestBSTSubtree(self, root: TreeNode) -> int:
        if root is None:
            return 0

        _, size, _, _ = self.helper(root)
        return size

    def helper(self, root):
        if root is None:
            return True, 0, sys.maxsize, -sys.maxsize

        l_bst, l_size, l_min, l_max = self.helper(root.left)
        r_bst, r_size, r_min, r_max = self.helper(root.right)

        bst = l_bst and r_bst and root.val > l_max and root.val < r_min

        if bst:
            size = l_size + r_size + 1
        else:
            size = max(l_size, r_size)

        return bst, size, min(l_min, r_min, root.val), max(l_max, r_max, root.val)
```

## KMP

### 1625 · Words Compression

## 二分图最大权匹配 KM算法

### 1576 · Optimal Match
