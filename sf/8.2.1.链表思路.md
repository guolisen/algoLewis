[TOC]

### 一、基础操作类

1. **LeetCode 876. Middle of the Linked List（链表的中间节点）**
    - **题目描述**：给定一个单链表，返回链表的中间节点。如果有两个中间节点（链表长度为偶数），返回第二个中间节点。
    - **示例**：输入 `1->2->3->4->5`，输出 `3`；输入 `1->2->3->4->5->6`，输出 `4`。
    - 思路：快慢指针法。快指针每次走 2 步，慢指针每次走 1 步，当快指针到达末尾时，慢指针即为中间节点。
2. **LeetCode 237. Delete Node in a Linked List（删除链表中的节点，只给待删节点）**
    - **题目描述**：给定单链表中的一个节点（非尾节点），要求删除该节点（无法访问头节点，只能操作给定的待删节点）。
    - **示例**：链表为 `4->5->1->9`，给定待删节点 `5`，删除后链表变为 `4->1->9`。
    - 思路：将待删节点的下一个节点的值复制到当前节点，然后删除下一个节点。

### 二、反转链表系列

1. **LeetCode 206. Reverse Linked List（反转整个链表）**
    - **题目描述**：给定单链表的头节点，将整个链表反转并返回反转后的头节点。
    - **示例**：输入 `1->2->3->4->5`，输出 `5->4->3->2->1`。
    - 思路：迭代法，用`prev`、`curr`、`next`三个指针，依次反转节点指向；或递归法，从后往前反转。
    
2. **LeetCode 92. Reverse Linked List II（反转链表的第 m 到第 n 个节点）**
    - **题目描述**：给定单链表的头节点，反转链表中从索引 `m` 到 `n` 的节点（索引从 1 开始），返回反转后的链表。
    - **示例**：输入 `1->2->3->4->5`，`m=2`，`n=4`，输出 `1->4->3->2->5`。
    - 思路：先找到第 m-1 个节点，然后用类似反转整个链表的方法反转 m 到 n 的节点，注意连接前后部分。
    - 先找leftnode再找rightnode，rightnode->next= null, 反转l r中间node，最后连到前后
    
    ```
            cur = pre.next
            for _ in range(right - left):
                next = cur.next
                cur.next = next.next
                next.next = pre.next
                pre.next = next
            return dummy_node.next
    ```
    
    
    
3. **LeetCode 24. Swap Nodes in Pairs（两两交换链表中的节点）**
    - **题目描述**：给定单链表的头节点，两两交换相邻的节点（如第 1 和第 2 个，第 3 和第 4 个），返回交换后的链表（不能仅修改节点值）。
    
    - **示例**：输入 `1->2->3->4`，输出 `2->1->4->3`。
    
    - 思路：   交换之前的节点关系是 `temp -> node1 -> node2`，交换之后的节点关系要变成 `temp -> node2 -> node1`
    
        ```
                if (!head)
                    return nullptr;
                ListNode dummy(-1, head);
                ListNode* temp = &dummy;
                while (temp->next && temp->next->next)
                {
                    ListNode* node1 = temp->next;
                    ListNode* node2 = temp->next->next;
                    temp->next = node2;
                    node1->next = node2->next;
                    node2->next = node1;
                    temp = node1;
                }
                return dummy.next;
        ```
    
        
    
4. **LeetCode 25. Reverse Nodes in k-Group（K 个一组反转链表）**
    - **题目描述**：给定单链表的头节点和整数 `k`，每 `k` 个节点一组进行反转，若最后剩余节点不足 `k` 个，则保持原样，返回处理后的链表。
    - **示例**：输入 `1->2->3->4->5`，`k=2`，输出 `2->1->4->3->5`。
    - 思路：先判断剩余节点是否足够 k 个，若足够则反转这 k 个节点，然后递归处理后续部分；不足则直接返回。

### 三、环相关问题

1. **LeetCode 141. Linked List Cycle（判断链表是否有环）**
    - **题目描述**：给定单链表的头节点，判断链表中是否存在环（即某个节点的 next 指针指向之前的节点，形成循环）。
    
    - **示例**：有环链表 `3->2->0->-4->2`（-4 的 next 指向 2），返回 `true`；无环链表返回 `false`。
    
    - 思路：快慢指针法。快指针每次走 2 步，慢指针每次走 1 步，若相遇则有环。
    
        ```
                ListNode* slow = head;
                ListNode* fast = head->next;
                while (fast && fast->next)
                {
                    if (fast == slow)
                        return true;
                    slow = slow->next;
                    fast = fast->next->next;
                }
        ```
    
        
    
2. **LeetCode 142. Linked List Cycle II（找到环的入口点）**
    - **题目描述**：给定单链表的头节点，若链表有环，返回环的入口节点；若无环，返回 `null`。
    
    - **示例**：有环链表 `3->2->0->-4->2`（环入口为 2），返回节点 `2`。
    
    - 思路：先通过快慢指针确定有环，然后让慢指针回到头节点，快指针留在相遇点，两者同时以 1 步 / 次的速度前进，相遇点即为环入口。
    
        ```
                ListNode* slow = head;
                ListNode* fast = head;
                while (fast && fast->next)
                {
                    slow = slow->next;
                    fast = fast->next->next;
                    if (slow == fast)
                    {
                        ListNode* ptr = head;
                        while(ptr != slow)
                        {
                            ptr = ptr->next;
                            slow = slow->next;
                        }
                        return ptr;
                    }
                }
        ```
    
        也可以用unordered_set, 遍历整个链表查找重复，若重复返回 

### 四、相交链表问题

1. **LeetCode 160. Intersection of Two Linked Lists（找到两个相交链表的第一个节点）**
    - **题目描述**：给定两个单链表的头节点 `headA` 和 `headB`，若两链表相交（共享部分节点），返回第一个相交节点；否则返回 `null`。
    - **示例**：链表 A 为 `4->1->8->4->5`，链表 B 为 `5->6->1->8->4->5`，相交于节点 `8`，返回 `8`。
    
    1. 用unordered_set记录A，然后遍历B
    2. 交叉查找
    
    ```
            ListNode* ha = headA;
            ListNode* hb = headB;
            while (ha != hb)
            {
                ha = (ha == nullptr) ? headB : ha->next;
                hb = (hb == nullptr) ? headA : hb->next;
            }
            return ha;
    ```
    
    

### 五、删除与去重

1. **LeetCode 203. Remove Linked List Elements（删除链表中值为 val 的所有节点）**
    - **题目描述**：给定单链表的头节点和整数 `val`，删除链表中所有值为 `val` 的节点，返回修改后的链表头节点。
    - **示例**：输入 `1->2->6->3->4->5->6`，`val=6`，输出 `1->2->3->4->5`。
    - 思路：迭代法，用`prev`和`curr`指针，遇到值为 val 的节点则`prev->next = curr->next`；或递归法处理。
    
    ```
            auto h = head;
            auto dummy = new ListNode(-1, head);
            auto p = dummy;
            while (h)
            {
                if (h->val == val)
                {
                    p->next = h->next;
                    h = h->next;
                }
                else
                {
                    p = p->next;
                    h = h->next;
                }
            }
            return dummy->next;
    ```

2. **LeetCode 83. Remove Duplicates from Sorted List（删除排序链表中的重复元素，保留一个）**
    - **题目描述**：给定一个已排序的单链表，删除所有重复的元素，使每个元素只出现一次，返回修改后的链表。
    - **示例**：输入 `1->1->2->3->3`，输出 `1->2->3`。
    - 思路：迭代法，用`curr`指针，若当前节点值等于下一个节点值，则`curr->next = curr->next->next`，否则`curr = curr->next`。
    - 用hash记录
```
    unordered_set<int> hash;
    ListNode* h = head;
    ListNode* dummy = new ListNode(-1, head);
    ListNode* p = dummy;
    while (h)
    {
        if (hash.count(h->val) != 0)
        {
            p->next = h->next;
            h = h->next;
        }
        else
        {
            hash.insert(h->val);
            p = p->next;
            h = h->next;
        }
    }
    return dummy->next;
```
3. **LeetCode 82. Remove Duplicates from Sorted List II（删除排序链表中的重复元素，完全删除）**
    - **题目描述**：给定一个已排序的单链表，删除所有含有重复数字的节点（即重复元素完全移除，不保留任何一个），返回修改后的链表。
    
    - **示例**：输入 `1->2->3->3->4->4->5`，输出 `1->2->5`；输入 `1->1->1->2->3`，输出 `2->3`。
    
    - 思路：迭代法，用`dummy`节点（哑节点）、`prev`和`curr`指针，记录是否有重复，若有则跳过所有重复节点，否则正常移动。
    
    - 用hash记录,  pre,  h->val == h->next->val   然后用pre删除中间的重复
    
        ```
                ListNode* dummy = new ListNode(-1, head);
                ListNode* h = head;
                ListNode* p = dummy;
                while(h && h->next)
                {
                    if (h->val == h->next->val)
                    {
                        while (h && h->next && (h->val == h->next->val))
                        {
                            h = h->next;
                        }
                        p->next = h->next;
                        h = h->next;
                    }
                    else
                    {
                        p = p->next;
                        h = h->next;
                    }
                }
                return dummy->next;
        ```
    
        

### 六、合并与拆分

1. **LeetCode 21. Merge Two Sorted Lists（合并两个有序链表）**
    - **题目描述**：将两个升序单链表合并为一个新的升序单链表并返回，新链表通过拼接两个链表的节点而成（不创建新节点）。
    
    - **示例**：输入 `1->2->4` 和 `1->3->4`，输出 `1->1->2->3->4->4`。
    
    - 思路：迭代法，用`dummy`节点，比较两个链表的当前节点值，小的接到`dummy`后面；或递归法处理。
    
        用第三个链表，用两个往第三个里面插入
    
    ```
            ListNode* dummy = new ListNode(-1);
            ListNode* h = dummy;
            while (list1 && list2)
            {
                if (list1->val <= list2->val)
                {
                    h->next = list1;
                    h = h->next;
                    list1 = list1->next;
                }
                else
                {
                    h->next = list2;
                    h = h->next;
                    list2 = list2->next;
                }
            }
            if (list1)
            {
                h->next = list1;
            }
            if (list2)
            {
                h->next = list2;
            }
            return dummy->next;
    ```
    
    
    
2. **LeetCode 23. Merge k Sorted Lists（合并 k 个有序链表）**
    - **题目描述**：给定一个包含 `k` 个升序单链表的数组，将所有链表合并为一个升序单链表并返回。
    - **示例**：输入 `[[1->4->5], [1->3->4], [2->6]]`，输出 `1->1->2->3->4->4->5->6`。
    - 思路：优先队列（最小堆）法，将 k 个链表的头节点入堆，每次取出最小值节点，然后将该节点的下一个节点入堆；或分治法，两两合并。
    
    ```
            priority_queue<ListNode*, vector<ListNode*>, std::function<bool(ListNode*, ListNode*)>> q([](ListNode* l, ListNode* r) -> bool {
                return l->val > r->val;
            });
            for (auto l : lists)
            {
                if (!l)
                    continue;
                q.push(l);
            }
            ListNode* dummy = new ListNode(-1);
            ListNode* h = dummy;
            while (!q.empty())
            {
                auto cur = q.top(); q.pop();
                h->next = cur;
                if (cur && cur->next)
                    q.push(cur->next);
                h = h->next;
            }
            return dummy->next;
    ```
    
    
    
3. **LeetCode 86. Partition List（按值拆分链表，小于 x 的放前面）**
    - **题目描述**：给定单链表的头节点和整数 `x`，将链表分隔成两部分：所有小于 `x` 的节点排在大于或等于 `x` 的节点之前（保持两部分内部的相对顺序）。
    
    - **示例**：输入 `1->4->3->2->5->2`，`x=3`，输出 `1->2->2->4->3->5`。
    
    - 思路：创建两个链表，一个存小于 x 的节点，一个存大于等于 x 的节点，最后将两个链表连接。
    
        ```
                ListNode* smalldummy = new ListNode(-1);
                ListNode* largedummy = new ListNode(-1);
                ListNode* sp = smalldummy;
                ListNode* lp = largedummy;
                while(head)
                {
                    if (head->val < x)
                    {
                        sp->next = head;
                        sp = sp->next;
                    }
                    else
                    {
                        lp->next = head;
                        lp = lp->next;
                    }
                    head = head->next;
                }
                lp->next = nullptr;
                sp->next = largedummy->next;
                return smalldummy->next;
        ```
    
        
    
4. **LeetCode 328. Odd Even Linked List（奇偶拆分链表）**
   
    - **题目描述**：给定单链表的头节点，将链表中的节点按 “奇数位置在前、偶数位置在后” 的顺序重新排列（位置从 1 开始），返回重排后的链表。
    
    - **示例**：输入 `1->2->3->4->5`，输出 `1->3->5->2->4`；输入 `2->1->3->5->6->4->7`，输出 `2->3->6->7->1->5->4`。
    
    - 思路：创建奇数链表和偶数链表，分别连接奇数位置和偶数位置的节点，最后将偶数链表接到奇数链表末尾。
    
        **和上一题相同**

### 七、其他高频题

1. **LeetCode 234. Palindrome Linked List（回文链表判断）**
    - **题目描述**：给定单链表的头节点，判断该链表是否为回文链表（正向和反向遍历结果相同）。
    
    - **示例**：输入 `1->2->2->1`，返回 `true`；输入 `1->2`，返回 `false`。
    
    - 思路：先找到中间节点，反转后半部分链表，然后比较前半部分和反转后的后半部分是否相同。
    
        **遍历整个链表将val存到vector中，然后判断是否是回文**
    
2. **LeetCode 2. Add Two Numbers（链表求和，逆序存储）**
    - **题目描述**：两个非空链表分别表示两个非负整数（ digits 逆序存储，如 `342` 表示为 `2->4->3`），求两数之和并以同样的逆序链表形式返回。
    
    - **示例**：输入 `2->4->3`（342）和 `5->6->4`（465），输出 `7->0->8`（807，342+465=807）。
    
    - 思路：迭代法，模拟竖式加法，记录进位，将结果节点依次连接。
    
        ```
            def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
                # 虚拟头节点，简化结果链表的构建
                dummy = ListNode(0)
                current = dummy  # 当前节点指针，用于构建结果链表
                carry = 0        # 进位
                
                # 遍历两个链表，直到两个链表都遍历完且无进位
                while l1 or l2 or carry:
                    # 获取当前位的数值（若链表已遍历完，视为 0）
                    val1 = l1.val if l1 else 0
                    val2 = l2.val if l2 else 0
                    
                    # 计算当前位的总和（包含进位）
                    total = val1 + val2 + carry
                    # 计算当前位的结果和新的进位
                    current_val = total % 10
                    carry = total // 10
                    
                    # 创建新节点，加入结果链表
                    current.next = ListNode(current_val)
                    current = current.next  # 移动指针
                    
                    # 移动两个链表的指针（若未遍历完）
                    if l1:
                        l1 = l1.next
                    if l2:
                        l2 = l2.next
                
                return dummy.next  # 虚拟头节点的下一个节点是结果的头节点
        ```
    
        
    
3. **LeetCode 138. Copy List with Random Pointer（复制带随机指针的链表）**
    - **题目描述**：给定一个链表，每个节点除了 `next` 指针外，还有一个 `random` 指针指向链表中的任意节点或 `null`，要求复制这个链表（新链表的节点与原链表完全独立）。
    
    - **示例**：输入含 random 指针的链表，输出复制后的新链表，且新节点的 `next` 和 `random` 指针与原节点一致。
    
    - 思路：哈希表法，先复制节点并存储原节点到新节点的映射，然后根据映射设置新节点的 next 和 random 指针；或原地复制法，先在原节点后复制新节点，再设置 random 指针，最后拆分。
    
    - **将新旧节点用hash存上，列表用arr存到数组中，然后依据arr将新节点连上**
    
        ```
            def copyRandomList(self, head):
                h = collections.defaultdict(RandomListNode)
                arr = []
                p = head
                while p != None:
                    h[p] = RandomListNode(p.label)
                    arr.append(p)
                    p = p.next
                
                for i in range(len(arr) - 1):
                    h[arr[i]].next = h[arr[i + 1]]
                    if arr[i].random in h:
                        h[arr[i]].random = h[arr[i].random]
                h[arr[len(arr) - 1]].next = None
                if arr[len(arr) - 1].random in h:
                    h[arr[len(arr) - 1]].random = h[arr[len(arr) - 1].random]
                return h[arr[0]]
        ```
    
        