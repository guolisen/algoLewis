### 一、基础操作类

1. **LeetCode 876. Middle of the Linked List（链表的中间节点）**
    - **题目描述**：给定一个单链表，返回链表的中间节点。如果有两个中间节点（链表长度为偶数），返回第二个中间节点。
    - **示例**：输入 `1->2->3->4->5`，输出 `3`；输入 `1->2->3->4->5->6`，输出 `4`。
    - 思路：快慢指针法。快指针每次走 2 步，慢指针每次走 1 步，当快指针到达末尾时，慢指针即为中间节点。
2. **LeetCode 237. Delete Node in a Linked List（删除链表中的节点，只给待删节点）**
    - **题目描述**：给定单链表中的一个节点（非尾节点），要求删除该节点（无法访问头节点，只能操作给定的待删节点）。
    - **示例**：链表为 `4->5->1->9`，给定待删节点 `5`，删除后链表变为 `4->1->9`。
    - 思路：将待删节点的下一个节点的值复制到当前节点，然后删除下一个节点。

### 二、反转链表系列

1. **LeetCode 206. Reverse Linked List（反转整个链表）**
    - **题目描述**：给定单链表的头节点，将整个链表反转并返回反转后的头节点。
    - **示例**：输入 `1->2->3->4->5`，输出 `5->4->3->2->1`。
    - 思路：迭代法，用`prev`、`curr`、`next`三个指针，依次反转节点指向；或递归法，从后往前反转。
2. **LeetCode 92. Reverse Linked List II（反转链表的第 m 到第 n 个节点）**
    - **题目描述**：给定单链表的头节点，反转链表中从索引 `m` 到 `n` 的节点（索引从 1 开始），返回反转后的链表。
    - **示例**：输入 `1->2->3->4->5`，`m=2`，`n=4`，输出 `1->4->3->2->5`。
    - 思路：先找到第 m-1 个节点，然后用类似反转整个链表的方法反转 m 到 n 的节点，注意连接前后部分。
3. **LeetCode 24. Swap Nodes in Pairs（两两交换链表中的节点）**
    - **题目描述**：给定单链表的头节点，两两交换相邻的节点（如第 1 和第 2 个，第 3 和第 4 个），返回交换后的链表（不能仅修改节点值）。
    - **示例**：输入 `1->2->3->4`，输出 `2->1->4->3`。
    - 思路：迭代法，用`prev`、`curr`、`next`指针，每次交换两个节点；或递归法，交换前两个节点后递归处理剩余部分。
4. **LeetCode 25. Reverse Nodes in k-Group（K 个一组反转链表）**
    - **题目描述**：给定单链表的头节点和整数 `k`，每 `k` 个节点一组进行反转，若最后剩余节点不足 `k` 个，则保持原样，返回处理后的链表。
    - **示例**：输入 `1->2->3->4->5`，`k=2`，输出 `2->1->4->3->5`。
    - 思路：先判断剩余节点是否足够 k 个，若足够则反转这 k 个节点，然后递归处理后续部分；不足则直接返回。

### 三、环相关问题

1. **LeetCode 141. Linked List Cycle（判断链表是否有环）**
    - **题目描述**：给定单链表的头节点，判断链表中是否存在环（即某个节点的 next 指针指向之前的节点，形成循环）。
    - **示例**：有环链表 `3->2->0->-4->2`（-4 的 next 指向 2），返回 `true`；无环链表返回 `false`。
    - 思路：快慢指针法。快指针每次走 2 步，慢指针每次走 1 步，若相遇则有环。
2. **LeetCode 142. Linked List Cycle II（找到环的入口点）**
    - **题目描述**：给定单链表的头节点，若链表有环，返回环的入口节点；若无环，返回 `null`。
    - **示例**：有环链表 `3->2->0->-4->2`（环入口为 2），返回节点 `2`。
    - 思路：先通过快慢指针确定有环，然后让慢指针回到头节点，快指针留在相遇点，两者同时以 1 步 / 次的速度前进，相遇点即为环入口。

### 四、相交链表问题

1. **LeetCode 160. Intersection of Two Linked Lists（找到两个相交链表的第一个节点）**
    - **题目描述**：给定两个单链表的头节点 `headA` 和 `headB`，若两链表相交（共享部分节点），返回第一个相交节点；否则返回 `null`。
    - **示例**：链表 A 为 `4->1->8->4->5`，链表 B 为 `5->6->1->8->4->5`，相交于节点 `8`，返回 `8`。
    - 思路：双指针法。指针 A 遍历链表 A 后遍历链表 B，指针 B 遍历链表 B 后遍历链表 A，相遇时即为相交节点（若不相交则相遇于 null）。

### 五、删除与去重

1. **LeetCode 203. Remove Linked List Elements（删除链表中值为 val 的所有节点）**
    - **题目描述**：给定单链表的头节点和整数 `val`，删除链表中所有值为 `val` 的节点，返回修改后的链表头节点。
    - **示例**：输入 `1->2->6->3->4->5->6`，`val=6`，输出 `1->2->3->4->5`。
    - 思路：迭代法，用`prev`和`curr`指针，遇到值为 val 的节点则`prev->next = curr->next`；或递归法处理。
2. **LeetCode 83. Remove Duplicates from Sorted List（删除排序链表中的重复元素，保留一个）**
    - **题目描述**：给定一个已排序的单链表，删除所有重复的元素，使每个元素只出现一次，返回修改后的链表。
    - **示例**：输入 `1->1->2->3->3`，输出 `1->2->3`。
    - 思路：迭代法，用`curr`指针，若当前节点值等于下一个节点值，则`curr->next = curr->next->next`，否则`curr = curr->next`。
3. **LeetCode 82. Remove Duplicates from Sorted List II（删除排序链表中的重复元素，完全删除）**
    - **题目描述**：给定一个已排序的单链表，删除所有含有重复数字的节点（即重复元素完全移除，不保留任何一个），返回修改后的链表。
    - **示例**：输入 `1->2->3->3->4->4->5`，输出 `1->2->5`；输入 `1->1->1->2->3`，输出 `2->3`。
    - 思路：迭代法，用`dummy`节点（哑节点）、`prev`和`curr`指针，记录是否有重复，若有则跳过所有重复节点，否则正常移动。

### 六、合并与拆分

1. **LeetCode 21. Merge Two Sorted Lists（合并两个有序链表）**
    - **题目描述**：将两个升序单链表合并为一个新的升序单链表并返回，新链表通过拼接两个链表的节点而成（不创建新节点）。
    - **示例**：输入 `1->2->4` 和 `1->3->4`，输出 `1->1->2->3->4->4`。
    - 思路：迭代法，用`dummy`节点，比较两个链表的当前节点值，小的接到`dummy`后面；或递归法处理。
2. **LeetCode 23. Merge k Sorted Lists（合并 k 个有序链表）**
    - **题目描述**：给定一个包含 `k` 个升序单链表的数组，将所有链表合并为一个升序单链表并返回。
    - **示例**：输入 `[[1->4->5], [1->3->4], [2->6]]`，输出 `1->1->2->3->4->4->5->6`。
    - 思路：优先队列（最小堆）法，将 k 个链表的头节点入堆，每次取出最小值节点，然后将该节点的下一个节点入堆；或分治法，两两合并。
3. **LeetCode 86. Partition List（按值拆分链表，小于 x 的放前面）**
    - **题目描述**：给定单链表的头节点和整数 `x`，将链表分隔成两部分：所有小于 `x` 的节点排在大于或等于 `x` 的节点之前（保持两部分内部的相对顺序）。
    - **示例**：输入 `1->4->3->2->5->2`，`x=3`，输出 `1->2->2->4->3->5`。
    - 思路：创建两个链表，一个存小于 x 的节点，一个存大于等于 x 的节点，最后将两个链表连接。
4. **LeetCode 328. Odd Even Linked List（奇偶拆分链表）**
    - **题目描述**：给定单链表的头节点，将链表中的节点按 “奇数位置在前、偶数位置在后” 的顺序重新排列（位置从 1 开始），返回重排后的链表。
    - **示例**：输入 `1->2->3->4->5`，输出 `1->3->5->2->4`；输入 `2->1->3->5->6->4->7`，输出 `2->3->6->7->1->5->4`。
    - 思路：创建奇数链表和偶数链表，分别连接奇数位置和偶数位置的节点，最后将偶数链表接到奇数链表末尾。

### 七、其他高频题

1. **LeetCode 234. Palindrome Linked List（回文链表判断）**
    - **题目描述**：给定单链表的头节点，判断该链表是否为回文链表（正向和反向遍历结果相同）。
    - **示例**：输入 `1->2->2->1`，返回 `true`；输入 `1->2`，返回 `false`。
    - 思路：先找到中间节点，反转后半部分链表，然后比较前半部分和反转后的后半部分是否相同。
2. **LeetCode 2. Add Two Numbers（链表求和，逆序存储）**
    - **题目描述**：两个非空链表分别表示两个非负整数（ digits 逆序存储，如 `342` 表示为 `2->4->3`），求两数之和并以同样的逆序链表形式返回。
    - **示例**：输入 `2->4->3`（342）和 `5->6->4`（465），输出 `7->0->8`（807，342+465=807）。
    - 思路：迭代法，模拟竖式加法，记录进位，将结果节点依次连接。
3. **LeetCode 138. Copy List with Random Pointer（复制带随机指针的链表）**
    - **题目描述**：给定一个链表，每个节点除了 `next` 指针外，还有一个 `random` 指针指向链表中的任意节点或 `null`，要求复制这个链表（新链表的节点与原链表完全独立）。
    - **示例**：输入含 random 指针的链表，输出复制后的新链表，且新节点的 `next` 和 `random` 指针与原节点一致。
    - 思路：哈希表法，先复制节点并存储原节点到新节点的映射，然后根据映射设置新节点的 next 和 random 指针；或原地复制法，先在原节点后复制新节点，再设置 random 指针，最后拆分。