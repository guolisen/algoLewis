[TOC]

### 二叉树遍历（基础核心）

#### 1. 前序遍历 → **LeetCode 144. Binary Tree Preorder Traversal**

   ```
   class Solution:
       res = list()
       def pretrave(self, root: TreeNode):
           if root == None:
               return
           self.res.append(root.val)
           self.pretrave(root.left)
           self.pretrave(root.right)
       def preorder_traversal(self, root: TreeNode) -> List[int]:
           self.pretrave(root)
           return self.res
   ```

```
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if root == None:
            return [] 
        stack = []
        res = []
        while root or len(stack):
            while root:
                res.append(root.val)
                stack.append(root)
                root = root.left 
        
            root = stack[-1]
            stack.pop()
            root = root.right 
        return res
```



#### 2. 中序遍历 → **LeetCode 94. Binary Tree Inorder Traversal**

```
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        stack = []
        current = root
        res = []
        while current or len(stack):
            while current:
                stack.append(current)
                current = current.left 
            if len(stack) > 0:  # 可以去掉
                current = stack[-1]
                stack.pop()
                res.append(current.val)
                current = current.right
        return res
```



#### 3. 后序遍历 → **LeetCode 145. Binary Tree Postorder Traversal**

后序遍历，用"根，右，左" 求序列，最后反转结果。

```
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if root == None:
            return []
        stack = []
        res = []
        while root or len(stack):
            while root:
                res.append(root.val)
                stack.append(root)
                root = root.right 
            root = stack[-1]
            stack.pop()
            root = root.left 
        return res[::-1]
```



#### 4. 层序遍历 → **LeetCode 102. Binary Tree Level Order Traversal**

   ```
   class Solution:
       def pretrave(self, root, h, level):
           if root == None:
               return
           h[level].append(root.val)
           self.pretrave(root.left, h, level + 1)
           self.pretrave(root.right, h, level + 1)
           
       def level_order(self, root: TreeNode) -> List[List[int]]:
           if root == None:
               return []
   
           h = collections.defaultdict(list)
           self.pretrave(root, h, 0)
           res = []
           for v in h.values():
               res.append(v)
           return res
   ```

   

#### 5. 锯齿形层序遍历 → **LeetCode 103. Binary Tree Zigzag Level Order Traversal**

#### 6. 垂序遍历 → **LeetCode 987. Vertical Order Traversal of a Binary Tree**

   宽搜

   ```
   class Solution {
   public:
       vector<vector<int>> verticalOrder(TreeNode *root) {
           if (root == nullptr)
               return vector<vector<int>>();
           
           queue<pair<TreeNode*, int>> q;
           q.push({root, 0});
           map<int, vector<int>> hash;
           while (!q.empty())
           {
               auto cur = q.front(); q.pop();
               hash[cur.second].push_back(cur.first->val);
               if (cur.first->left){
                   q.push({cur.first->left, cur.second - 1});
               }
               if (cur.first->right){
                   q.push({cur.first->right, cur.second + 1});
               }
           }
   
           vector<vector<int>> res;
           for (auto v : hash)
           {
               res.push_back(v.second);
           }
           return res;
       }
   };
   ```

   

### 二叉树结构与属性判断

#### 1. 判断二叉树是否对称 → **LeetCode 101. Symmetric Tree**

   递归判断左右，每层的最左边，和最右边是否对称，还有每层的中间

   ```
   class Solution {
   public:
       bool issym(TreeNode* left, TreeNode* right)
       {
           if ((!left && right) || (left && !right))
               return false;
           if (!left && !right)
               return true;
           if (left->val != right->val)
               return false;
           return issym(left->left, right->right) && issym(left->right, right->left);
       }
   
       bool isSymmetric(TreeNode *root) {
           if (root == nullptr)
               return true;
           return issym(root->left, root->right);
       }
   };
   ```

   

#### 2. 二叉树的最大深度 → **LeetCode 104. Maximum Depth of Binary Tree**

   ```
   class Solution {
   public:
       int maxdepth = 0;
       void postorder(TreeNode* root, int depth)
       {
           if (root == nullptr)
               return;
           maxdepth = max(maxdepth, depth);
           postorder(root->left, depth + 1);
           postorder(root->right, depth + 1);
   
       }
       int maxDepth(TreeNode *root) {
           postorder(root, 1);
           return maxdepth;
       }
   };
   ```

   

#### 3. 二叉树的最小深度 → **LeetCode 111. Minimum Depth of Binary Tree**

   ```
       int mindepth = 0x3f3f3f3f;
       bool postorder(TreeNode* root, int depth)
       {
           if (root == nullptr)
               return true;
           auto l = postorder(root->left, depth + 1);
           auto r = postorder(root->right, depth + 1);
           if (l && r)
               mindepth = min(mindepth, depth);
   
           return false;
       }
       int minDepth(TreeNode *root) {
           if (root == nullptr)
               return 0;
           postorder(root, 1);
           return mindepth;
       }
   ```

   

#### 4. 判断平衡二叉树 → **LeetCode 110. Balanced Binary Tree**

   后序遍历

   ```
   class Solution {
   public:
       bool res = true;
       int postorder(TreeNode* root, int depth)
       {
           if (root == nullptr)
               return depth;
   
           int l = postorder(root->left, depth + 1);
           int r = postorder(root->right, depth + 1);
           if (abs(l - r) > 1)
           {
               res = false;
           }
   
           return max(l, r);
       }
       bool isBalanced(TreeNode *root) {
           if (root == nullptr)
               return true;
           postorder(root, 0);
           return res;
       }
   };
   ```

   

#### 5. 判断完全二叉树 → **LeetCode 958. Check Completeness of a Binary Tree**

   宽搜，如果有left,right是null 就标记flag = true, 后面再遇到不空的就认为不是完全二叉树

   ```
   class Solution {
   public:
       bool isCompleteTree(TreeNode* root) {
           if (root == nullptr)
               return true;
           queue<TreeNode*> q;
           q.push(root);
           bool flag = false;
           while (!q.empty())
           {
               int level = q.size();
               while(level--)
               {
                   auto cur = q.front(); q.pop();
   
                   if (cur->left)
                   {
                       if (flag)
                       {
                           return false;
                       }
   
                       q.push(cur->left);
                   }
                   else
                   {
                       flag = true;
                   }
                   if (cur->right)
                   {
                       if (flag)
                       {
                           return false;
                       }
   
                       q.push(cur->right);
                   }
                   else
                   {
                       flag = true;
                   }
               }
           }
           return true;
       }
   };
   ```

   

#### 6. 判断二叉搜索树 → **LeetCode 98. Validate Binary Search Tree**

   ```
   class Solution:
       def dfs(self, root, minv, maxv):
           if root == None:
               return True
           if root.val <= minv or root.val >= maxv:
               return False
           
           return self.dfs(root.left, minv, root.val) and self.dfs(root.right, root.val, maxv)
   
       def is_valid_b_s_t(self, root: TreeNode) -> bool:
           return self.dfs(root, -math.inf, math.inf)
   ```

   

#### 7. 二叉树的直径 → **LeetCode 543. Diameter of Binary Tree**

   ```
   class Solution {
   public:
       int diameterSearch(TreeNode* root, int& res)
       {
           if (root == nullptr)
               return 0;
           auto l = diameterSearch(root->left, res);
           auto r = diameterSearch(root->right, res);
           res = max(res, l + r + 1);
       
           return max(l + 1, r + 1);
       }
       int diameterOfBinaryTree(TreeNode* root) {
           int res = 0;
           diameterSearch(root, res);
           return res - 1;
       }
   };
   ```

   

#### 8. 二叉树的坡度 → **LeetCode 563. Binary Tree Tilt**

   ```
   class Solution {
   public:
       int postorder(TreeNode* root, int& res)
       {
           if (root == nullptr)
               return 0;
           int l = postorder(root->left, res);
           int r = postorder(root->right, res);
   
           res += abs(l - r);
           return l + r + root->val;
       }
       int findTilt(TreeNode *root) {
           if (root == nullptr)
               return 0;
           int res = 0;
           postorder(root, res);
           return res;
       }
   };
   ```

   

### 二叉树路径问题

#### 1. 路径总和 → **LeetCode 112. Path Sum**

   ```
   class Solution {
   public:
       bool dfs(TreeNode* root, int sum, int targetSum)
       {
           if (!root)
               return false;
           if (root->left == nullptr && root->right == nullptr)
           {
               if (sum + root->val == targetSum)
                   return true;
               else
                   return false;
           }
   
           auto l = dfs(root->left, sum + root->val, targetSum);
           auto r = dfs(root->right, sum + root->val, targetSum);
           if (l || r)
               return true; 
           return false;
       }
       bool hasPathSum(TreeNode* root, int targetSum) {
           if (root == nullptr)
               return false;
           return dfs(root, 0, targetSum);
       }
   };
   ```

   ```
   class Solution:
       def hasPathSum(self, root: TreeNode, sum: int) -> bool:
           if not root:
               return False
           if not root.left and not root.right:
               return sum == root.val
           return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)
   ```



#### 2. 路径总和 II → **LeetCode 113. Path Sum II**

   ```
   class Solution {
   public:
       void dfs(TreeNode* root, int targetSum, vector<int> path, int sum, vector<vector<int>>& res)
       {
           if (!root)
               return;
           if (!root->left && !root->right)
           {
               if (sum + root->val == targetSum)
               {
                   path.push_back(root->val);
                   res.push_back(path);
                   return;
               }
               return;
           }
   
           path.push_back(root->val);
           dfs(root->left, targetSum, path, sum + root->val, res);
           dfs(root->right, targetSum, path, sum + root->val, res);
           path.pop_back();
       }
       vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
           if (!root)
               return {};
           vector<vector<int>> res;
           dfs(root, targetSum, {}, 0, res);
           return res;
       }
   };
   ```

   

#### 3. 最长同值路径 → **LeetCode 687. Longest Univalue Path**

   遍历所有node, 对所有node再进行dfs计算所有相同的节点

   ```
   class Solution {
   public:
       int maxlen = 0;
       int count(TreeNode* root, int val)
       {
           if(!root || root->val != val)
               return 0;
           int l = count(root->left, val) + 1;
           int r = count(root->right, val) + 1;
   
           return max(l, r);
       }
       void dfs(TreeNode* root)
       {
           if (root == nullptr)
               return;
           
           int res = count(root->left, root->val) + count(root->right, root->val);
           if (res > maxlen)
               maxlen = res;
           dfs(root->left);
           dfs(root->right);
   
       }
       int longestUnivaluePath(TreeNode *root) {
           if (root == nullptr)
               return 0;
           dfs(root);
           return maxlen;
       }
   };
   ```

 ```
 class Solution:
     def __init__(self):
         self.maxlen = -math.inf
 
     def search(self, root):
         if root == None:
             return 0
         left = self.search(root.left)
         right = self.search(root.right)
 
         curLeft, curRight = 0, 0
         if root.left and root.val == root.left.val:
             curLeft = left + 1
         if root.right and root.val == root.right.val:
             curRight = right + 1
 
         self.maxlen = max(self.maxlen, curLeft + curRight)
         return max(curLeft, curRight)
         
     def longestUnivaluePath(self, root: Optional[TreeNode]) -> int:
         if root == None:
             return 0
         self.search(root)
         return self.maxlen
 ```



#### 4. 二叉树中的最大路径和 → **LeetCode 124. Binary Tree Maximum Path Sum**

   ```
   class Solution {
   public:
       int countMax(TreeNode * root, int& maxVal)
       {
           if (!root)
               return 0;
           
           int leftsum = countMax(root->left, maxVal);
           if (leftsum < 0)
               leftsum = 0;
           int rightsum = countMax(root->right, maxVal);
           if (rightsum < 0)
               rightsum = 0;
           maxVal = max(maxVal, root->val + leftsum + rightsum);
   
           return max(root->val + leftsum, root->val + rightsum);
       }
       int maxPathSum(TreeNode * root) {
           if (!root)
               return 0;
           
           int max = -9999999;
           countMax(root, max);
           return max;
       }
   };
   ```

   ```
   #include <limits>
   class Solution {
   public:
       int maxlen = numeric_limits<int>::min();
       int count(TreeNode* root)
       {
           if (!root)
               return 0;
           int l = count(root->left);
           int r = count(root->right);
           maxlen = max(maxlen, root->val);
           maxlen = max(maxlen, l + root->val);
           maxlen = max(maxlen, r + root->val); 
           maxlen = max(maxlen, l + r + root->val);
           return max(max(l, r) + root->val, root->val);
       }
       int maxPathSum(TreeNode *root) {
           if (root == nullptr)
               return 0;
           count(root);
           return maxlen;
       }
   };
   ```

   

#### 5. 二叉树的所有路径 → **LeetCode 257. Binary Tree Paths**

   ```
   class Solution {
   public:
       void dfs(TreeNode* root, vector<int> path, vector<string>& res)
       {
           if (root == nullptr)
               return;
           if (!root->left && !root->right)
           {
               string tmp = "";
               for (auto c : path)
               {
                   tmp += to_string(c) + "->";
               }
               tmp += to_string(root->val);
               res.push_back(tmp);
               return;
           }
   
           path.push_back(root->val);
           dfs(root->left, path, res);
           dfs(root->right, path, res);
           path.pop_back();
       }
       vector<string> binaryTreePaths(TreeNode *root) {
           if (root == nullptr)
               return {};
           vector<string> res;
           dfs(root, {}, res);
           return res;
       }
   };
   ```

   

### 二叉树构造与修改

#### 1. 从前序与中序遍历序列构造二叉树 → **LeetCode 105. Construct Binary Tree from Preorder and Inorder Traversal**

   先序的第一个是root，在中序中找到这个root，左边是左子树的中序，右边是右子树的中序。算出大小，在先序中找到左子树的先序序列，和有子树的先序序列，继续dfs。

   **build tree tempate:**

   ```
   curRoot = TreeNode(preorder[0])
   
   idx = inorder.index(preorder[0])
   curRoot.left = self.dfs(preorder[1:idx + 1], inorder[:idx])
   curRoot.right = self.dfs(preorder[idx + 1:], inorder[idx + 1:])
   
   return curRoot
   ```

   

   ```
   class Solution:
       def dfs(self, preorder, inorder):
           if len(preorder) == 0 or len(inorder) == 0:
               return None
           if len(preorder) == 1:
               return TreeNode(preorder[0])
   
           curRoot = TreeNode(preorder[0])
           idx = inorder.index(preorder[0])
           curRoot.left = self.dfs(preorder[1:idx + 1], inorder[:idx])
           curRoot.right = self.dfs(preorder[idx + 1:], inorder[idx + 1:])
           return curRoot
   
       def build_tree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
           if preorder == None or inorder == None:
               return None
           return self.dfs(preorder, inorder)
   ```

   

#### 2. 从中序与后序遍历序列构造二叉树 → **LeetCode 106. Construct Binary Tree from Inorder and Postorder Traversal**

   ```
   class Solution:
       def dfs(self, inorder, postorder):
           if postorder == None or len(postorder) == 0:
               return None
           if len(postorder) == 1:
               return TreeNode(postorder[0])
   
           curNode = TreeNode(postorder[-1])
           idx = inorder.index(postorder[-1])
   
           curNode.left = self.dfs(inorder[:idx], postorder[:idx])
           curNode.right = self.dfs(inorder[idx + 1:], postorder[idx: -1])
           return curNode
   
       def build_tree(self, inorder: List[int], postorder: List[int]) -> TreeNode:
           if inorder == None or postorder == None:
               return None
           return self.dfs(inorder, postorder)
   ```

   

#### 3. 最大二叉树 → **LeetCode 654. Maximum Binary Tree**

   ```
   class Solution:
       def dfs(self, nums):
           if len(nums) == 0:
               return None
           if len(nums) == 1:
               return TreeNode(nums[0])
   
           idx = nums.index(max(nums))
           curNode = TreeNode(nums[idx])
           curNode.left = self.dfs(nums[:idx])
           curNode.right = self.dfs(nums[idx + 1:])
           return curNode
   
       def constructMaximumBinaryTree(self, nums: List[int]) -> Optional[TreeNode]:
           if nums == None or len(nums) == 0:
               return None
           return self.dfs(nums)
   ```

   

#### 4. 合并二叉树 → **LeetCode 617. Merge Two Binary Trees**

   ```
       def dfs(self, t1, t2):
           if t1 == None:
               return t2
           if t2 == None:
               return t1
           
           curNode = TreeNode(t1.val + t2.val)
   
           curNode.left = self.dfs(t1.left, t2.left)
           curNode.right = self.dfs(t1.right, t2.right)
   
           return curNode
   
       def merge_trees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:
           return self.dfs(t1, t2)
   ```

   

#### 5. 翻转二叉树 → **LeetCode 226. Invert Binary Tree**

   后序遍历

   ```
   class Solution:
       def dfs(self, root):
           if root == None:
               return
           self.dfs(root.left)
           self.dfs(root.right)
           root.left, root.right = root.right, root.left
   
       def invert_binary_tree(self, root: TreeNode):
           if root == None:
               return
           self.dfs(root)
   ```

   

#### 6. 修剪二叉搜索树 → **LeetCode 669. Trim a Binary Search Tree**  <<<

   ```
   class Solution:
       def dfs(self, root, minimum, maximum):
           if root == None:
               return None
           curNode = None
           if minimum <= root.val and root.val <= maximum:
               curNode = TreeNode(root.val)
           else:
               if root.val < minimum:
                   return self.dfs(root.right, minimum, maximum)
               elif root.val >= maximum:
                   return self.dfs(root.left, minimum, maximum)
           
           curNode.left = self.dfs(root.left, minimum, maximum)
           curNode.right = self.dfs(root.right, minimum, maximum)
   
           return curNode
   
       def trim_b_s_t(self, root: TreeNode, minimum: int, maximum: int) -> TreeNode:
           if root == None:
               return None
           return self.dfs(root, minimum, maximum)
   ```

   

### 二叉搜索树（BST）专项

#### 1. 二叉搜索树的最近公共祖先 → **LeetCode 235. Lowest Common Ancestor of a Binary Search Tree**

   ```
   class Solution:
       """
       @param root: root of the tree
       @param p: the node p
       @param q: the node q
       @return: find the LCA of p and q
       """
       def dfs(self, root, p, q):
           if root == None:
               return None
           if root == p or root == q:
               return root
           if root.val >= p.val and root.val >= q.val:
               return self.dfs(root.left, p, q)
           elif root.val <= p.val and root.val <= q.val:
               return self.dfs(root.right, p, q)
           return root
       def lowestCommonAncestor(self, root, p, q):
           return self.dfs(root, p, q)
   ```

   

#### 2. 二叉搜索树中的搜索 → **LeetCode 700. Search in a Binary Search Tree**

   ```
   class Solution:
       """
       @param root: the tree
       @param val: the val which should be find
       @return: the node
       """
       def dfs(self, root, val):
           if root == None:
               return None
           if root.val < val:
               return self.dfs(root.right, val)
           elif root.val > val:
               return self.dfs(root.left, val)
           return root
       def search_b_s_t(self, root: TreeNode, val: int) -> TreeNode:
           return self.dfs(root, val)
   ```

   

#### 3. 二叉搜索树的最小绝对差 → **LeetCode 530. Minimum Absolute Difference in BST**

   对每个结点查找，最近大于，最近小于，算出diff

   ```
   class Solution:
       """
       @param root: the root
       @return: the minimum absolute difference between values of any two nodes
       """
       mindiff = 0x3f3f3f3f
       def count(self, root):
           if root.left:
               p = root.left
               while p.right:
                   p = p.right
               self.mindiff = min(self.mindiff, abs(p.val - root.val))
           if root.right:
               p = root.right
               while p.left:
                   p = p.left
               self.mindiff = min(self.mindiff, abs(p.val - root.val))
           return self.mindiff
   
       def dfs(self, root):
           if root == None:
               return 0x3f3f3f3f
           self.count(root)
           self.dfs(root.left)
           self.dfs(root.right)
       def get_minimum_difference(self, root: TreeNode) -> int:
           self.dfs(root)
           return self.mindiff
   ```

   

#### 4. 二叉搜索树中的众数 → **LeetCode 501. Find Mode in Binary Search Tree**

   用hash记录出现次数

   ```
   class Solution:
       """
       @param root: a root of integer
       @return: return a integer list
                we will sort your return value in output
       """
       def dfs(self, root, h):
           if root == None:
               return
           h[root.val] += 1
           self.dfs(root.left, h)
           self.dfs(root.right, h)
   
       def find_mode(self, root: TreeNode) -> List[int]:
           if root == None:
               return None
           h = collections.defaultdict(int)
           self.dfs(root, h)
           freq = max(h.values())
           res = [k for k,v in h.items() if v == freq]
           return res
   ```

   

#### 5. 把二叉搜索树转换为累加树 → **LeetCode 538. Convert BST to Greater Tree**

```
class Solution {
public:
    int sum = 0;
    TreeNode* convertBST(TreeNode* root) {
        if (root != nullptr) {
            convertBST(root->right);
            sum += root->val;
            root->val = sum;
            convertBST(root->left);
        }
        return root;
    }
};
```



   右-中-左，将sum传给左子树

   ```
   class Solution:
       def dfs(self, root, s):
           if root == None:
               return 0
           r = self.dfs(root.right, s)
           root.val += r
           ret = root.val
           root.val += s
           l = self.dfs(root.left, root.val)
   
           return ret + l
   
       def convert_b_s_t(self, root: TreeNode) -> TreeNode:
           if root == None:
               return None
           self.dfs(root, 0)
           return root
   ```

   

#### 6. 最大 BST 子树 → **LeetCode 333. Largest BST Subtree**    <<<<

   判断是否是BST树，1. 左右子树都是BST  2. 当前节点的值大于左子树中的最大值 3. 当前节点的值小于右子树的最小值

   ```
       def dfs(self, root):
           if root == None:
               return True, 0, -math.inf, math.inf
   
           lbst, lsize, lmax, lmin = self.dfs(root.left)
           rbst, rsize, rmax, rmin = self.dfs(root.right)
           bst = lbst and rbst and root.val > lmax and root.val < rmin
   
           curSize = 0
           if bst:
               curSize = lsize + rsize + 1
           else:
               curSize = max(lsize, rsize)
           retmax = max(root.val, max(lmax, rmax))
           retmin = min(root.val, min(lmin, rmin))
           return bst, curSize, retmax, retmin
   
           
       def largest_b_s_t_subtree(self, root: TreeNode) -> int:
           if root == None:
               return 0
           bst, msize, retmax, retmin = self.dfs(root)
           return msize
   ```

   

### 二叉树公共祖先问题

#### 1. 二叉树的最近公共祖先 → **LeetCode 236. Lowest Common Ancestor of a Binary Tree**

```
bool dfs(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (root == nullptr) 
    	return false;
    bool lson = dfs(root->left, p, q);
    bool rson = dfs(root->right, p, q);
    if ((lson && rson) || ((root->val == p->val || root->val == q->val) && (lson || rson))) {
        ans = root;
    } 
    return lson || rson || (root->val == p->val || root->val == q->val);
}
```



   三种情况，1. root在A,B中间，直接返回root            2. l 等于A或B 则返回 l     3.  r 等于A或B 则返回 r     4. 其余返回None

   ```
   class Solution:
       """
       @param: root: The root of the binary tree.
       @param: A: A TreeNode in a Binary.
       @param: B: A TreeNode in a Binary.
       @return: Return the least common ancestor(LCA) of the two nodes.
       """
       def dfs(self, root, A, B):
           if root == None:
               return None
           if root.val == A.val or root.val == B.val:
               return root
           l = self.dfs(root.left, A, B)
           r = self.dfs(root.right, A, B)
   
           if r and l:
               return root
           if r:
               return r
           if l:
               return l
           return None
       def lowestCommonAncestor(self, root, A, B):
           return self.dfs(root, A, B)
   ```

   

#### 2. 二叉树的最近公共祖先 III → **LeetCode 1650. Lowest Common Ancestor of a Binary Tree III**

```
class Solution:
    """
    @param: root: The root of the binary tree.
    @param: A: A TreeNode
    @param: B: A TreeNode
    @return: Return the LCA of the two nodes.
    """
    res = None
    def dfs(self, root, A, B):
        if root == None:
            return 0

        count = 0
        if root.val == A.val or root.val == B.val:
            count += 1

        l = self.dfs(root.left, A, B)
        r = self.dfs(root.right, A, B)
        if l == 2 or r == 2:
            return 2
        count += l + r
        if count == 2:
            self.res = root
        return count

    def lowestCommonAncestor3(self, root, A, B):
        self.dfs(root, A, B)
        return self.res
```

```
    TreeNode* ans = nullptr;
    bool dfs(TreeNode * root, TreeNode * p, TreeNode * q)
    {
        if (root == nullptr) 
        	return false;
        bool lson = dfs(root->left, p, q);
        bool rson = dfs(root->right, p, q);
        if ((lson && rson) || ((root->val == p->val || root->val == q->val) && (lson || rson))) {
            ans = root;
        } 
        return lson || rson || (root->val == p->val || root->val == q->val);
    }
    TreeNode * lowestCommonAncestor3(TreeNode * root, TreeNode * A, TreeNode * B) {
        dfs(root, A, B);
        return ans;
    }
```



### 其他高频题

#### 1. 填充每个节点的下一个右侧节点指针 → **LeetCode 116. Populating Next Right Pointers in Each Node**

```
class Solution {
public:
    /**
     * @param root: root of a tree
     * @return: head node of a doubly linked list
     */
    void midtrav(TreeNode* root, vector<TreeNode*>& res)
    {
        if (!root)
            return;
        midtrav(root->left, res);
        res.push_back(root);
        midtrav(root->right, res);
    }
    TreeNode * treeToDoublyList(TreeNode * root) {
        vector<TreeNode*> res;
        midtrav(root, res);
        TreeNode* head = new TreeNode(-1);
        TreeNode* h = head;
        for (auto n : res)
        {
            h->right = n;
            n->left = h;
            h = h->right;
        }
        h->right = head->right;
        head->right->left = h;
        return head->right;
    }
};
```



#### 2. 二叉树的序列化与反序列化 → **LeetCode 297. Serialize and Deserialize Binary Tree**

BFS

```
class Solution:
    """
    @param root: An object of TreeNode, denote the root of the binary tree.
    This method will be invoked first, you should design your own algorithm 
    to serialize a binary tree which denote by a root node to a string which
    can be easily deserialized by your own "deserialize" method later.
    """
    def serialize(self, root):
        if root is None:
            return ""
            
        # use bfs to serialize the tree
        queue = deque([root])
        bfs_order = []
        while queue:
            node = queue.popleft()
            bfs_order.append(str(node.val) if node else '#')
            if node:
                queue.append(node.left)
                queue.append(node.right)
            
        return ' '.join(bfs_order)

    """
    @param data: A string serialized by your serialize method.
    This method will be invoked second, the argument data is what exactly
    you serialized at method "serialize", that means the data is not given by
    system, it's given by your own serialize method. So the format of data is
    designed by yourself, and deserialize it here as you serialize it in 
    "serialize" method.
    """
    def deserialize(self, data):
        # None or ""
        if not data:
            return None

        bfs_order = [
            TreeNode(int(val)) if val != '#' else None
            for val in data.split()
        ]
        root = bfs_order[0]
        fast_index = 1
        
        nodes, slow_index = [root], 0
        while slow_index < len(nodes):
            node = nodes[slow_index]
            slow_index += 1
            node.left = bfs_order[fast_index]
            node.right = bfs_order[fast_index + 1]
            fast_index += 2
            
            if node.left:
                nodes.append(node.left)
            if node.right:
                nodes.append(node.right)
        
        return root
```



#### 3. 左叶子之和 → **LeetCode 404. Sum of Left Leaves**

```
class Solution:
    """
    @param root: t
    @return: the sum of all left leaves
    """

    def dfs(self, root, flag, res):
        if root == None:
            return None
        self.dfs(root.left, True, res)
        self.dfs(root.right, False, res)
        if flag and not root.left and not root.right:
            res.append(root)

    def sum_of_left_leaves(self, root: TreeNode) -> int:
        if root == None:
            return 0
        res = []
        self.dfs(root, False, res)
        s = 0
        for n in res:
            s += n.val
        return s
```



#### 4. 找树左下角的值 → **LeetCode 513. Find Bottom Left Tree Value**

BFS

```
class Solution:
    """
    @param root: a root of tree
    @return: return a integer
    """
    def find_bottom_left_value(self, root: TreeNode) -> int:
        if root == None:
            return None
           
        q = collections.deque([root])
        res = None
        while len(q) > 0:
            level = len(q)
            res = None
            while level > 0:
                level -= 1
                cur = q.popleft()
                if res == None:
                    res = cur
                if cur.left:
                    q.append(cur.left)
                if cur.right:
                    q.append(cur.right)
        return res.val
```



### 910 · Largest BST Subtree

```
class Solution:
    def largestBSTSubtree(self, root: TreeNode) -> int:
        if root is None:
            return 0

        _, size, _, _ = self.helper(root)
        return size

    def helper(self, root):
        if root is None:
            return True, 0, sys.maxsize, -sys.maxsize

        l_bst, l_size, l_min, l_max = self.helper(root.left)
        r_bst, r_size, r_min, r_max = self.helper(root.right)

        bst = l_bst and r_bst and root.val > l_max and root.val < r_min

        if bst:
            size = l_size + r_size + 1
        else:
            size = max(l_size, r_size)

        return bst, size, min(l_min, r_min, root.val), max(l_max, r_max, root.val)
```

