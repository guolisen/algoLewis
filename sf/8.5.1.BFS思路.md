### 一、树与二叉树层序遍历（BFS 基础场景）

1. **LeetCode 102. Binary Tree Level Order Traversal（二叉树的层序遍历）**
    - 思路：BFS 队列实现，每层节点依次入队，遍历并记录节点值，形成二维结果。
2. **LeetCode 107. Binary Tree Level Order Traversal II（二叉树的层序遍历 II，自底向上）**
    - 思路：BFS 层序遍历后，将结果列表反转；或从叶子层开始构建结果。
3. **LeetCode 103. Binary Tree Zigzag Level Order Traversal（二叉树的锯齿形层序遍历）**
    - 思路：BFS 队列记录每层节点，奇数层正序、偶数层逆序（或用双端队列调整插入顺序）。
4. **LeetCode 199. Binary Tree Right Side View（二叉树的右视图）**
    - 思路：BFS 层序遍历，记录每层最后一个节点。
5. **LeetCode 116. Populating Next Right Pointers in Each Node（填充每个节点的下一个右侧节点指针）**
    - 思路：BFS 层序遍历，每层节点依次连接 `next` 指针；或利用已连接的 `next` 指针递归处理子节点。
6. **LeetCode 513. Find Bottom Left Tree Value（找树左下角的值）**
    - 思路：BFS 层序遍历，记录每层第一个节点，最后一层的第一个节点即为结果。
7. **LeetCode 111. Minimum Depth of Binary Tree（二叉树的最小深度）**
    - 思路：BFS 层序遍历，遇到第一个叶子节点时的层数即为最小深度（比 DFS 更高效）。

### 二、图与网格相关（最短路径 / 连通性）

1. **LeetCode 200. Number of Islands（岛屿数量）**
    - 思路：网格 BFS，遍历每个陆地（'1'），并将其及相邻陆地标记为已访问（'0'），每轮 BFS 对应一个岛屿。
2. **LeetCode 695. Max Area of Island（岛屿的最大面积）**
    - 思路：网格 BFS，遍历每个陆地时计算连通区域的面积，更新最大值。
3. **LeetCode 130. Surrounded Regions（被围绕的区域）**
    - 思路：边界 BFS + 标记，先对边界的 'O' 及其连通区域标记为临时值，再将未标记的 'O' 改为 'X'，标记的临时值改回 'O'。
4. **LeetCode 417. Pacific Atlantic Water Flow（太平洋大西洋水流问题）**
    - 思路：双向 BFS，分别从太平洋边界和大西洋边界出发，记录能到达的节点，最后取两者的交集。
5. **LeetCode 994. Rotting Oranges（腐烂的橘子）**
    - 思路：多源 BFS，初始将所有腐烂橘子入队，每次腐烂相邻新鲜橘子，统计时间（层数）。
6. **LeetCode 542. 01 Matrix（01 矩阵）**
    - 思路：多源 BFS，初始将所有 '0' 入队，计算每个 '1' 到最近 '0' 的最短距离。
7. **LeetCode 286. Walls and Gates（墙与门）**
    - 思路：多源 BFS，初始将所有门（0）入队，计算每个空房间（INF）到最近门的距离。
8. **LeetCode 207. Course Schedule（课程表）**
    - 思路：拓扑排序 + BFS 入度统计（Kahn 算法），若最终所有节点入度为 0 则可完成，否则存在环。
9. **LeetCode 210. Course Schedule II（课程表 II）**
    - 思路：BFS 拓扑排序（Kahn 算法），记录入度为 0 的节点顺序，即为拓扑序列。

### 三、最短路径问题（无权图 / 简单权重）

1. **LeetCode 111. Minimum Depth of Binary Tree（二叉树的最小深度）**
    - 思路：BFS 层序遍历，遇到第一个叶子节点时的层数即为树的最短路径（最小深度）。
2. **LeetCode 127. Word Ladder（单词接龙）**
    - 思路：无权图最短路径 BFS，将单词视为节点，相邻单词（仅一个字母不同）为边，求起始到目标的最短步数。
3. **LeetCode 126. Word Ladder II（单词接龙 II）**
    - 思路：BFS 找最短路径长度，DFS 收集所有最短路径；或 BFS 过程中记录父节点，再回溯生成路径。
4. **LeetCode 752. Open the Lock（打开转盘锁）**
    - 思路：多源 BFS，初始将 "0000" 入队，每次尝试转动一位（+1 或 -1），统计到目标状态的最少转动次数。
5. **LeetCode 279. Perfect Squares（完全平方数）**
    - 思路：BFS，将数字视为节点，相邻节点为 `n - i²`（i 为平方数），求从 n 到 0 的最短路径（最少平方数之和）。
6. **LeetCode 433. Minimum Genetic Mutation（最小基因变化）**
    - 思路：类似单词接龙 BFS，基因序列视为节点，相邻序列（仅一个字符不同）为边，求起始到目标的最短变化次数。

### 四、其他高频 BFS 题

1. **LeetCode 297. Serialize and Deserialize Binary Tree（二叉树的序列化与反序列化）**
    - 思路：BFS 层序序列化（记录空节点），反序列化时根据层序序列递归重建。
2. **LeetCode 886. Possible Bipartition（可能的二分图）**
    - 思路：二分图判断 + BFS，对每个未染色节点进行 BFS，尝试染色（两种颜色），若相邻节点颜色冲突则无法二分。
3. **LeetCode 1302. Deepest Leaves Sum（层数最深叶子节点的和）**
    - 思路：BFS 层序遍历，记录最后一层（最深层）的节点值之和。
4. **LeetCode 235. Lowest Common Ancestor of a Binary Search Tree（二叉搜索树的最近公共祖先）**
    - 思路：BFS 迭代实现，利用 BST 性质（根节点值在 p、q 之间则是公共祖先）。
5. **LeetCode 236. Lowest Common Ancestor of a Binary Tree（二叉树的最近公共祖先）**
    - 思路：BFS 记录每个节点的父节点，然后回溯 p 和 q 的路径，找第一个交集节点。