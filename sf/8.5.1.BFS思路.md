### 一、树与二叉树层序遍历（BFS 基础场景）

1. **LeetCode 102. Binary Tree Level Order Traversal（二叉树的层序遍历）**
    - **题目描述**：给定二叉树的根节点，返回按层级从左到右遍历的节点值（结果为二维列表，每层节点值组成一个子列表）。
    - **示例**：输入 `3->9->20->null->null->15->7`，输出 `[[3], [9,20], [15,7]]`。
    - 思路：BFS 队列实现，每层节点依次入队，遍历并记录节点值，形成二维结果。
2. **LeetCode 107. Binary Tree Level Order Traversal II（二叉树的层序遍历 II，自底向上）**
    - **题目描述**：给定二叉树的根节点，返回自底向上的层序遍历结果（即从叶子层到根层，每层节点值组成子列表）。
    - **示例**：输入同上，输出 `[[15,7], [9,20], [3]]`。
    - 思路：BFS 层序遍历后，将结果列表反转；或从叶子层开始构建结果。
3. **LeetCode 103. Binary Tree Zigzag Level Order Traversal（二叉树的锯齿形层序遍历）**
    - **题目描述**：给定二叉树的根节点，返回锯齿形层序遍历结果（奇数层从左到右，偶数层从右到左，结果为二维列表）。
    - **示例**：输入同上，输出 `[[3], [20,9], [15,7]]`。
    - 思路：BFS 队列记录每层节点，奇数层正序、偶数层逆序（或用双端队列调整插入顺序）。
4. **LeetCode 199. Binary Tree Right Side View（二叉树的右视图）**
    - **题目描述**：给定二叉树的根节点，返回从右侧能看到的节点值（即每层最右侧的节点）。
    - **示例**：输入 `1->2->3->null->5->null->4`，输出 `[1,3,4]`。
    - 思路：BFS 层序遍历，记录每层最后一个节点。
5. **LeetCode 116. Populating Next Right Pointers in Each Node（填充每个节点的下一个右侧节点指针）**
    - **题目描述**：给定完美二叉树（所有叶子在同一层，每个父节点有两个子节点），填充每个节点的 `next` 指针，使其指向同一层右侧节点（最后一个节点 `next` 为 `null`）。
    - **示例**：输入 `1->2->3->4->5->6->7`，填充后 `2.next=3`，`4.next=5`，`5.next=6` 等。
    - 思路：BFS 层序遍历，每层节点依次连接 `next` 指针；或利用已连接的 `next` 指针递归处理子节点。
6. **LeetCode 513. Find Bottom Left Tree Value（找树左下角的值）**
    - **题目描述**：给定二叉树的根节点，返回最底层（最深层）最左边节点的值。
    - **示例**：输入 `2->1->3`，输出 `1`；输入 `1->2->3->4->null->5->6->null->null->7`，输出 `7`。
    - 思路：BFS 层序遍历，记录每层第一个节点，最后一层的第一个节点即为结果。
7. **LeetCode 111. Minimum Depth of Binary Tree（二叉树的最小深度）**
    - **题目描述**：给定二叉树的根节点，返回根到最近叶子节点的最短路径上的节点数（最小深度）。
    - **示例**：输入 `3->9->20->null->null->15->7`，输出 `2`（根到叶子 9 的路径）。
    - 思路：BFS 层序遍历，遇到第一个叶子节点时的层数即为最小深度（比 DFS 更高效）。

### 二、图与网格相关（最短路径 / 连通性）

1. **LeetCode 200. Number of Islands（岛屿数量）**
    - **题目描述**：给定 `m x n` 网格，`'1'` 代表陆地，`'0'` 代表水，相邻陆地（水平 / 垂直）组成岛屿，返回岛屿的数量。
    - **示例**：输入 `[["1","1","0","0","0"],["1","1","0","0","0"],["0","0","1","0","0"],["0","0","0","1","1"]]`，输出 `3`。
    - 思路：网格 BFS，遍历每个陆地（'1'），并将其及相邻陆地标记为已访问（'0'），每轮 BFS 对应一个岛屿。
2. **LeetCode 695. Max Area of Island（岛屿的最大面积）**
    - **题目描述**：给定 `m x n` 网格，`'1'` 代表陆地，`'0'` 代表水，返回最大岛屿的面积（岛屿面积为陆地单元格数量）。
    - **示例**：输入含一个 6 单元格的岛屿，输出 `6`。
    - 思路：网格 BFS，遍历每个陆地时计算连通区域的面积，更新最大值。
3. **LeetCode 130. Surrounded Regions（被围绕的区域）**
    - **题目描述**：给定 `m x n` 网格，`'X'` 和 `'O'` 组成，被 `'X'` 完全包围的 `'O'` 需改为 `'X'`，边界上的 `'O'` 及其连通区域不变。
    - **示例**：输入边界有 `'O'` 时，其连通区域保留，其他 `'O'` 改为 `'X'`。
    - 思路：边界 BFS + 标记，先对边界的 'O' 及其连通区域标记为临时值，再将未标记的 'O' 改为 'X'，标记的临时值改回 'O'。
4. **LeetCode 417. Pacific Atlantic Water Flow（太平洋大西洋水流问题）**
    - **题目描述**：给定 `m x n` 高度矩阵，太平洋在左 / 上边界，大西洋在右 / 下边界，水流只能从高到低或等高流动，返回既能流到太平洋又能流到大西洋的单元格坐标。
    - **示例**：输入 `[[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]`，输出符合条件的坐标列表。
    - 思路：双向 BFS，分别从太平洋边界和大西洋边界出发，记录能到达的节点，最后取两者的交集。
5. **LeetCode 994. Rotting Oranges（腐烂的橘子）**
    - **题目描述**：给定 `m x n` 网格，`0` 是空，`1` 是新鲜橘子，`2` 是腐烂橘子，腐烂橘子每天会感染上下左右的新鲜橘子，返回所有橘子腐烂的天数（若有新鲜橘子无法腐烂，返回 `-1`）。
    - **示例**：输入 `[[2,1,1],[1,1,0],[0,1,1]]`，输出 `4`。
    - 思路：多源 BFS，初始将所有腐烂橘子入队，每次腐烂相邻新鲜橘子，统计时间（层数）。
6. **LeetCode 542. 01 Matrix（01 矩阵）**
    - **题目描述**：给定 `m x n` 的二进制矩阵，返回一个矩阵，其中每个元素是该位置到最近的 `0` 的最短距离（距离为相邻单元格的步数）。
    - **示例**：输入 `[[0,0,0],[0,1,0],[1,1,1]]`，输出 `[[0,0,0],[0,1,0],[1,2,1]]`。
    - 思路：多源 BFS，初始将所有 '0' 入队，计算每个 '1' 到最近 '0' 的最短距离。
7. **LeetCode 286. Walls and Gates（墙与门）**
    - **题目描述**：给定 `m x n` 矩阵，`-1` 是墙，`0` 是门，`INF` 是空房间，计算每个空房间到最近门的距离（门到自身距离为 0，墙不可达）。
    - **示例**：输入含门和空房间的矩阵，输出每个房间到最近门的距离矩阵。
    - 思路：多源 BFS，初始将所有门（0）入队，计算每个空房间（INF）到最近门的距离。
8. **LeetCode 207. Course Schedule（课程表）**
    - **题目描述**：给定 `numCourses` 门课程和先修课程列表 `prerequisites`（如 `[a,b]` 表示修 a 前需先修 b），判断是否可能完成所有课程。
    - **示例**：`numCourses=2`，`prerequisites=[[1,0]]`，输出 `true`；若含环则输出 `false`。
    - 思路：拓扑排序 + BFS 入度统计（Kahn 算法），若最终所有节点入度为 0 则可完成，否则存在环。
9. **LeetCode 210. Course Schedule II（课程表 II）**
    - **题目描述**：同上，若可能完成所有课程，返回课程学习顺序（拓扑序列）；否则返回空数组。
    - **示例**：`numCourses=4`，`prerequisites=[[1,0],[2,0],[3,1],[3,2]]`，输出 `[0,1,2,3]` 等合法顺序。
    - 思路：BFS 拓扑排序（Kahn 算法），记录入度为 0 的节点顺序，即为拓扑序列。

### 三、最短路径问题（无权图 / 简单权重）

1. **LeetCode 111. Minimum Depth of Binary Tree（二叉树的最小深度）**
    - **题目描述**：给定二叉树的根节点，返回根到最近叶子节点的最短路径上的节点数（最小深度）。
    - **示例**：输入 `3->9->20->null->null->15->7`，输出 `2`。
    - 思路：BFS 层序遍历，遇到第一个叶子节点时的层数即为树的最短路径（最小深度）。
2. **LeetCode 127. Word Ladder（单词接龙）**
    - **题目描述**：给定开始单词 `beginWord`、目标单词 `endWord` 和单词列表 `wordList`，每次可将单词中的一个字母替换为其他字母，且新单词必须在 `wordList` 中，返回从 `beginWord` 到 `endWord` 的最短转换步数（若无法转换，返回 0）。
    - **示例**：`beginWord="hit"`，`endWord="cog"`，`wordList=["hot","dot","dog","lot","log","cog"]`，输出 `5`（hit→hot→dot→dog→cog）。
    - 思路：无权图最短路径 BFS，将单词视为节点，相邻单词（仅一个字母不同）为边，求起始到目标的最短步数。
3. **LeetCode 126. Word Ladder II（单词接龙 II）**
    - **题目描述**：同上，返回所有从 `beginWord` 到 `endWord` 的最短转换路径（路径中每个单词需在 `wordList` 中）。
    - **示例**：输入同上，输出 `[["hit","hot","dot","dog","cog"],["hit","hot","lot","log","cog"]]`。
    - 思路：BFS 找最短路径长度，DFS 收集所有最短路径；或 BFS 过程中记录父节点，再回溯生成路径。
4. **LeetCode 752. Open the Lock（打开转盘锁）**
    - **题目描述**：转盘锁有 4 个数字（0-9），每次可将一个数字加 1 或减 1（9+1=0，0-1=9），`deadends` 是无法到达的状态，返回从 "0000" 到目标状态 `target` 的最少转动次数（若无法到达，返回 -1）。
    - **示例**：`target="0202"`，`deadends=["0201","0101","0102","1212","2002"]`，输出 `6`。
    - 思路：多源 BFS，初始将 "0000" 入队，每次尝试转动一位（+1 或 -1），统计到目标状态的最少转动次数。
5. **LeetCode 279. Perfect Squares（完全平方数）**
    - **题目描述**：给定正整数 `n`，找到若干个完全平方数（如 1,4,9,...），使其和等于 `n`，返回组成和的最少平方数个数。
    - **示例**：`n=12`，输出 `3`（4+4+4）；`n=13`，输出 `2`（4+9）。
    - 思路：BFS，将数字视为节点，相邻节点为 `n - i²`（i 为平方数），求从 n 到 0 的最短路径（最少平方数之和）。
6. **LeetCode 433. Minimum Genetic Mutation（最小基因变化）**
    - **题目描述**：基因序列由 'A'、'C'、'G'、'T' 组成，每次可将一个字符替换为其他三种之一，`bank` 是有效基因序列列表，返回从 `start` 到 `end` 的最少变化次数（若无法变化，返回 -1）。
    - **示例**：`start="AACCGGTT"`，`end="AACCGGTA"`，`bank=["AACCGGTA"]`，输出 `1`。
    - 思路：类似单词接龙 BFS，基因序列视为节点，相邻序列（仅一个字符不同）为边，求起始到目标的最短变化次数。

### 四、其他高频 BFS 题

1. **LeetCode 297. Serialize and Deserialize Binary Tree（二叉树的序列化与反序列化）**
    - **题目描述**：设计算法将二叉树序列化为字符串，再将字符串反序列化为原始二叉树（序列化格式自定义）。
    - **示例**：序列化 `1->2->3->null->null->4->5` 为 `"1,2,3,null,null,4,5"`，反序列化后恢复原树。
    - 思路：BFS 层序序列化（记录空节点），反序列化时根据层序序列递归重建。
2. **LeetCode 886. Possible Bipartition（可能的二分图）**
    - **题目描述**：给定 `n` 个人和不友好关系列表 `dislikes`（如 `[a,b]` 表示 a 和 b 不友好），判断能否将所有人分为两组，使每组内无不友好关系（二分图）。
    - **示例**：`n=4`，`dislikes=[[1,2],[1,3],[2,4]]`，输出 `true`（分组 [1,4] 和 [2,3]）。
    - 思路：二分图判断 + BFS，对每个未染色节点进行 BFS，尝试染色（两种颜色），若相邻节点颜色冲突则无法二分。
3. **LeetCode 1302. Deepest Leaves Sum（层数最深叶子节点的和）**
    - **题目描述**：给定二叉树的根节点，返回所有层数最深的叶子节点的值之和。
    - **示例**：输入 `1->2->3->4->5->null->6->7->null->null->null->null->8`，最深叶子为 7 和 8，输出 `15`。
    - 思路：BFS 层序遍历，记录最后一层（最深层）的节点值之和。
4. **LeetCode 235. Lowest Common Ancestor of a Binary Search Tree（二叉搜索树的最近公共祖先）**
    - **题目描述**：给定二叉搜索树的根节点和两个节点 `p`、`q`，找到它们的最近公共祖先（LCA：两节点的公共祖先中最深的那个）。
    - **示例**：输入 BST `6->2->8->0->4->7->9->null->null->3->5`，`p=2`，`q=8`，返回 `6`。
    - 思路：BFS 迭代实现，利用 BST 性质（根节点值在 p、q 之间则是公共祖先）。
5. **LeetCode 236. Lowest Common Ancestor of a Binary Tree（二叉树的最近公共祖先）**
    - **题目描述**：给定二叉树的根节点和两个节点 `p`、`q`，找到它们的最近公共祖先（节点可以是自身的祖先）。
    - **示例**：输入二叉树 `3->5->1->6->2->0->8->null->null->7->4`，`p=5`，`q=4`，返回 `5`。
    - 思路：BFS 记录每个节点的父节点，然后回溯 p 和 q 的路径，找第一个交集节点。