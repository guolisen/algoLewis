# 短URL系统高性能与高可用设计（面试回答方案）

面试官您好，短URL系统的核心价值是“空间压缩”与“链路追踪”，而大规模用户场景下，高性能（低延迟、高并发）和高可用（少故障、秒级恢复）是系统的生命线。我的回答将围绕“**架构分层解耦**、**核心模块极致优化**、**全链路容错兜底**”三个核心思路展开，结合具体设计方案说明如何实现目标。

# 一、先明确核心挑战：大规模用户下的性能与可用痛点

在百万级QPS、亿级用户规模下，系统会面临三个核心问题：

- **性能瓶颈**：短码与长URL的映射查询是高频操作，若用传统数据库（如MySQL）直接查询，磁盘IO会成为瓶颈，延迟可能从毫秒级飙升至百毫秒级；

- **可用性风险**：单节点故障、数据库宕机、网络分区等问题，会直接导致“短URL无法跳转”，影响用户体验；

- **并发冲突**：短码生成时的唯一性校验、高并发下的缓存击穿/雪崩，会进一步放大性能与可用问题。

基于这些痛点，我的设计核心是“**缓存优先、异步解耦、多活冗余**”，通过分层架构将性能瓶颈前置解决，用容错机制覆盖各类故障场景。

# 二、高性能设计：从“查得快”到“不查也快”

高性能的核心是“减少慢查询、避免无效计算”，通过“缓存穿透-缓存-数据库”的三级查询链路，配合短码生成优化，将核心接口延迟控制在10ms以内。

## 1. 架构分层：用“缓存+数据库”实现读写分离与查询加速

采用“接入层-缓存层-存储层”的三层架构，核心是将高频查询的短码映射全量放入缓存，数据库仅负责持久化与兜底：

- **接入层**：部署Nginx集群+Lua脚本，实现“短码合法性校验”（如长度、字符范围）和“请求限流”（防止恶意刷量），无效请求直接拦截，不进入后续链路；

- **缓存层**：采用Redis集群（主从+哨兵），将“短码→长URL”的映射作为String类型存储，设置过期时间（如7天，配合后台定时刷新），支持百万级QPS查询（Redis单机可支撑10万+QPS，集群可横向扩展）；

- **存储层**：用MySQL分库分表存储全量映射关系，按“短码首字符”哈希分表（如分16张表），避免单表数据量过大导致的查询缓慢，同时开启MySQL查询缓存（针对低频冷数据）。

**查询链路**：用户请求→Nginx校验→Redis查询（命中则直接返回长URL并跳转）→Redis未命中则查询MySQL→将结果回写Redis→返回跳转。该链路中，99%的高频请求会在Redis层完成，延迟控制在1-3ms。

## 2. 短码生成：预生成待分配池+实时绑定，兼顾唯一与高效

短码生成的核心是“为用户提交的长URL分配唯一短码”，若实时生成并校验唯一性（如查数据库确认无重复），高并发下会因“重复校验”导致数据库锁等待。优化设计是“**预生成唯一短码池+实时绑定长URL**”，本质是将“短码唯一性校验”前置到池化阶段，用户请求时仅需“取码+绑定”，大幅提升性能：

- **短码预生成（核心：保证唯一不重复）**：后台定时任务（如每10秒）批量生成10万条“全局唯一短码”，存入Redis的List结构作为“待分配短码池”。唯一性通过“62进制编码（a-z/A-Z/0-9共62字符）+ 机器ID + 时间戳微秒级”实现——例如短码格式为“8位字符”，前2位是机器ID哈希（避免多节点生成冲突），中间3位是时间戳微秒截断（保证时序唯一），后3位是随机数（补充熵值），理论上可生成62^8≈3.8万亿条唯一短码，完全满足亿级用户需求；

- **实时绑定（用户请求触发）**：用户提交长URL时，应用服务从本地缓存的“待分配短码”中取1条，执行两步操作：① 用Redis的SETNX命令存储“短码→长URL”映射（确保同一短码仅绑定一次）；② 同步写入MySQL完成持久化。若SETNX失败（极端情况短码重复），立即取下一条短码重试，重试3次仍失败则触发短码池补充；

- **池化补充机制（按需动态扩容）**：① 应用服务本地缓存：启动时从Redis短码池批量取1000条，避免频繁网络请求；当本地缓存剩余量<200条时，异步从Redis补充；② Redis短码池：当剩余量<1万条时，触发定时任务紧急生成50万条补充，防止池空；③ 长URL去重优化：用户提交长URL前，先通过MD5哈希生成“长URL特征码”，查Redis是否已存在映射——若存在直接返回已有短码，避免重复分配。

该方案的核心优势：① 短码唯一性由“预生成规则”而非“实时查库”保证，写操作延迟从50ms（查库校验）降至5ms以内；② 长URL去重避免冗余短码，解决“预生成浪费”问题；③ 池化机制应对突发高并发——如秒杀活动瞬间10万用户提交长URL，本地缓存可直接支撑，无需等待短码生成。


示例：用户提交长URL“https://www.example.com/2024-sales-promotion”的完整流程
1. 系统计算长URL的MD5特征码“a1b2c3d4...”，查Redis发现无映射；
2. 从本地缓存取预生成短码“q2W7x9Z3”；
3. 执行Redis命令“SETNX q2W7x9Z3 https://www.example.com/2024-sales-promotion”，返回成功（绑定完成）；
4. 异步写入MySQL（短码表：q2W7x9Z3 | 长URL | 特征码 | 创建时间）；
5. 向用户返回短URL“https://t.cn/q2W7x9Z3”，全程耗时3ms。


## 3. 核心优化：缓存穿透/击穿/雪崩的防护

缓存是高性能的核心，但缓存异常会直接击垮数据库，需针对性防护：

- **缓存穿透**：对“不存在的短码”，在Redis中存储“空值”（如“null”）并设置5分钟过期，同时在接入层拦截非法短码（如包含特殊字符、长度不符）；

- **缓存击穿**：对热点短码（如爆款活动链接），设置Redis永不过期，同时用Redis的SETNX（分布式锁）控制数据库查询的并发度（同一短码仅允许1个请求查库）；

- **缓存雪崩**：将短码的Redis过期时间增加随机值（如7天±30分钟），避免大量Key同时过期，同时Redis集群采用主从复制，主节点故障时从节点秒级切换。

# 三、高可用设计：从“少故障”到“故障不影响”

**注**：高可用需建立在安全基础上，以下先补充网络安全设计，再展开高可用核心方案——安全是高性能与高可用的前提，可有效抵御恶意攻击导致的系统不可用。

## 0. 网络安全专项设计：抵御恶意攻击，保障系统底线

短URL系统的安全风险核心是“滥用资源”（如不存在短码攻击、恶意生成短码）和“数据泄露”（如短码猜解），需从“接入拦截-业务校验-行为风控”三层构建防护体系，重点解决“超大量不存在短码攻击”等极端问题。

### （1）核心目标：针对性解决三大极端攻击场景

- **场景1：不存在短码攻击**：恶意用户批量请求随机短码（如“t.cn/a1b2c3”“t.cn/a1b2c4”），利用“Redis未命中→查MySQL”的链路，通过百万级QPS击垮MySQL；

- **场景2：短码猜解攻击**：恶意用户通过遍历62进制短码，获取他人隐私长URL（如内部文档、个人链接）；

- **场景3：恶意生成攻击**：利用短URL跳转特性，批量生成指向钓鱼网站、病毒链接的短码，规避平台审核。

### （2）接入层：前置拦截，过滤90%恶意请求

接入层是安全第一道防线，基于Nginx+CDN实现“轻量校验、快速拦截”，不影响核心链路性能：

- **① 不存在短码攻击防护（核心）**：
- 基于布隆过滤器（Bloom Filter）实现“短码存在性预校验”：将全量有效短码哈希存入Redis布隆过滤器（占用空间极小，1亿条短码仅需12MB），Nginx通过Lua脚本同步调用该过滤器——不存在的短码直接返回404，不进入Redis/MySQL链路；
- 布隆过滤器更新机制：短码生成后异步同步至过滤器，删除短码时标记“失效”（过滤器不支持删除，通过Redis辅助存储“失效短码列表”，双重校验）；
- 效果：百万级不存在短码请求在接入层被拦截，MySQL零感知。

- **② 来源合法性校验**：
- IP维度：通过CDN接入WAF（Web应用防火墙），拦截黑名单IP（如近1小时发起1万+请求的IP），同时限制单IP每秒请求数（普通用户≤10次/秒，白名单用户≤100次/秒）；
- 协议维度：仅允许HTTPS请求，拒绝HTTP明文请求，防止请求被篡改；
-  Referer/UA校验：对高风险场景（如跳转支付链接的短码），校验Referer是否为信任域名，拦截无UA/异常UA（如爬虫脚本）的请求。

### （3）业务层：行为风控，精准识别恶意操作

针对通过接入层的“漏网请求”，基于Redis实现轻量级行为风控，延迟控制在1ms以内：

- **① 短码查询行为风控（防猜解+防攻击）**：
- 单IP短码查询失败计数：Redis用Hash存储“IP→失败次数”，1分钟内失败≥20次，触发IP临时封禁（10分钟），封禁信息同步至Nginx；
- 短码查询频率限制：对同一短码，限制单IP每秒查询≤5次，防止通过高频请求触发缓存击穿；
- 异常模式识别：通过Lua脚本识别“短码连续递增/递减请求”（如t.cn/a1b2c3→a1b2c4→a1b2c5），判定为猜解攻击，直接拦截并拉黑IP。

- **② 短码生成行为风控（防恶意生成）**：
- 用户身份绑定：生成短码需关联用户ID（游客通过设备指纹标识），单用户/设备每日生成短码≤100条，超量需验证码验证；
- 长URL预审核：集成第三方恶意链接检测API（如腾讯云/阿里云），生成短码前同步校验长URL是否为钓鱼/病毒链接，审核不通过则拒绝生成；
- 违规短码快速下线：建立“短码黑名单”，发现违规短码后，通过Redis设置“短码→黑名单标记”，接入层直接拦截该短码的跳转请求。

### （4）数据层：加密脱敏，防止信息泄露

针对短码猜解导致的隐私泄露风险，从数据存储和传输层面强化防护：

- **短码增强随机性**：在原有“机器ID+时间戳+随机数”基础上，增加“用户ID哈希后缀”，短码长度从8位扩展至10位（仍满足易传播需求），降低猜解概率——62^10≈8.39万亿条短码，遍历成本极高；

- **敏感长URL加密存储**：对包含隐私信息的长URL（如带token的链接），在MySQL存储时用AES-256加密，Redis缓存时存储加密后的长URL，跳转前在应用服务解密，防止Redis数据泄露导致隐私暴露；

- **操作日志审计**：所有短码生成/跳转请求记录日志（含IP、时间、用户ID），日志保留30天，支持异常行为追溯（如某IP批量猜解短码的完整轨迹）。

### （5）安全设计效果验证

- 不存在短码攻击：接入层布隆过滤器拦截率≥99%，MySQL查询量降低至原来的1%以下，极端攻击下MySQL负载无明显波动；

- 短码猜解攻击：单IP猜解失败20次后临时封禁，猜解成功概率低于0.001%；

- 恶意生成攻击：长URL审核通过率≥99.5%，违规短码下线响应时间≤5秒。

高可用的核心是“冗余+容错+快速恢复”，通过多活部署、故障隔离、降级兜底，确保系统可用性达到99.99%（每年故障时间不超过52分钟）。

## 1. 多活部署：跨地域容灾，避免单点故障

采用“两地三中心”的多活架构，核心组件全冗余：

- **接入层**：全国部署CDN节点，将短URL跳转请求就近调度，同时Nginx集群部署在至少2个可用区，单节点故障自动剔除；

- **缓存层**：Redis集群按“主从+哨兵”部署在3个可用区，主节点故障时，哨兵在10秒内选举新主，从节点实时同步数据（采用RDB+AOF混合持久化，避免数据丢失）；

- **存储层**：MySQL采用主从复制架构，主库部署在A区，从库部署在B区，主库故障时通过MHA（主从高可用工具）30秒内切换至从库，同时开启binlog日志，确保数据零丢失。

即使某一地域（如A区）整体故障，B区的从库、Redis从节点可立即接管服务，用户请求通过CDN调度至B区，业务无感知。

## 2. 故障容错：熔断+降级，保障核心功能

当后端服务（如MySQL、Redis）出现故障时，通过熔断降级机制避免“级联故障”，优先保障“短URL跳转”这一核心功能：

- **熔断机制**：用Sentinel或Hystrix监控Redis和MySQL的调用状态，当某组件错误率超过50%时，立即熔断该组件的调用，避免大量超时请求阻塞线程；

- **降级策略**：
        Redis熔断：暂时直接查询MySQL（仅核心跳转功能，关闭短码生成功能）；

- MySQL熔断：启用本地缓存的“热点短码映射”（提前缓存TOP10万热点数据），跳转请求优先用本地数据，短码生成功能暂停；

- 极端情况：若所有服务均故障，返回预设的“系统维护页”，但通过CDN缓存的静态页面保障用户可见。

## 3. 监控与恢复：秒级发现，分钟级恢复

高可用离不开完善的监控与自动恢复机制：

- **全链路监控**：用Prometheus+Grafana监控各层QPS、延迟、错误率（如Redis查询延迟>5ms、MySQL错误率>1%立即告警）；

- **自动恢复**：通过Shell脚本或K8s探针实现“故障自愈”——如Redis从节点故障时自动重启，Nginx节点异常时K8s自动重新调度；

- **数据恢复**：Redis数据丢失时，通过MySQL全量备份+binlog日志恢复；MySQL主库故障时，从库30秒内切换为主库，数据零丢失。

# 四、设计实例：高并发场景下的系统表现

以“电商大促活动”为例，短URL系统需支撑10万QPS查询、1万QPS写请求（生成短码），设计后的表现如下：

## 1. 性能表现

- 短URL跳转：99%请求延迟<3ms（Redis命中），1%冷数据延迟<50ms（MySQL查询）；

- 短码生成：99.9%请求延迟<5ms（本地缓存取码+Redis绑定），长URL去重命中率约15%（减少重复分配），无并发冲突；

- 系统并发：Redis集群（3主3从）支撑10万QPS查询，MySQL分16表支撑1万QPS写请求。

## 2. 故障场景表现

- 场景1：Redis主节点故障→哨兵10秒选举新主，从节点数据同步完成，期间1%请求延迟升至50ms（查MySQL），无业务中断；

- 场景2：MySQL主库故障→MHA 30秒切换至从库，期间短码生成功能暂停，跳转功能正常（依赖Redis）；

- 场景3：某可用区整体故障→CDN自动将请求调度至其他可用区，Redis和MySQL从节点接管服务，用户无感知；

- 场景4：百万级不存在短码攻击→接入层布隆过滤器拦截99%请求，剩余1%被Redis空值缓存拦截，MySQL负载稳定在正常水平的5%以下。

# 五、总结：设计核心要点（面试提炼）

面试官，总结来说，短URL系统的“高性能+高可用+高安全”是三位一体的设计目标，核心是“**安全打底、性能前置、冗余兜底**”，可提炼为四个关键点：

1. **性能优化核心**：以Redis为核心构建缓存体系（覆盖99%查询）；短码“预生成池+实时绑定”避免并发冲突，长URL去重减少冗余，将读写延迟控制在毫秒级；

2. **高可用核心**：全组件多活部署（跨可用区/地域），配合熔断降级机制，实现“故障不扩散、核心功能不中断”；

3. **安全防护核心**：接入层布隆过滤器拦截不存在短码攻击，行为风控识别恶意操作，加密脱敏防止数据泄露，从源头抵御攻击；

4. **落地关键**：安全设计需“轻量不耗性能”（如布隆过滤器、Lua脚本），与原有架构无缝衔接，既不影响用户体验，又能保障系统底线。

这套设计既满足了大规模用户的性能需求，又通过全链路容错和安全防护保障了高可用与高安全，同时具备良好的扩展性（如Redis、MySQL可横向扩容），可支撑业务从百万级到亿级用户的增长。

面试官，总结来说，短URL系统的高性能与高可用设计，核心是“**将压力前置、用冗余兜底**”，可提炼为三个关键点：

1. **性能优化核心**：以Redis为核心构建缓存体系（覆盖99%查询）；短码“预生成池+实时绑定”避免并发冲突，长URL去重减少冗余，将读写延迟控制在毫秒级；

2. **高可用核心**：全组件多活部署（跨可用区/地域），配合熔断降级机制，实现“故障不扩散、核心功能不中断”；

3. **容错核心**：针对缓存、数据库的典型故障（雪崩、击穿、主从切换），设计专项防护策略，确保系统在极端场景下仍能运行。

这套设计既满足了大规模用户的性能需求，又通过全链路容错保障了高可用，同时具备良好的扩展性（如Redis、MySQL可横向扩容），可支撑业务从百万级到亿级用户的增长。
> （注：文档部分内容可能由 AI 生成）